<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3笔记]]></title>
    <url>%2F2019%2F01%2F10%2Fpython%2F%5BPython3%5D%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录学习Python3的笔记。 参考资料 python3文档 认识pythonpython代码 Python代码不能压缩和混淆； 命令行操作命令行信息12345# 获取命令行参数import sysprint(sys.argv)# 获取当前Python命令的可执行文件路径print(sys.executable) 退出控制台12//windows$ exit() 语句换行使用三引号开头表示多行语句，再次使用三引号结束，如下： 12345&gt;&gt;&gt; '''... hello... world... ''''\nhello\nworld\n' python版本信息1$ python --version 输入输出123//input可以不带参数num=input("请输入一个数字");print(num); 运行python文件1$ python hello.py 编程规范语句写法注意 单行语句：不需要加“;”作为结束符； 代码块：不需要{}包裹，而是使用四个空格(非tab键)缩进包裹，每个语句块结束都要空出一行； 注释：单行注释使用#，多行注释使用三引号； 12# 单行注释&apos;&apos;&apos;多行注释&apos;&apos;&apos; 变量命名：以小写字母开头，可以使用驼峰命名或者下划线分割字母的方式命名； 函数命名：函数名使用小写字母，单词之间用_下划线分割； 语句换行： 123456789# 方式一：末尾加\：换行【不推荐是使用】from xlib.firstlib import a, b,\ cprint(&apos;end&apos;)# 方式二：圆括号包裹换行【推荐使用】from xlib.firstlib import (a, b, c)print(&apos;end&apos;) 变量变量python是动态语言，定义变量直接对变量赋值，而无需指定变量类型； 12y = 10x = y 变量命名变量命名：以小写字母开头，可以使用驼峰命名或者下划线分割字母的方式命名； 变量的类型 值类型（不可改变）：int、str、tuple 引用另类型（引用类型）：list、set、dict 变量内存地址使用id(var)获取变量var的内存地址： 123&gt;&gt;&gt; x = 10&gt;&gt;&gt; id(x)140707502150976 常量python中并未严格定义常量的表达式，只是推荐用大写字母来表示常量； 1PI = 3.14159265359 运算符算数运算符12+、-、*、/、//(整除)、%**(次方)：2**3=8 赋值运算符1=，+=，*=，/=，%=，**=(幂赋值运算符)，//= 关系运算符比较值是否相等，返回布尔值； 1==，!=，&gt;,&lt;,&gt;=,&lt;= 逻辑运算and、or和not来表示计算机的与、或和非运算； 成员运算符 in：1 in [1,2]=true （注意：字典的成员运算只针对key） not in : 与in相反； 身份运算符返回布尔值 is ：比较的是内存地址是否相等； is not：与is相反； 位运算符位运算符先转换成2进制进行运算结果再转换回来； 123456&amp;：1&amp;1=1,1&amp;0=0,0&amp;0=0；|^(按位异或)~&lt;&lt;&gt;&gt; 位运算符还可以用于集合之间的运算： 求集合交集：{1,2}&amp;{1}={1} 求集合合集：{1,2,3,4}|{3,4,7}={1,2,3,4,7} 运算符优先级运算符优先级从最高到最低如下表： 运算符 描述 ** 指数运算 (最高优先级)，如：2**3=8 ~、+、- 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) *、/、%、// 乘，除，取模和取整除 +、- 加法减法 &gt;&gt;、&lt;&lt; 左移、右移位运算符 &amp;、 按位与 ^、丨 运算符 &lt;=、&lt;、&gt;、&gt;= 比较运算符 &lt;&gt;、==、!= 比较运算符 =、%=、/=、//=、-=、+=、*=、**= 赋值运算符 is、is not 身份运算符 in、not in 成员运算符 and、or、not 逻辑运算符(and的优先级大于or) 数据类型数据类型概览 基础数据类型有： 整数(int)：十六进制0x44表示整数更方便，Python的整数没有大小限制； 浮点数(float)：e代替10，如1.23e9，Python的浮点数没有大小限制，但是超出一定范围就用inf表示无限大； 字符串(str)； 布尔值(bool)：True（非0的数值或非空的类型） False（0或空值或None） ，可以使用or、and、not(或与非)运算表达式表示； None(NoneType)：空值； bytes: 字节，用带b前缀的单引号或双引号字符串表示，如：b’abc’； complex(复数)：python复数单位用j表示，如36j（a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位）； 2. 全部数据类型概览图 思维导图中的数据类型有以下特点： 不可变的类型有：数字、字符串、元组； 有序的的类型有：字符串、列表、元组，有序的数据类型可以用索引(索引是从0开始)访问、可以对序列进行截取的切片操作； 无序的数据类型：集合、字典，没有索引，不可以通过切片操作来截取； 数据类型相关方法获取数据的类型12&gt;&gt;&gt; type(0);&lt;class 'int'&gt; 判断数据类型判断数据类型的正确方式：isinstance(var_name, data_type),该方法返回bool值； 12&gt;&gt;&gt; isinstance(1,int)True 数据类型相互转换123456789101112131415161718192021222324# str/float-&gt;intint('1') # 1int(0.01) # 0# 将进制数转换为int类型的10进制数：int(str_x,base=进制)int('1001',2) # 9int('1001',base=2) # 9# int/list/tuple-&gt;strstr(1) # '1'str([1,2]) # '[1,2]'# tuple-&gt;listlist((1,2,3)) # [1,2,3]# str-&gt;bytesbytes('hello', encoding='utf-8')'str'.encode('utf-8')# bytes-&gt;strb=b'\xe9\x80\x86\xe7\x81haha\xab'b.decode('utf-8',errors='ignore') # 忽略非法字符，用strict会抛出异常#...以此类推其它类型转换 数字数字包括整数、浮点数、负数、进制数… 进制数常见进制数 二进制：0b作前缀； 八进制：0o作前缀； 十六进制：0x作前缀； 进制转换方法 任意进制数转二进制：bin(任意进制数) 12310-&gt;2：bin(10)8-&gt;2：bin(0o1)16-&gt;2：bin(0xE) 任意进制数转十进制：int(任意进制数) 任意进制数转八进制：oct(任意进制数) 任意进制数转十六进制：hex(任意进制数) 数学运算保留小数round(number[,n])：number四舍五入保留n位小数； 12//示例：round(3.2132,2) 布尔类型 type = bool 非零数值、非空字符串、非空list等，就判断为True，否则为False。 True、False表示布尔值（请注意大小写）； 布尔值可以用and(与)、or(或)和not(非)运算来表示； 布尔值可以用条件运算的结果来表示； 空值 type = None 空值用None表示。 None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 判空操作： 123456//非空判断if a: pass//空判断if not a: pass 字符串 type = str 编码 Python 3的字符串使用Unicode，直接支持多语言。 UTF-8 UTF-8编码是可变长编码，UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，对比Unicode，更加节省空间； 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节 Python文件设置编码当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码 转义字符常用\表示转义字符，常用方式： 换行符：\n 横向制表符：\t 回车：\r 格式化字符串格式化字符串的方法： 在字符串中使用%占位符，字符串后跟%，%后跟需要被替换的字符串； 使用字符串的format方法; 占位符%格式化字符串 动态字符串可以使用%占位符的方式格式化字符串，常见占位符如下： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 【示例】 12345678910111213//替换单个字符串&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'//多个替换&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.'//保留2位整数，区分是否补0的情况：&gt;&gt;&gt; print('%2d-%02d' % (3, 1))3-01//保留两位小数：&gt;&gt;&gt; print('%.2f' % 3.1415926)3.14 format方法格式化字符串另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 字符串操作方法长度len(str); len()函数实际上是调用str对象的len()方法来获取字符串的长度,二者等价； 1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; &apos;ABC&apos;.__len__()3 乘法复制字符串乘法(字符串复制)：重复n次输出乘号前面的字符串; 123// [示例]&gt;&gt;&gt; "hello"*3;'hellohellohello' 索引取值 如果下标越界会报IndexError 123456//从左到右:&gt;&gt;&gt; 'hello'[0];'h'//从右到左:&gt;&gt;&gt; 'hello'[-2];'l' 索引切片(截取)字符串按索引截取：str[a:b:step],截取str的a到b索引的元素，不包含b,步长为step; str[star,end]切片 123456789101112131415//按索引截取&gt;&gt;&gt; "hello"[1:2];'e'//[6:]：从第n个截取到最后；&gt;&gt;&gt; "hello"[0:];'hello'//[6:0]：一个都不截取；&gt;&gt;&gt; "hello"[5:];''//从索引为0的元素截取到整个字符串倒数第2个元素：&gt;&gt;&gt; "hello"[:-2];'hel'//从倒数第2个元素截取到最后：&gt;&gt;&gt; "hello"[-2:];'lo' str[star,end,step]切片 1&quot;hello world&quot;[0:8:2] # 从索引为0截取到索引为7的位置，步长为2； 字符索引获取字符串在另一个字符串中的索引： 12&gt;&gt;&gt; 'hello'.index('o');4 字符串替换replace方法会替换字符串中所有符合条件的字符串或字符； 12&gt;&gt;&gt; 'hello'.replace('lo','*');'hel*' 去除左右空格12&gt;&gt;&gt; ' hello '.strip();'hello' 字符串转换123456789101112//获取字符的整数编码:ord(str);//把整数编码转换为对应的字符:chr(code);//字符串转bytes:'ABC'.encode('ascii');'中文'.encode('utf-8');//bytes转字符串:b'ABC'.decode('ascii'); //'ABC'b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8') //'中文'//bytes解码，使用errors='ignore'忽略错误的字节b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore') //'中' list type = list list(列表)是一个可变的有序表，可以添加或删除其中的元素。 列表的定义列表类似js中的数组，支持任意数据类型的数据组合，支持一维到多维list; 1234//一维：任意类型的组合，通过下标索引来访问；arr1 = [1,2,3,4,&apos;hello&apos;,True];//多维列表：实质就是嵌套列表，通过arr[1][2]这种形式访问；[[1,2],[3,4,5],[True,False],&apos;hello&apos;] 列表的操作列表的操作与有序数据类型的操作类似，请参考字符串的操作； CRUD操作list=[]列表 1234567891011121314//添加元素list.append(&apos;Adam&apos;)//添加元素到指定索引位置list.insert(1, &apos;Jack&apos;)//删除末尾元素list.pop()//删除指定索引位置的元素list.pop(1)//指定位置元素重新赋值list[1] = &apos;Sarah&apos;//获取最后一个元素list[-1]//获取指定索引的值list[0] 列表长度1len(list) 数学运算 列表的加法：[1,2]+[3]=[1,2,3] 列表的乘法：[1,2]*2=[1,2,1,2] 截取支持类似字符串的冒号（:）切片操作，截取指定索引的列表元素（请参考字符串的操作）； 函数生成列表使用list(range(startIndex,stopIndex,stepLength))表达式生成list： 1list(range(1, 22)) 列表生成式列表生成式指在[]内使用一行表达式生成一个列表list的表达式； 列表生成式作用的目标可以是列表、集合、元组，最终结果是list; 1.列表生成式作用于list: 1234567891011121314151617# 循环列表生成式print([x * x for x in range(1, 11)])# os.listdir可以列出当前文件夹下的文件和目录import osprint([d for d in os.listdir('.')])# 多层循环列表生成式print([m + n for m in 'ABC' for n in 'XYZ'])print([m + n + str(x) for m in 'ABC' for n in 'XYZ' for x in range(1, 4)])# 带判断的列表生成式print([x * x for x in range(1, 11) if x % 2 == 0])# 列表生成式遍历dict字典内容d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125;print([k + '=' + v for k, v in d.items()]) 2.列表生成式作用在元组： 1234a = (1, 2, 3)r = [i ** i for i in a]print(r)# [1,4,9] 元组(tuple) type = tuple 元组：tuple。tuple和list非常类似,都是Python内置的有序集合，但是tuple不可变，一旦初始化就不能修改,没有添加和删除方法,所以代码更安全，如果可能，能用tuple代替list就尽量用tuple; 注意：tuple如果内含可变元素，可变元素内部可以改变； 元组定义tuple的元素定义在圆括号()里; 123456//定义一个元组：tupleA = ('Michael', 'Bob', 'Tracy',1,22)//定义一个空的tuple:t = ();//定义只有1个元素的tuple:t = (1,) 函数生成元组使用tuple(range(startIndex,stopIndex,stepLength))方法直接生成一个tuple: 1tuple(range(1, 22)) 序列有顺序，每个元素都分配一个序号,序列包括：列表、元组、str，他们之间的操作都类似； 序列操作切片(截取)支持切片(截取)操作，参考字符串切片操作； 逻辑包含支持逻辑in、not in运算符： 122 in [1,2] # True2 not in [1,2] # False 序列内置函数最大值1max(序列) 最小值1min(序列) 长度1len(序列) joinjoin函数使用分隔符将序列类型的变量组合成一个字符串； 1234s = ','.join('hello')print(s)# h,e,l,l,o# &lt;class 'str'&gt; 集合 type = set 集合的定义 使用花括号{}包含元素,元素是不可变类型数据，如字符串、数字和元组； set是一组元素的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 定义集合变量 方式一：直接赋值 123&gt;&gt;&gt; x=&#123;1,2,3,&quot;hello&quot;&#125;&gt;&gt;&gt; type(x)&lt;class &apos;set&apos;&gt; 方式二：通过set([…])定义，需要提供一个list作为输入集合; 123&gt;&gt;&gt; x=set(&#123;1&#125;)&gt;&gt;&gt; x&#123;1&#125; 空集合空集合：set()，注意{}不能表示空集合，type({})=dict(字典) 12&gt;&gt;&gt; type(set())&lt;class &apos;set&apos;&gt; 集合的操作添加通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果； 1234&gt;&gt;&gt; x = &#123;1&#125;&gt;&gt;&gt; x.add(4)&gt;&gt;&gt; x&#123;1, 4&#125; 删除通过remove(key)方法可以删除元素； 1234&gt;&gt;&gt; s = &#123;1,2,3&#125;&gt;&gt;&gt; s.remove(1)&gt;&gt;&gt; s&#123;2, 3&#125; 集合的运算 支持逻辑包含：in、not int； 支持求集合差集：{1,2,3}-{1}={2,3} 支持求集合交集：{1,2}&amp;{1}={1} 支持求集合合集：{1,2,3,4}|{3,4,7}={1,2,3,4,7} 字典 type = dict Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 特点 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 无序的(不支持索引)、不支持切片操作、不重复。 字典的定义 字典的定义类似java的map,用花括号包裹许多个key:value，用逗号分隔； 语法格式：{key1:value1,key2:value2,…} 注意：key是不可变类型，value可以是任意类型； 空字典空的字典：type({})=dict 示例 例1： 123&gt;&gt;&gt; d = &#123;1:&apos;one&apos;,&apos;two&apos;:2&#125;&gt;&gt;&gt; d&#123;1: &apos;one&apos;, &apos;two&apos;: 2&#125; 例2： 123&gt;&gt;&gt; x = &#123;1:2,&apos;1&apos;:1,(1,3):1,3:&#123;1,3&#125;,6:&#123;&apos;one&apos;:&apos;hello&apos;&#125;&#125;&gt;&gt;&gt; x&#123;1: 2, &apos;1&apos;: 1, (1, 3): 1, 3: &#123;1, 3&#125;, 6: &#123;&apos;one&apos;: &apos;hello&apos;&#125;&#125; key的特点 key不能相同，相同则会覆盖对用的value值； key中数字和字符串被认为不同的key,如1，“key”; 123&gt;&gt;&gt; x = &#123;1:2,&apos;1&apos;:1&#125;&gt;&gt;&gt; x&#123;1: 2, &apos;1&apos;: 1&#125; key的数据类型：是不可变的类型，包括：int，str，元组； 12345&gt;&gt;&gt; x = &#123;1:2,&apos;1&apos;:1,(1,3):1&#125;&gt;&gt;&gt; x&#123;1: 2, &apos;1&apos;: 1, (1, 3): 1&#125;&gt;&gt;&gt; x.get((1,3))1 字典的操作添加 直接通过d[key]=value的方式赋值； 1234&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d[1]=&apos;one&apos;&gt;&gt;&gt; d&#123;1: &apos;one&apos;&#125; 通过内置函数setdefault(key,defaultValue):如果键不存在于字典中，将会添加键并将值设为defaultValue; 12345&gt;&gt;&gt; d=&#123;&#125;&gt;&gt;&gt; d.setdefault(1,&apos;one&apos;)&apos;one&apos;&gt;&gt;&gt; d&#123;1: &apos;one&apos;&#125; 根据key获取值 d[key]: 中括号索引的方式，如果key不存在，dict就会报错； 123&gt;&gt;&gt; d = &#123;1:&apos;one&apos;&#125;&gt;&gt;&gt; d[1]&apos;one&apos; d.get(key)的方式：如果key不存在，可以返回None； 12345678910&gt;&gt;&gt; d = &#123;1:&apos;one&apos;&#125;&gt;&gt;&gt; d[1]&apos;one&apos;&gt;&gt;&gt; d.get(1) &apos;one&apos;&gt;&gt;&gt; d =&#123;&#125;&gt;&gt;&gt; d.get(1)&gt;&gt;&gt; type(d.get(1))&lt;class &apos;NoneType&apos;&gt; d.get(key,default)的方式：如果key不存在返回default，但不会新增到字典中； 1234567&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d&#123;&#125;&gt;&gt;&gt; d.get(1,&apos;one&apos;)&apos;one&apos;&gt;&gt;&gt; d&#123;&#125; 删除key要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 12345&gt;&gt;&gt; d = &#123;1:&apos;one&apos;&#125;&gt;&gt;&gt; d.pop(1)&apos;one&apos;&gt;&gt;&gt; d&#123;&#125; 遍历字典语法： 12345678910111213141516# 直接遍历字典，默认遍历结果是dict的keystudents = &#123;'name': '张三'&#125;for key in students: print(key) # 遍历返回key_value为key和value组成的元组for key_value in students.items(): print(key_value) # 遍历key：for key in students.keys(): print(key) # 遍历value：for value in students.values(): print(value) 示例： 1234d = &#123;1: 'one', 2: 'two'&#125;for key_value in d.items(): print(key_value)# 结果：(1, 'one') (2, 'two') 数据解构赋值序列解包类似js里的解构赋值，但是解构左右两边数量必须对等； 生成器一边循环一边计算,根据前面的元素推算后面的元素的机制，称为生成器generator,generator也是可迭代对象； 表达式生成器构建一个generator只需要将列表生成式的[]换成()即可得到generator对象； 12345678L = [x * x for x in range(3)]g = (x * x for x in range(3))# print(g)print(next(g))print(next(g))print(next(g))# 溢出时报错: StopIterationprint(next(g)) 函数生成器 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator； yield关键字：在每次调用next()的时候，执行函数遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 定义示例以实现一个斐波那契数列函数为例来实现一个generator： 12345678910111213141516171819202122# 原实现斐波那契数列的函数实现def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done' fib(3)# yield关键字实现generator：def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'f = fib(6) 函数返回值如果定义函数生成器最终return返回一个值，如果需要获得返回值的话，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 12345678910111213141516def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' f = fib(6)while True: try: x = next(f) print('g:', x) except StopIteration as e: print('Generator return value:', e.value) break 生成器迭代使用next(g)可以遍历generator,但是不知道临界，所以一般都使用循环来迭代generator(不需要关心StopIteration的错误): 1234# 循环来遍历生成器g = (x * x for x in range(3))for n in g: print(n) 迭代器Iterable 可以直接作用于for循环的对象统称为可迭代对象：Iterable 可迭代的数据类型有： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 Iterable对象判断可以使用isinstance(aim,Iterable)内置函数来判断是否是Iterable对象： 1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False Iterator 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 Python的for循环本质上就是通过不断调用next()函数实现的； Iterator对象判断可以使用isinstance()判断一个对象是否是Iterator对象： 123456789&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)False Iterable转Iterator 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)True Iterator数据流对象 Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 条件控制语句条件判断if条件判断语句，判断表达式必须，返回结果可以使用pass占位，pass是空语句/占位语句； 语法12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 1234567891011121314151617# ifif expression: pass # if...elseif condition: passelse: pass# if...elif..elseif condition: passelif expression: passelse: pass 示例12345678910111213# eg1：MOOD=Falseif mood : print('good mood')else : print('bad mood')# eg2：CONDIITON = Falseif CONDIITON: print('True')elif not CONDIITON: print('False') 三元表达式 python中的三元表达式的效果类似java中的三目运算符(expression?r2:r2); 表达式格式：结果为真的返回 if 表达式 else 结果为假的返回 示例： 12345# python中的三元表达式x = 2y = 3r = x if x &gt; y else yprint(r) 循环while循环语法当while表达式满足会一直循环执行while语句块中的逻辑，当不满足时跳出循环，或者执行else语句块； 123456789# whilewhile expression: pass# while...else...while expression: passelse: pass 示例12345678910111213# eg1counter = 1while counter&lt;=10: print(counter) counter+=1 # eg2counter=0while counter&lt;=10: counter+=1 print(counter)else: print(&apos;结束&apos;) for循环 for循环的目标是可迭代对象类型(Iterable)的数据，就可以使用for循环进行迭代。 判断一个对象是否是可迭代对象，通过collections模块的Iterable类型判断； 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False for…in…循环1234# for...in...循环遍历列表arrays=['apple','orange','banana']for fruit in arrays: print(fruit+',', end='') 12345# 嵌套for...in...循环遍历列表；arrays=[['apple','orange','banana'],(1,3,4)]for x in arrays: for y in x: print(y) for…in…else循环1234567# for...in...else循环结束后执行else;arrays=[['apple','orange','banana'],(1,3,4)]for x in arrays: for y in x: print(y)else: print('game over') for…in range循环for…in range(startIndex,endIndex,step)循环按索引访问数据，不包含endIndex; 123456789# 以步长1，遍历列表：arrays = [1,2,3,4,5,6,7,8]for i in range(0,len(arrays),1): print(arrays[i], end=' | ') # 以步长1，倒序遍历列表：倒序时步长要为负数；arrays = [1,2,3,4,5,6,7,8]for i in range(len(arrays)-1,0,-1): print(arrays[i], end=' | ') for循环获取索引 Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： eg1: 遍历列表： 123456&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):... print(i, value)...0 A1 B2 C eg2: 遍历由元组组成的列表： 1234567for i, (x, y) in enumerate([(1, 1), (2, 4), (3, 9)]): print(i, x, y) # 结果# 0 1 1# 1 2 4# 2 3 9 循环控制语句breakbreak 仅终止当前循环,终止当前循环后不会执行当前循环的else,如果外层还有循环，则继续执行外层的循环； 1234567arrays=[1,3,4]for x in arrays: if x == 3: break print(x)else: print('break终端循环后，不会执行else的逻辑') continuecontinue：结束当前循环，继续执行下个循环； 1234567arrays=[1,3,4]for x in arrays: if x == 3: continue print(x)else: print('结束') Python实现java语言switch特性Python中没有类似java语言的switch API,可以用elif或者字典来代替; 字典switch这里主要是dict字典来实现switch语法； key对应简单的值： 1234567# 简单的switch,利用字典的key实现swicher = &#123; 1:'one', 2:'two', 3:'three'&#125;print(swicher.get(7,'default')) key对应函数： 12345678910111213141516171819202122def getOne(*args): return 'one'def getTwo(*args): return 'two'def getThree(*args): return 'three'def getDefault(*args): return 'invalid value='+str(args[0])swicher = &#123; 1 : getOne, 2 : getTwo, 3 : getThree&#125;day = 12# 函数中传参数，在最后的()中传：day_name = swicher.get(day,getDefault)(day)print(day_name) 函数内置函数 内置函数文档地址 python内置了许多函数，可以直接调用,常用的内置函数有： abs(x): 计算x的绝对值； max(a,b,…): 获取多个参数的最大值； 函数命名函数命名：函数名使用小写字母，单词之间使用下划线(_)分割； 定义函数 定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。 return None也可以简写为return。 py文件定义函数 定义一个空函数： 12def funcname(parameter_list): pass 定义一个求绝对值的函数； 12345678def my_abs(x): if x &gt;= 0: return x else: return -x# 调用函数print(my_abs(-5)) # 5 python交互环境定义函数在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下： 12345678&gt;&gt;&gt; def my_abs(x): ... if x &gt;= 0: ... return x ... else: ... return -x ... &gt;&gt;&gt; my_abs(-9) 9 函数返回多个值函数返回多个值时，python将多个值放到一个tuple中，语法上可以省略(): 1234def multi_value(): return 1, 88print(multi_value()) # (1, 88) 函数的参数默认参数定义函数时，函数的参数可以设置默认值,设置默认值使用等号直接赋值即可： 1234def myfn(name, sex='man'): return 'name=' + name + ',sex=' + sexprint(myfn('ethan')) 定义默认参数要牢记一点：默认参数必须指向不变对象！ 可变参数 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple. 定义函数时接收的参数个数不确定时，可以在参数前加*，此时参数就是可变参数； 在调用接收可变参数的函数时，如果传入已有的list或tuple作为多个参数时,需要在调用处给list或tuple前也加*，这样list或tuple的元素才能正确转化为一个元组，否则转化后的元组只有整个list或整个tuple作为1个参数； 1234567891011def myfn(*args): print(type(args)) print(args) returnprint(myfn(*[1, 33]))# 结果：# &lt;class 'tuple'&gt;# ('ethan', 1, 33)# None 关键字参数 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict. 关键字参数使用 **kw表示； 在调用接收关键字参数的函数时，如果传入已有的dict作为多个参数时,需要在调用处给dict前也加**，这样dict的元素才能正确转化为一个dict，否则转化后的dict只有整个dict作为1个参数； 1234567891011def myfn(**kw): print(type(kw)) print(kw) returnd = &#123;'name': 'ethan'&#125;print(myfn(**d))# 结果：# &lt;class 'dict'&gt;# &#123;'name': 'ethan'&#125;# None 命名关键字参数命名关键字参数主要是为了限制调用者传入哪些参数名的参数，如果传入了函数未声明接收的参数名则会报错，是非必要参数； 注意点 12345- 关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。- 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了。- 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。- 命名关键字参数可以有缺省值，即可以设置默认值；- 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数。 示例 1234567def myfn(name, *, city, age=23): print(name + "," + str(age) + "岁,现居" + city) returnd = &#123;'city': '北京'&#125;myfn('ethan', **d)# 结果：ethan,23岁,现居北京 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 要点12- 虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。- 对于任意函数，都可以通过类似func(*args, **kw)的形式定义。 示例 12345678910111213def f1(a, b, c='None', *args, name, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'name =', name, 'kw =', kw)def f2(a, b, c='None', *, name, **kw): print('a =', a, 'b =', b, 'c =', c, 'name =', name, 'kw =', kw)d1 = &#123;'name': 'name'&#125;d2 = &#123;'other': 'other'&#125;f1('a', 'b', 'c', '*args', **d1, **d2)# a = a b = b c = c args = ('*args',) name = name kw = &#123;'other': 'other'&#125;f2('a', 'b', 'c', **d1, **d2)# a = a b = b c = c name = name kw = &#123;'other': 'other'&#125; 函数的要点 函数可以赋值给变量：f=fn()-&gt;f()； 函数可以作为参数：fn(fn1())； 函数内可以再定义函数，函数可以作为函数的返回； 函数内的变量和模块的变量同名时，就近原则，优先使用函数内定义的变量； 函数内给模块变量赋值：python就会看做这是重新定义一个与模块变量同名的局部变量； 函数内给模块变量赋值：需要在函数内使用global关键字重新声明一下模块变量为全局变量； 1234567891011121314151617181920# 函数中的函数调用def curve_pre(): a=25 def curve(x): return a*x*x return curve f = curve_pre()print(f(2))# 函数中重新赋值模块变量：origin=0def count_step(step): global origin new_step = origin + step origin = new_step return new_step print(count_step(2))print(count_step(3)) 递归函数如果一个函数在内部调用自身本身，这个函数就是递归函数。 123456def fact(n): if n == 1: return 1 return n * fact(n - 1)print(fact(998)) 递归栈溢出使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)； 解决递归调用栈溢出的方法是通过尾递归优化； 尾递归优化尾递归是指，对函数返回的优化，即：函数返回时调用函数自身，并且，return语句不能包含调用函数自身之外的表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 严重警告：Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。 函数式编程 纯粹的函数式编程语言编写的函数没有变量； Python的函数允许使用变量，因此，Python不是纯函数式编程语言。 函数式编程特点 允许使用变量； 允许把函数本身作为参数传入另一个函数； 函数允许返回一个函数； 函数内可以定义函数； 函数名可以赋值给变量，此时不会立刻执行函数，使用变量名加圆括号f()调用; 闭包当函数返回一个函数名时，函数名对应的函数并没有立刻执行，而是直到调用了f()才执行，这称为闭包(closure). 闭包的特点 闭包返回的函数并未执行，返回函数中不要引用任何可能会变化的变量; 闭包返回的函数每次调用都会返回一个新的函数，并且每次调用互不影响; 闭包返回的函数内，通过nonlocal关键字声明变量不是局部变量，而是父函数的变量； 示例 eg1: 一个简单的闭包 12345678910def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf= count()f() # 9 eg3：闭包返回的函数内的非局部变量： 1234567891011121314151617origin = 0def factory(pos): x = pos def go(step): # nonlocal声明非局部变量，即父函数的变量； nonlocal x new_step = step + x x = new_step return new_step return gotourist = factory(origin)print(tourist(2)) # 2print(tourist(3)) # 5 闭包函数的闭包信息 打印f函数的闭包信息 1print(f.__closure__) 打印f函数闭包内环境变量(环境变量按字母排序对应索引)的值 1print(f.__closure__[0].cell_contents) 闭包的缺点 闭包根函数的变量（环境变量）常驻内存，容易发生内存泄漏； 匿名函数在Python中，对匿名函数提供了有限支持,匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 语法关键字lambda用来修饰匿名函数，使用冒号分割参数和返回表达式，冒号前面的x表示函数参数，冒号后面是返回结果。 123456# 匿名函数示例lambda x: x * x# 等价于def f(x): return x * x 装饰器 在代码运行期间动态增加函数的功能而且不会改变原有函数的定义的方式，称之为装饰器（Decorator）。 装饰器：可以不改变函数逻辑，给函数新增功能； 装饰器函数 定义装饰器函数：定义一个装饰器函数，需要接收一个被装饰函数为参数，装饰器内部定义一个返回被装饰函数的扩展功能函数，最终装饰器函数返回扩展功能函数 (需要注意：扩展函数应该加@functools.wraps(func)修饰，确保最终返回的函数保持被装饰函数本身的属性)。 使用装饰器函数：当我们给被装饰函数上方添加声明：@装饰器函数名，此时直接调用被装饰函数时就得到了扩展的功能，实际是一种装饰模式（AOP编程思想）； 示例 定义一个打印日志的装饰器函数： 12345678910111213141516171819202122import functoolsdef log(func): # @functools.wraps的作用是让返回的wrapper函数保持func函数的属性； @functools.wraps(func) def wrapper(*args, **kw): # 在运行被修饰的函数前打印一行日志 print('call %s() start' % func.__name__) return func(*args, **kw) return wrapper# @log = log(func_test)@logdef func_test(): print("hello") # 调用结束的log print('call %s() end' % 'func_test')f = func_testf()print(f.__name__) 装饰器函数带参数如果装饰器本身需要传入参数，定义最外层装饰器函数接收参数，内部定义一个无参数的装饰器函数，最外层有参数的装饰器函数返回无参数的装饰器函数名即可； 12345678910111213141516171819202122import functoolsdef log_has_argument(text): def decorator(func): # @functools.wraps的作用是让返回的wrapper函数保持func函数的属性； @functools.wraps(func) def wrapper(*args, **kw): print('接收了一个参数text=%s' % text) return func(*args, **kw) return wrapper return decorator# @log = log(args)(func_test)@log_has_argument('我是参数')def func_test(): print("hello") # 调用结束的log print('call func_test() end')f = func_testf() 装饰器通用优化 装饰器内给被装饰函数支持可变参数：func(*args); 装饰器内给被装饰函数支持可变参数和可变关键字参数：func(args,*kw); 偏函数 Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。 创建偏函数12341&gt; 创建偏函: functools.partial就是帮助我们创建一个偏函数的;2&gt; 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数;3&gt; functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值）。4&gt; 调用创建好的偏函数，还可以改变默认参数; 示例 创建一个偏函数：用于求2进制数对应10进制: 1234567import functools# 创建一个偏函数：用于求2进制数对应10进制int2 = functools.partial(int, base=2)print(int2('1000000'))# 调用创建好的偏函数，可以改变默认参数print(int2('1000000', base=10)) 应用场景当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数（偏函数），这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 内建的高阶函数 变量可以指向函数，函数的参数能接收变量，函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。 python提供了许多内建的高阶函数供开发者调用； mapmap将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 语法1&gt; 语法格式： 1map(fn,iterableData) 2&gt; 参数说明： fn：函数； iterableData：iterable类型的数据； 示例 对序列中的每个元素求平方： 123456def f(x): return x * xr = map(f, [1, 2])print(list(r))# [1,4] 将序列的元素都转str: 12&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] reduce reduce函数来自functools模块； reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算,返回一个计算结果，其效果就是： 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 语法1reduce(function, sequence, initial=None) 示例 reduce累加序列中元素的实现： 123456from functools import reducedef fn(x, y): return x + yprint(reduce(fn, [1, 3, 5])) 把序列[1, 3, 5, 7, 9]变换成整数13579: 123456from functools import reducedef fn(x, y): return x*10 + yprint(reduce(fn, [1, 3, 5])) filter Python内建的filter()函数用于过滤序列,filter()函数返回的是一个Iterator; 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 示例 在一个list中，删掉偶数，只保留奇数： 123456def is_odd(n): return n % 2 == 1r = list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))print(r)# [1, 5, 9, 15] sorted Python内置的sorted()函数就可以直接对list进行排序; 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序； 语法12sorted(list, func, reverse):# reverse: 是否倒序； 示例 对list元素求绝对值后再排序： 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs, reverse=false)[5, 9, -12, -21, 36] 注意 默认情况下，对字符串排序，是按照ASCII的大小比较的，由于’Z’ &lt; ‘a’，结果，大写字母Z会排在小写字母a的前面。 模块模块的概念在Python中，一个.py文件就称之为一个模块（Module）。 模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。 模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。 模块的命名 模块名要遵循Python变量命名规范，不要使用中文、特殊字符； 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。 包为了避免模块名冲突，Python引入了按目录来组织模块的方法，称为包（Package）。 包的定义1如果目录文件夹中有一个__init__.py文件，Python就把这个目录当成包，否则Python就把这个目录当成普通目录。 要点121&gt; __init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，它的模块名就是包名。2&gt; 包可以有多级目录，即包内可以包含包，组成多级层次的包结构。 示例 mypackage多级层次的包结构： 123456789mypackage ├─ __init__.py ├─ web │ ├─ __init__.py │ ├─ utils.py │ └─ www.py ├─ __init__.py ├─ abc.py └─ xyz.py 导入模块Python模块文件导入另一个模块后，当前模块就可以通过(包名.)模块名或者别名来访问模块中的所有功能了。 导入模块注意点 当python中的模块1导入了模块2，则模块2里的代码会被执行一遍； 要避免循环导入：如module1引用module2，module2又引用module1； 语法导入其它模块的语法有两种方式： 方式一：import… 方式二：from…import… import…1234import package_name.module_name as alias# package_name: 包名# module_name：模块名# alias: 别名 from…import… 注意点： 123【注意】1&gt; 当使用from...import导入一个模块中的多个成员,用逗号隔开: from utils.m1 import a, b;2&gt; 当使用from...import *时,可以在被导入的模块文件中用__all__=[&apos;elemnt1&apos;,...]列表来表示*要导出的元素名； 语法格式： 1234from [包名.]模块 import 函数/变量from [包名] import 模块# 不推荐用*from [包名][模块] import * 模块导入示例导入内建模块以导入sys模块为例： 1import sys 导入自定义模块1&gt; 创建utils包，在保重创建一个test模块： 1desc = 'from test module' 2&gt; 如果创建一个与test模块不同包的模块main,来使用test模块的功能: 12import utils.testprint(utils.test.desc) 如果导入的模块包级别特别深时，可以使用别名： 12import utils.test as testprint(test.desc) 3&gt; 如果创建一个与test模块同包的模块main,来使用test模块的功能: 12import testprint(test.desc) 作用域作用域有公开的和私有的作用域，来控制模块内的属性是否能被外界访问； 公开作用域 模块内正常的函数和变量名是公开的（public），可以被直接引用； 模块内类似xxx这样的变量是特殊变量，可以被直接引用，但是有特殊用途，我们自己的变量一般不要用这种变量名； 12【特殊变量】模块文件可以定义，如__author__,__name__,__doc__等特殊变量，来表示模块的一些标识; 私有作用域在Python中，是通过下滑线(“_”)前缀来实现私有作用域（private），被私有化的属性不能被外部访问； 1private函数或变量不应该被别人引用，只需给名称加单下划线（&quot;_&quot;）前缀即可； 安装第三方模块pip包管理工具在Python中，安装第三方模块，是通过包管理工具pip完成的。 1234【pip的安装】1&gt; Mac或Linux,pip在安装python时默认安装了； Mac或Linux上有可能并存Python 3.x和Python 2.x，python2只支持pip,python3既支持pip3也支持pip 。2&gt; windows安装python时，确保安装时勾选了pip和Add python.exe to Path。 第三方库的获取 官方地址：一般第三方库都会在Python官方的pypi.python.org网站注册，可以直接在此网站搜索需要的库； anaconda官网 ：一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，Anaconda会把系统Path中的python指向自己自带的Python，可直接使用python命令进入。 安装第三方库 安装Pillow库，参考官方文档，安装命令如下： 1$ pip install Pillow 模块搜索路径Path当使用import加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错ImportError。 默认搜索路径 默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中； 123【查看搜索路径】&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path 自定义模块搜索路径添加自己的搜索目录，有两种方法： 1&gt; 方法一：是直接修改sys.path，添加要搜索的目录(这种方法是在运行时修改，运行结束后失效)。 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/Users/michael/my_py_scripts&apos;) 2&gt; 方法二：是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。 面向对象编程 面向对象的设计思想是抽象出类（Class），根据Class创建实例（Instance）对象； 面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。 类和实例类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 创建类语法格式定义类的语法格式如下： 12class ClassName(object): pass 【注释】 ClassName：类名通常是大写开头的单词，不同于变量名、函数名，类名推荐驼峰命名; (object)：表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 示例123# 创建类class Student(object): pass 类实例定义好了类，就可以通过ClassName()创建类的实例对象,即创建实例是通过类名+()实现的; 类的实例可以自由的访问类公开的成员变量和方法； 可以自由地给一个类的实例变量绑定属性, 此时只作用于此实例，不会影响到其它实例； 示例12345678# 创建类class Student(object): pass# 类的实例对象student = Student()# 可以自由地给一个实例变量绑定属性student.name = 'ethan' 类的构造函数类可以起到模板的作用，可以定义类的构造函数（比普通函数多了个默认不用传的self参数，代表类自身的实例），让类实例化时传入一些默认的属性值，作为类初始化属性的值。 构造函数的默认参数self可以直接给当前类添加新属性 构造函数语法12345通过定义一个特殊的__init__方法，在创建实例的时候，就把设定的必须的属性绑上去；构造函数格式：def __init__(self,*args)【构造函数的参数】- self：默认参数，不需要传；- *args: 其他参数，必须传； 例如：在创建Student类实例的时候，传入name、score属性 12345678class Student(object): def __init__(self, name, score): self.name = name self.score = scorestudent = Student('ethan', 99)print(student.name, student.score)# ethan 99 类变量 概述：类变量必须通过“类名.变量名”来访问和赋值； 获取类的所有变量组成的字典：通过类名.__dict__来访问，返回类所有成员组成的字典； 类方法访问类变量： 121&gt; 类名.变量名2&gt; self.__class__.变量名； 123456789class Student(object): name = '张三' def __init__(self): passStudent.name = 'hello' print(Student.name) # helloprint(Student.__dict__) # &#123;&#125; 实例变量 概述：实例变量必须通过“实例对象.变量名”来访问和赋值； 实例变量的定义：必须在类中用self.变量名定义，才会被添加到实例变量字典中； 实例方法中使用实例变量：最好加self.变量名； 实例变量和类变量的访问：首先会在实例变量里找，没有用self.varname定义时，python会到类中再查找，返回同名的类变量，如果类中也没有，会到父类中继续查找； 实例变量字典：通过对象.__dict__来访问，返回字典； 实例方法 实例方法相对于函数，增加了一个默认参数self，可以直接操作self给当前类添加新属性; 定义类实例的方法实例方法实际就是函数添加了self作为第一个参数，调用时除了self不用传递，其他参数正常传入； 1234567891011class Student(object): def __init__(self, name, score): self.name = name self.score = score # 实例方法封装：打印分数score def print_score(self): print(self.score)student = Student('ethan', 99)student.print_score() 类名访问实例方法123456789101112class Student(object): name = '张三' def __init__(self): self.__name = "ethan" def print_hello(self): print("hello," + self.__name)s = Student()s.print_hello()Student.print_hello(s) 实例方法访问类变量1231. 方法内部直接使用：类名.变量名；2. 方法内部使用__class__内置函数来访问：self.__class__.变量名；3. 实例方法操作类变量：会直接改变类变量； 1234567891011class Test(object): name = 'ethan' def set_name(self, name): # Test.name = name self.__class__.name = namet = Test()t.set_name("张三")print(Test.name)# 张三 实例方法访问实例变量1self.变量名 类方法类方法定义时，也需要用一个标识符cls作为第一个参数（cls同self类似也可以是任意的字符），cls代表类本身，但是方法需要用装饰器@classmethod来声明； 123456789101112class Test(object): sum = 0 # 类方法 # @classmethod:装饰器，标识类方法 @classmethod def do_sum(cls): # 类方法操作类变量 cls.sum += 1 print(cls.sum)Test.do_sum() 要点 在python中类的对象访问类方法是可以的，不推荐使用； 类方法可以访问静态方法； 类方法不能直接访问实例方法； 类的静态方法 概述：静态方法可以同时被类和对象访问，不同于类方法和实例方法的是不需要默认有第一个参数代表静态方法，但是需要装饰器@staticmethod作为静态方法的标识； 12345678910111213class Test(object): # 静态方法可以同时被对象和类访问 @staticmethod def print_info(): print('调用了静态方法')# 对象访问静态方法test = Test()test.__class__.print_info()# 类名访问静态方法Test.print_info() 要点 静态方法可以用类方法代替使用； 静态方法不可以直接访问实例方法； 静态方法可以访问类方法：类名.方法名(); 类的访问限制私有变量私有变量如果要让内部属性不被外部访问，可以把属性的名称前加上双下划线，在Python中，实例的变量名如果以开头，就变成了一个私有变量（private）。 要点 私有变量只有类的内部可以访问，外部实例不能访问。 可以通过对外暴露返回私有变量的方法，供外部调用来访问私有成员； 注意：同时以双下划线做前缀和后缀的变量是特殊变量，类的外部实例可以直接访问。 示例： 123456789101112131415161718192021222324class Student(object): # 私有变量 __age = 28 def __init__(self, name): # 私有变量 self.__name = name self.sex = 'man' def print_info(self): print(self.__name, self.__age) # 返回私有变量name def get_name(self): return self.__name # 修改私有变量name def set_name(self, name): self.__name = namestudent = Student('ethan')student.print_info() # ethan 28student.set_name("令狐冲")print(student.get_name()) # 令狐冲 单下划线前缀属性通常模块的私有成员使用单下划线做前缀，类似的，在类中，以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 私有方法同私有变量 访问私有属性 强烈建议不要这么干 Python私有属性不是绝对的，可以通过如下格式访问： 1实例名._类名__方法名()或属性名 1234567891011121314151617# 示例class Animal(object): __name = '二哈' __name2 = '二哈' _age = 10 def __init__(self, name, age): self.__name = name self._age = age def __print_name(self): print(self.__name)dog = Animal("三哈", 15)print(dog._Animal__name)print(dog._Animal__print_name()) 继承 Python的类也支持类似java中的继承，在定义类时，类名后面紧跟的圆括号里的类名就是当前定义的类需要继承的父类，通常无需继承时，默认要写object表示所有类的父类； Python允许使用多重继承，继承多个类时，用逗号分隔即可； 单继承示例12345678910111213141516# 示例1class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): passclass Cat(Animal): passdog = Dog()dog.run()cat = Cat()cat.run() 多继承示例12345678910111213# 示例2class Animal(object): passclass Runnable(object): def run(self): print(&apos;it is running...&apos;)class Dog(Animal, Runnable): passdog = Dog()dog.run() 多态同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说，多态就是用基类的引用指向子类的对象。 例如：当子类和父类都存在相同方法时，子类的方法会覆盖了父类的同名方法。 12345678910111213141516171819class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): def run(self): print('Dog is running...')class Cat(Animal): def run(self): print('Cat is running...')dog = Dog()dog.run()cat = Cat()cat.run()# Dog is running...# Cat is running... 对象的类型判断判断对象的类型，同判断变量类型类似，两种方法： type(x) isinstance(x,type) type() 基本的type()方法可以判断一些基本的数据类型,也可以判断对象的类型： 123456class Animal(object): passdog = Animal()# 注意这种方式无法用于判断继承类型print(type(dog) == Animal) 判断一个对象是否是函数,可以使用types模块: 12345678910111213import typesdef fn(): pass# 函数类型print(type(fn) == types.FunctionType)# 内建函数类型print(type(abs) == types.BuiltinFunctionType)# lambda表达式类型print((type(lambda x: x) == types.LambdaType))# 生成器类型print(type((x for x in range(10))) == types.GeneratorType) isinstance() 建议一直使用来判断对象或者变量的数据类型； 对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数； 能用type()判断的基本类型也可以用isinstance()判断； 123456789class Animal(object): passclass Dog(Animal): passdog = Dog()print(isinstance(dog, Dog))print(isinstance(dog, Animal)) 获取对象的信息获取所有属性和方法Python提供内置函数dir()来获取对象的所有属性和方法,dir()返回一个包含字符串的list； 12345678910111213141516class Animal(object): __name = '二哈' _age = 10 def __init__(self, name, age): self.__name = name self._age = ageclass Dog(Animal): def get_name(self): return self.__namedog = Dog("三哈", 15)print(dir(dog))# ['_Animal__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_age', 'get_name'] 属性变量的设置和获取 获取对象的属性：getattr 12# 如果不存在，会抛异常，推荐设置默认值getattr(obj,str,default) 设置对象的属性：setattr 1setattr(obj,str,default) 示例： 123456class Animal(object): alias = ''dog = Animal()setattr(dog, 'alias', '小名')print(getattr(dog, 'alias', '默认')) 判断是否包含某属性hasattr()内置函数用来判断某对象是否包含某个属性； 123456class Animal(object): alias = ''dog = Animal()print(hasattr(dog, 'alias')) # Trueprint(hasattr(dog, 'name')) # False 实例绑定属性和类绑定属性 实例属性属于各个实例所有，实例之间互不干扰； 类属性属于类所有，所有实例共享一个属性； 不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。 实例绑定属性 由于Python是动态语言，根据类创建的实例可以任意绑定属性。 绑定方式 给实例绑定属性的方法是通过实例变量，或者通过self变量； 12345678class Student(object): def __init__(self, name): # 绑定name属性 self.name = names = Student('Bob')# 绑定score属性s.score = 90 通过setattr内置函数设置实例的属性； 限制允许绑定的属性1231&gt; Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性；2&gt; __slots__赋值一个元组，元组中是存放的是允许添加的属性名称；3&gt; __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 12345678910# 示例class Student(object): # 限制实例的属性 # 用tuple定义允许绑定的属性名称 __slots__ = ('name', 'age') passstudent = Student()student.age = 18print(student.age) 类绑定属性 直接在class中定义属性变量，这种属性变量是类属性，可以直接通过类名.属性变量名访问; 当我们定义了一个类属性后，这个属性虽然归类所有，类的所有实例都可以访问到。 12345678class Test(object): name = 'ethan'print(Test.name) # ethanTest.age = 11print(Test.age) # 11t = Test()print(t.__class__.age) # 11 实例绑定方法和类绑定方法实例绑定方法 类的实例的操作，不影响类的其它实例; 直接给一个初始化的实例绑定的方法，对另一个实例是不起作用，可以使用types模块的MethodType函数给实例对象绑定方法； 1234567891011121314from types import MethodTypeclass Student(object): name = 'miao'# 给实例绑定一个方法# 定义一个函数作为实例方法def set_age(self, age): self.age = ages = Student()s.set_age = MethodType(set_age, s)s.set_age(25)print(s.age) 类绑定方法可以定义以个函数，然后通过类名.方法名直接给类绑定一个方法; 12345678910class Student(object): name = 'miao'# 以给class绑定方法def set_score(self, score): self.score = scoreStudent.set_score = set_scores.set_score(100)print(s.score) 类方法的装饰器装饰器（decorator）可以给函数动态加上功能，对于类的方法，装饰器一样起作用。 @property属性读写限制和检查 Python内置的@property装饰器就是负责把一个方法变成属性调用的, 并且可以限制属性的读写； 在方法上添加@property，负责把此属性的getter方法变成属性的读取，此时只读。 @属性名.setter，负责把一个setter方法变成属性赋值； 1234567891011121314151617181920212223class Student(object): def __init__(self, birth): self._birth = birth @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth# birth是可读写属性，而age就是一个只读属性s = Student(2008)print(s.age) # 7s.birth = 2014print(s.age) # 1s.age = 12 # error 类可定制 Python为类class内部提供了一些特殊方法用来定制类，允许重写这些特殊方法，为类的实例添加一些特殊的功能。 类的可定制方法官方文档 __str__ 字符串输出实例 121&gt; __str__用来输出类实例字符串信息，通常我们可以重新定义它来返回一个规则的字符串；2&gt; __repr__用来输出类实例变量的字符串表示信息，通常__str__()和__repr__()代码都是一样的； 示例 1234567891011121314class Student(object): def __init__(self, name): self.name = name def __str__(self): return 'Student object (name: %s)' % self.name __repr__ = __str__print(Student('Michael'))s = Student('Lily')print(s)# Student object (name: Michael)# Student object (name: Lily) __iter__ 类添支持迭代 123如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 示例：以斐波那契数列为例，写一个Fib类，可以作用于for循环： 123456789101112131415class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 for n in Fib(): print(n) __getitem__ 类实例支持索引访问 __getitem__()传入的参数可能是一个int，也可能是一个切片对象slice 当接收的是int参数时，仅支持下标访问： 123456789class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return af = Fib()print(f[10]) 支持切片访问：接收的参数也可以是切片对象，需要判断做处理； 12345678910111213141516171819202122class Fib(object): def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 result = [] for x in range(stop): if x &gt;= start: result.append(a) a, b = b, a + b return resultf = Fib()print(f[0:5]) 拓展121&gt; 与__getitem__对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。2&gt; __delitem__()方法，用于删除某个元素。 通过上面的方法,我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。 __getattr__ 类实例调用未定义的属性和方法处理 正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。 要点12341&gt; 重写__getattr__()方法，可以对未知属性和方法进行处理；2&gt; 如果属性未定义，也没有在__getattr__()中处理，也会返回None;3&gt; 如果方法未定义，也没有在__getattr__()中处理，则会抛出错误；4&gt; 注意:只有在没有找到属性的情况下，才调用__getattr__，已有的属性; 示例123456789101112131415class Student(object): def __init__(self): self.name = &apos;Michael&apos; def __getattr__(self, attr): if attr == &apos;score&apos;: return 99 elif attr == &apos;age&apos;: # 返回函数 return lambda: 25s = Student()print(s.money) # Noneprint(s.score) # 99print(s.age()) # 25print(s.agex()) # error __call__ 可调用对象 要点12341&gt; 任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用;2&gt; __call__()还可以定义参数。3&gt; 对实例进行直接调用就好比对一个函数进行调用一样;4&gt; 能被调用的对象就是一个Callable对象; 示例 12345678910class Student(object): def __init__(self, name): self.name = name def __call__(self): print('My name is %s.' % self.name)s = Student('Michael')s()# My name is Michael. 可调用对象通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。 1234&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(None)False 枚举类 Python提供了Enum枚举类来实现每个类中的常量都是class的一个唯一实例; 概念要点概念 枚举类本质还是一个类，需要继承enum模块的Enum类或IntEnum类，枚举成员名称大写； 1from enum import Enum,IntEnum,unique(标识枚举标签的值不能相等) 枚举值类型 Enum类型的枚举成员的值可以是字符串、数字类型; IntEnum类型的枚举成员的值只能是int类型； 使用注意 Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。 枚举成员是不可更改的常量； 既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量； 枚举不能实例化，它通过单例模式设计的； 枚举有两个成员值相等时，第二个重复的是第一个的别名，一般别名枚举标签不会被打印，获取到的都是第一次出现的标签名； 如果需要打印别名可以遍历：枚举类.__members__(只打印枚举标签的名称)，枚举类.__member__.items()(打印的是各个枚举成员的所有内容元组)； 简单的枚举类12345678910from enum import Enum# Enum(cls,value)Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))# 遍历枚举类的所有成员# name: cls类名，member 枚举类中的常量值for name, member in Month.__members__.items(): # value属性则是自动赋给成员的int常量，默认从1开始计数。 print(name, '=&gt;', member, ',', member.value) 自定义枚举类 如果需要更精确地控制枚举类型，可以从Enum派生出自定义类； 自定义枚举类，需要使用@unique装饰器帮助我们检查保证没有重复值。 1234567891011from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类123456789101. 获取枚举的标签名称：枚举类名.标签名.name2. 获取枚举标签对应的值：枚举类名.标签.value3. 获取枚举的标签：枚举类名[&apos;标签名&apos;]、枚举类名(标签值)、枚举类.标签4. 遍历枚举的所有标签：for e in 枚举类；5. 遍历枚举的所有成员包括别名标签名：枚举类.__members__;6. 遍历枚举的所有成员包括别名标签详细信息：枚举类.__members__.items();7. 枚举不支持大小和值的比较，可以做等值比较 ：枚举类.标签==枚举类.标签；8. 枚举可做身份比较：枚举类.标签 is 枚举类.标签；9. 枚举中通过标签值获取枚举标签：枚举类(value);10. 约束枚举标签的值不能重复：使用装饰器 @unique； 12345678910111213141516171819202122232425262728293031323334from enum import Enum, unique# @unique装饰器可以帮助我们检查保证没有重复值。@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6print(Weekday.Mon)print(Weekday(1))print(Weekday['Mon'])# 获取枚举对应int值print(Weekday.Mon.value)# 枚举比较day1 = Weekday.Monprint(day1 == Weekday.Mon)print(Weekday(1) == Weekday.Mon)print(Weekday(1) == day1)'''结果：Weekday.MonWeekday.MonWeekday.Mon1TrueTrueTrue''' 动态创建类使用type函数 通过type()函数创建的类和直接写class是完全一样的； type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义； 语法1type(&apos;类名&apos;,(object,父类元组...),属性字典) 要创建一个class对象，type()函数依次传入以下3个参数： 1231. class的名称；2. 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；3. class的方法名称与函数绑定的dict。 示例123456789101112131415# 先定义函数def fn(self, name='world'): print('Hello, %s.' % name)d = &#123; 'hello': fn, 'name': 'ethan'&#125;# 动态代码创建Hello classHello = type('Hello', (object,), d)h = Hello()h.hello()print(h.name) 使用metaclass 除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass(元类)。 定义和使用元类的步骤： 元类需要继承type类，并重写__new__()方法用于创建类实例； 元类需要重写的__new__()方法实际是增加对attrs逻辑处理，最终回调type.__new__(mcs, name, bases, attrs)，来应用修改后的实例化逻辑； 自定义一个类来使用元类时，只需要给自定类的父类元组中添加metaclass属性来指向已定义的元类，那么自定义类实例化时，就会调用元类定义的__new__()方法来进行实例化； 应用metaclass的类的mataclass特性会继续应用到子类; __new__()__new__(mcs, name, bases, attrs)方法接收到的参数依次是： mcs: 当前准备创建的元类模板自己的实例对象； name: 类的名字； bases: 类继承的父类集合； attrs: 类的属性和方法集合。 示例 metaclass给自定义的MyList增加一个add方法来拓展list： 不要使用元类来添加方法，此处只做演示； 123456789101112131415# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): # 指定在创建MyList时，要通过ListMetaclass.__new__()来创建 def __new__(mcs, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(mcs, name, bases, attrs)# 指示使用ListMetaclass来定制类，传入关键字参数metaclassclass MyList(list, metaclass=ListMetaclass): passL = MyList()L.add('hello')L.add('world')print(L) metaclass可以隐式地继承到子类: 12345678910111213141516171819# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): # 指定在创建MyList时，要通过ListMetaclass.__new__()来创建 def __new__(mcs, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(mcs, name, bases, attrs)# 指示使用ListMetaclass来定制类，传入关键字参数metaclassclass MyList(list, metaclass=ListMetaclass): pass# metaclass可以隐式地继承到子类，但子类自己却感觉不到class XList(MyList): passL = XList()L.add('hello')L.add('world')print(L) 元类实现ORM ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。 要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。 实现ORM简单框架的代码加注释，详细如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Field: 存储数据表的映射字段名和类型class Field(object): # name 字段名 # column_type 对应数据库的数据类型 def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return '&lt;%s:%s&gt;' % (self.__class__.__name__, self.name)# 字符串类型(varchar(100))class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, 'varchar(100)')# 整数类型(bigint)class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, 'bigint')# 元类模板：class ModelMetaclass(type): # 重写使用此元类模板的子类创建实例对象的方法 def __new__(mcs, name, bases, attrs): # 尚未实例化时的处理 if name == 'Model': return type.__new__(mcs, name, bases, attrs) # 实例化后的处理 # 打印实例化的类名 print('Found model: %s' % name) # 将attrs转存到mappings实例属性对的映射字典：存储数据字段和值 mappings = dict() for k, v in attrs.items(): if isinstance(v, Field): print('Found mapping: %s ==&gt; %s' % (k, v)) mappings[k] = v # 清空attrs for k in mappings.keys(): attrs.pop(k) # 给attrs重设属性 attrs['__mappings__'] = mappings # 保存属性和列的映射关系 attrs['__table__'] = name # 假设表名和类名一致 # 重新利用type创建实例 return type.__new__(mcs, name, bases, attrs)# 使用元类作为模板，统一对外暴露对数据处理的方法和属性class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r"'Model' object has no attribute '%s'" % key) def __setattr__(self, key, value): self[key] = value # 插入数据到数据库的sql def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) params.append('?') args.append(getattr(self, k, None)) sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params)) # 打印最终的插入sql print('SQL: %s' % sql) print('ARGS: %s' % str(args))# testing code:class User(Model): id = IntegerField('id') name = StringField('username') email = StringField('email') password = StringField('password')u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')u.save() 抽象类定义抽象类定义一个类，并指定抽象类的metaclass=ABCMeta(Abstract Base Classes)即表示抽象类； 抽象类不能直接被实例化； 抽象类中使用@abstractmethod装饰器标识的方法时抽象方法，方法体使用pass无需实现，但是子类必须实现抽象方法； 可以直接使用继承抽象类的方式来直接使用抽象类； 抽象类中使用@property+@abstractmethod装饰的方法称为抽象属性； 示例12345678910111213141516171819202122232425262728293031from abc import ABCMeta, abstractmethod# 定义一个抽象类(不能直接被实例化)# ABCMeta(Abstract Base Classes)class People(metaclass=ABCMeta): # 抽象属性 @property @abstractmethod def name(self): pass # 定义抽象方法,无需实现功能,但是子类必须实现该方法 @abstractmethod def get_sex(self): pass# 继承的方式让类实现实现抽象基类class Student(People): def __init__(self, name): self._name = name @property def name(self): return self._name def get_sex(self): return '男's = Student('ethan')print(s.name) # ethanprint(s.get_sex()) # 男 错误处理 Python所有的错误都是从BaseException类派生的; 只有在必要的时候再使用错误类型，尽量使用Python内置的错误类型。 捕获和处理错误Python异常处理使用try…except…else…finally,try语句块内是需要被检查的代码， except捕获的异常类型可以有多个，else是没有异常时的处理，finally每次都会执行； 123456789101112131415161718192021222324import loggingclass MyError(BaseException): passtry: # try区域是需要被检查的代码 print('异常检测区...') r = 10 / 0 print('result:', r)except ZeroDivisionError as e: # 具体错误 raise MyError('抛出一个自定义错误') except TypeError as e: logging.exception(e)except Exception as e: # 抛出异常，将终端程序 raise Exception('抛出异常，将终端程序')except BaseException as e: # logging模块打印异常信息 logging.exception(e)else: print('没有错误代码块')finally: print('finally...')print('END') 错误调试断言错误断言使用assert标识的语句，assert后跟表达式和错误信息，如果表达式返回True说明断言成功，否则就是断言失败，断言失败标识后面的语句就会报错； 注意：断言失败后会抛出异常，中断程序，不推荐； 123456def foo(s): n = int(s) assert n != 0, &apos;n is zero!&apos; return 10 / nfoo(2) 关闭断言启动Python解释器时可以用-O参数来关闭assert，关闭后，你可以把所有的assert语句当成pass来看。 1$ python -O err.py 打印错误日志 使用logging模块，来打印错误日志，好处是不会抛出错误中断程序； logging模块有debug，info，warning，error等几个级别的信息； 12345# 导入logging模块import logging# 配置日志显示信息的级别logging.basicConfig(level=logging.INFO)logging.info('输出一段错误信息') pdb命令调试略 IDE调试PyCharm和VScode都支持很智能的调试功能； 参考常见的错误类型和继承关系官方文档 正则表达式概述正则表达式由普通字符和元字符组成，普通字符就是普通的字符，元字符是正则规定的特殊字符，Python提供re模块来操作正则表达式的模块； 正则元字符转义字符正则表达式使用斜杠（\）来表示转义字符； 边界符 元字符 描述 ^ 匹配正则表达式的开始 $ 匹配正则表达式的结束 数量限制符 元字符 描述 * 匹配此元字符前面的子表达式任意次 + 匹配此元字符前面的子表达式一次或多次 ? 匹配此元字符前面的子表达式零次或一次，也可做非贪婪匹配限制符 {n} 匹配n(n&gt;=0)次 {n,} 至少匹配n(n&gt;=0)次 {n,m} 最少匹配n次,最多匹配m次(n&lt;=m,n&gt;=0,m&gt;=0) 匹配表达式12345678910111213. 匹配除“\r\n”之外的任何单个字符,要匹配包括“\r\n”在内的任何字符,请使用像“[\s\S]” [xyz] 匹配[]内包含的任意一个字符 [^xyz] 匹配未包含在[]内的任意字符 [a-z] 匹配指定范围内的任意字符(例如：[a-zA-Z0-9])[^a-z] 匹配任何不在指定范围内的任意字符 \d 匹配一个数字字符,等价于[0-9] \D 匹配一个非数字字符 \w 匹配包括下划线的任何单词字符,类似但不等价于“[A-Za-z0-9_]”，这里的&quot;单词&quot;字符使用Unicode字符集 \W 匹配任何非单词字符,等价于“[^A-Za-z0-9_]” \s 匹配任何不可见字符,包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v] \S 匹配任何可见字符。等价于[^ \f\n\r\t\v] () 将括号中的表达式定义为一个组，一个表达式最多9个组 | 将两个匹配条件进行逻辑“或”运算(例如:(him丨her)匹配him或her) 获取和非获取匹配12345678| 元字符 | 描述 || :--- | :--- ||(pattern) | 匹配pattern并获取这一匹配;&lt;br /&gt;如果要匹配的正则有多个（pattern）则每个pattern单独获得一个结果,&lt;br /&gt;组成元组作为符合条件的一组结果) || (?:pattern) | 非获取匹配，匹配pattern但不获取匹配结果,不进行存储供以后使用；&lt;br /&gt; 例如“industr(?:y\|ies)”就是一个比“industry\|industries”更简略的表达式。 || (?=pattern) | 非获取匹配，正向肯定预查；&lt;br /&gt;在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。&lt;br /&gt;例如：“Windows(?=95\|98\|NT\|2000)”&lt;br /&gt; 能匹配“Windows2000”中的“Windows”,但不能匹配“Windows3.1”中的“Windows”。&lt;br /&gt;预查不消耗 字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次，&lt;br /&gt;匹配的搜索而不 是从包含预查的字符之后开始。 || (?!pattern) | 非获取匹配，正向否定预查;&lt;br /&gt;在任何不匹配pattern的字符串开始处匹配查找字符串，&lt;br /&gt;该匹配不需要获取供以后使用;&lt;br /&gt;例如：“Windows(?!95\|98\|NT\|2000)”能匹配“Windows3.1”中的&lt;br /&gt;“Windows”，但不能匹配“Windows2000”中的“Windows”。 || (?&lt;=pattern) | 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反；&lt;br /&gt;例如：“(?&lt;=95\|98\|NT\|2000)Windows”能匹配“2000Windows”中&lt;br /&gt;的“Windows”，但不能匹配“3.1Windows”中的“Windows”) || (?&lt;!pattern) | 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反；&lt;br /&gt;(例如“(?&lt;!95\|98\|NT\|2000)Windows”能匹配“3.1Windows”中的“Windows”,&lt;br /&gt;但不能匹配“2000Windows”中的“Windows” | 其它匹配字符 元字符 描述 \f 匹配一个换页符。等价于\x0c和\cL \n 匹配一个换行符。等价于\x0a和\cJ \r 匹配一个回车符。等价于\x0d和\cM \t 匹配一个制表符。等价于\x09和\cI \v 匹配一个垂直制表符。等价于\x0b和\cK \xn 匹配十六进制数n的转义值（例如：“\x41”匹配“A”） 转义字符问题由于Python的字符串本身也用\转义，因此强烈建议使用Python的r前缀来写正则，就不用考虑转义的问题了： 12s = 'ABC\\-001' # 'ABC\-001's = r'ABC\-001' # 'ABC\-001' re模块 Python提供re模块，提供所有与正则表达式相关的功能; 正则匹配方法查找和匹配 match、search、findall 1.语法： 123456789re.match(pattern,string,flag)：判断字符串的首个元素是否匹配pattern，不匹配直接返回None，匹配时返回一个结果对象；re.search(pattern,string,flag)：搜索整个字符串查找第一个匹配的字符串并返回它的结果对象，没有匹配的则返回None；re.findall(pattern,string)：找出string中所有匹配的元素，返回结果[]列表；re.findall(pattern,string,flag)：找出string中所有匹配的元素，返回结果[]列表；【参数解析】flag：代表匹配模式，可以用|(或)符号一次使用多个flag. 常见flag匹配模式有： 1&gt; re.I：不区分大小写； 2&gt; re.S：让.(点)可以匹配\n； 2.示例： 1&gt; match 1234567891011121314import reregex = r'^\d&#123;3&#125;\-\d&#123;3,8&#125;$'test = '010-12345'# 打印匹配结果r = re.match(regex, '010-12345')print(r)# 逻辑判断是否匹配if re.match(regex, test): print('ok')else: print('failed') 2&gt; findall 12345import rea = 'hello ethan, hello jason'b = re.findall('hello', a)print(b) 分组匹配除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。正则表达式中用()包裹的部分表示的就是要提取的分组（Group）。 要点 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。 group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。 示例 普通分组和子串的提取： 123456789&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;&gt;&gt;&gt; m.group(0)&apos;010-12345&apos;&gt;&gt;&gt; m.group(1)&apos;010&apos;&gt;&gt;&gt; m.group(2)&apos;12345&apos; 正则来识别合法的时间： 1234&gt;&gt;&gt; t = &apos;19:05:30&apos;&gt;&gt;&gt; m = re.match(r&apos;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&apos;, t)&gt;&gt;&gt; m.groups()(&apos;19&apos;, &apos;05&apos;, &apos;30&apos;) 贪婪匹配贪婪匹配模式：正则表达式默认匹配模式，尽可能多的匹配所搜索的字符串； 123&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()(&apos;102300&apos;, &apos;&apos;)# 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 非贪婪匹配非贪婪匹配模式：尽可能少的匹配所搜索的字符串； 非贪婪模式限制符为问号?,即当?字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。 123例如：对于字符串“oooo”的贪婪和非贪婪匹配处理？1&gt; “o+”将尽可能多的匹配“o”，得到结果[“oooo”]，2&gt; “o+?”将尽可能少的匹配“o”，得到结果 [&apos;o&apos;, &apos;o&apos;, &apos;o&apos;, &apos;o&apos;] 123# 示例&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()(&apos;1023&apos;, &apos;00&apos;) re模块其他操作函数查找替换 语法： 1234567891011re.sub(pattern,replace,string,count)【参数】&gt; replace是字符串时：将string中符合pattern表达式的字符替换成replace；&gt; replace是函数时：接收string中满足替换条件pattern的所有结果所组成的value对象作为参数，通过value.group()方法拿到pattern符合表达式的结果字符； 【value.group解析】 value.group(index)：index不传时默认0，获取匹配的结果字符； 如果pattern使用()分组，则返回结果同分组类似： 1&gt; index=0时，返回的是完整匹配; 2&gt; index&gt;0时，返回对应第index组匹配结果； value.groups()：返回value对应的所有结果组成的元组；&gt; count：表示替换几个(默认0表示替换所有)； 示例： 123456789101112131415import relanguage = &apos;PythonC#12JavaC#3PHPC#21&apos;def convert(value): print(value.groups()) print(value.group()) return &apos;*&apos;# 普通匹配r = re.sub(r&apos;C#&apos;, convert, language)# 分组匹配r = re.sub(r&apos;(C#)(\d)&apos;, convert, language)print(r) 预编译该正则表达式如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配： 编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。 12345678&gt;&gt;&gt; import re# 编译:&gt;&gt;&gt; re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)# 使用：&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()(&apos;010&apos;, &apos;12345&apos;)&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()(&apos;010&apos;, &apos;8086&apos;) 正则切分字符串用正则表达式切分字符串比用固定的字符更灵活； 1234567# 普通分隔符切分，无法识别连续空格&gt;&gt;&gt; &apos;a b c&apos;.split(&apos; &apos;)[&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;]# 使用正则切分字符串，可以识别连续空格&gt;&gt;&gt; re.split(r&apos;\s+&apos;, &apos;a b c&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 正则表达式收集校验数字的表达式123456789101112131415161718191. 数字：^[0-9]*$2. n位的数字：^\d&#123;n&#125;$3. 至少n位的数字：^\d&#123;n,&#125;$4. m-n位的数字：^\d&#123;m,n&#125;$5. 零和非零开头的数字：^(0|[1-9][0-9]*)$6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$9. 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12. 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 校验字符的表达式1234567891011121. 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$3. 长度为3-20的所有字符：^.&#123;3,20&#125;$4. 由26个英文字母组成的字符串：^[A-Za-z]+$5. 由26个大写英文字母组成的字符串：^[A-Z]+$6. 由26个小写英文字母组成的字符串：^[a-z]+$7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11. 可以输入含有^%&amp;&apos;,;=?$\&quot;等字符：[^%&amp;&apos;,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+12. 空白行的正则表达式：\n\s*\r (可以用来删除空白行) Email地址1^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名1[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 手机号码1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$ IP地址1234# 提取IP地址\d+\.\d+\.\d+\.\d+# 匹配IP地址((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) IO编程文件读写Python中文件读写的IO操作主要有以下步骤内容： 通过with open()函数打开文件,with的作用是自动关闭文件(等价于调用close函数关闭文件)； 使用read或write进行读写操作； 读写文件的过程，最好捕获错误； 读文件示例读一个文本文件，输出所有内容： 12345try: with open('./test.txt', 'rt', encoding='utf-8', errors='ignore') as f: print(f.read())except IOError as e: print(e) 等价于： 1234567891011121314f = Nonetry: # 内置函数open()函数用来打开文件对象 # 标示符'r'表示读 f = open('./test.txt', 'rt', encoding='utf-8', errors='ignore') # read()一次读取文件的全部内容 print(f.read()) # close()关闭文件 f.close()except IOError as e: raise IOError('IO异常')finally: if f: f.close() 读写文件的内置函数open()open函数用来打开文件准备进行操作，语法格式如下： 1234567open(file, mode=&apos;r&apos;, buffering=None, encoding=None, errors=None, newline=None, closefd=True)【参数】&gt; file: 将要打开的文件，可以是文件地址；&gt; mode: 操作文件的模式（r(读)、w(覆盖写)、x(创建文件并打开写)、a(追加写)、b(二进制)、t(默认文本)、+(更新模式读写)） 注意：r/w/x可以与b/t拼接使用；&gt; encoding: 编码格式；&gt; error: 错误处理，可以设置为&apos;ignore&apos;，忽略错误； 示例 12# 打开读一个二进制文件f = open('./test.jpg', 'rb') read()读文件，返回字符串，语法解释如下： 1read(size): size不传时默认读取全部，否则按size大小读； readlines()调用readlines()一次读取所有内容并按行返回list。 12for line in f.readlines(): print(line.strip()) # 把末尾的'\n'删掉 类似方法：readline()可以每次读取一行内容， write()写文件 1write(str): str为写入的内容； 内存读写StringIO StringIO作用是在内存中读写str。 内存读写操作 write(str)方法将数据写入内存,调用此方法后读的位置会变成当前字符末尾，如果调用read()读的话，需要先调用seek(0)将读的位置重置才行； getvalue()方法用于获得写入后的str; 12345from io import StringIOf = StringIO()f.write('hello world')print(f.getvalue()) StringIO实例对象可以像读文件一调用read方法读，但是如果实例化后再调用写入方法则需要调用seek(0)重置读的位置； 123456789101112# 实例化后读from io import StringIOf = StringIO("hello\nworld\n")while True: s = f.readline() if s == '': break print(s.strip())print('end') 123456789101112131415# 写入后再读，需要seek(0)from io import StringIOf = StringIO("hello\nworld\n")print(f.read())f.write("welcome read")f.seek(0)while True: s = f.read() if s == '': break print(s.strip())print('end') ByteIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 读写操作12345678910from io import BytesIOf = BytesIO()# 写入二进制f.write('中文'.encode('utf-8'))print(f.getvalue())# 像读文件一样读f_read = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')print(f.read()) 操作系统和文件目录Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中。 获取操作系统信息1234567891011121314import os# os模块的某些函数是跟操作系统相关# 获取操作系统类型(nt:windows,posix:linux/macOs/unix)print(os.name)# linux获取详细的系统信息# print(os.uname())# 获取操作系统中定义的环境变量print(os.environ)# 获取某个环境变量的值print(os.environ.get('PATH'))print(os.environ.get('x', 'default')) 操作文件和目录12345678910111213141516171819202122232425262728293031import os# 当前路径可以用'.'表示# 获取当前模块的文件名print(__file__)# 当前系统的路径分隔符print(os.sep)# 操作文件和目录# 查看当前目录的绝对路径print(os.path.abspath('.'))# 获取当前目录下所有文件和目录print(os.listdir('.'))# 判断是否是目录print(os.path.isdir('./utils'))# 判断是否是文件print(os.path.isfile('./test.md'))# 路径拼接：不要直接拼字符串，而要通过os.path.join()函数进行拼接# 创建一个目录:new_dir = os.path.join(os.path.abspath('.'), 'testdir')os.mkdir(new_dir)# 删掉一个目录:os.rmdir(new_dir)# split将最后面级别的目录或文件与前缀的路径分割print(os.path.split('/Users/michael/testdir/file.txt'))# 将文件路径加文件名作为整体和文件扩展名分割print(os.path.splitext('/path/to/file.txt'))# 文件重命名os.rename('./test.txt', 'test.md')# 删除一个文件os.remove('test.py') 复制文件 os模块中没有复制文件的函数，但是读写文件可以完成文件复制，也可以使用shutil模块提供的copyfile() shutil模块中找到很多实用函数，它们可以看做是os模块的补充。 序列化pickling序列化概念 Python提供了pickle模块来实现序列化。 我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 序列化：序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。 反序列化：反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 序列化操作 pickle.dumps()方法把任意对象序列化成一个bytes； pickle.loads()方法把序列化的bytes反序列化为Python对象； pickle.dump()方法将一个对象序列化，并写入文件; pickle.loads()方法从文件中读取byte并反序列化出对象； 123456789101112131415import pickled = dict(name='Bob', age=20, score=88)# 对象的序列化和反序列化b = pickle.dumps(d)print(b)print(pickle.loads(b))# 序列化到文件，从文件中反序列化with open('dump.txt', 'wb') as fw: pickle.dump(d, fw)with open('dump.txt', 'rb') as fr: print(pickle.load(fr)) JSON序列化json写法 注意：json对象的key和字符串value必须用双引号包裹； 123json对象写法：&#123;“key”:&quot;value&quot;,....&#125; json数组写法：[&#123;“key”:&quot;value&quot;,....&#125; ,&#123;&#125;]json字符串写法：json_str=&apos;&#123;“key”:&quot;value&quot;,....&#125;&apos; json和python的数据类型json和python的数据类型对应关系如下： json python object dict array list string str number int或float true True false False null None 处理jsonjson字符串转python对象json.loads()函数是将json格式数据转换为字典 123456import jsonjson_str = '[&#123;"key": "value"&#125;]'d = json.loads(json_str)print(d)# [&#123;'key': 'value'&#125;] python对象转json字符串json.dumps()函数是将一个Python数据类型列表进行json格式的编码; 12345import jsonobj_py = [&#123;'key': 'value'&#125;]print(json.dumps(obj_py))# [&#123;"key": "value"&#125;] 处理中文json.dumps接收ensure_ascii参数表示是否使用ascii编码，默认为True时不能正确显示中文，如果显示中文请设置为False; 123obj = dict(name='小明', age=20)s = json.dumps(obj, ensure_ascii=False)print(s) 读写json文件 json.dump()函数将json信息写入.json文件； json.load()函数从.json文件中读取json信息； 1234567891011import json# json.dump()函数的使用，将json信息写进文件json_info = "&#123;'age': '12'&#125;"file = open('1.json', 'w', encoding='utf-8')json.dump(json_info, file)# json.load()函数的使用，将读取json信息file = open('1.json', 'r', encoding='utf-8')info = json.load(file)print(info) json序列化类对象123456789101112131415161718192021222324252627282930313233343536373839404142434445import jsonclass Student(object): def __init__(self, name, age, score): self.name = name self.age = age self.score = score######################################## 序列化对象：dumps接收自定义转换函数#######################################s = Student('Bob', 20, 88)# 定义函数将对象转为dictdef student2dict(std): return &#123; 'name': std.name, 'age': std.age, 'score': std.score &#125;# dumps()方法可选参数default用来指定转换方法print(json.dumps(s, default=student2dict))# 把任意class的实例变为dict# class的实例都有一个__dict__属性,但是定义了__slots__的class没有；print(json.dumps(s, default=lambda objx: objx.__dict__))######################################## 对象反序列化：loads接收自定义转换函数######################################## 反序列化对象def dict2student(d): return Student(d['name'], d['age'], d['score'])# 自定义转换函数json_str = '&#123;"age": 20, "score": 88, "name": "Bob"&#125;'print(json.loads(json_str, object_hook=dict2student))obj = dict(name='小明', age=20)# ensure_ascii: 表示是否使用ascii编码，ascii不能正确显示中文s = json.dumps(obj)print(s) 多任务多任务的实现有3种方式： 多进程模式； 多线程模式； 多进程+多线程模式。 多进程os模块进程方法 os.getppid()：获取父进程id； os.getpid()：获取当前进程id； os.fork()：创建子进程(仅支持Unix/Linux/Mac)； fork进程 在Python的os模块的fork函数可以轻松创建子进程，但是fork()仅支持Unix/Linux/Mac; 调用fork函数创建进程，需要注意fork()调用一次，返回两次: for()调用时操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回； 子进程永远返回0； 父进程返回子进程的ID。 1234567891011121314import osprint('Process (%s) start...' % os.getpid())# 创建一个子进程pid = os.fork()if pid == 0: print('子进程 (%s) 的父进程是 %s.' % (os.getpid(), os.getppid()))else: print('父进程 (%s) 创建了一个子进程 (%s).' % (os.getpid(), pid))# Process c start...# 子进程 c 的父进程是 p.# 父进程 p 创建了一个子进程 c. 跨平台进程模块 multiprocessing模块就是跨平台版本的多进程模块. multiprocessing模块提供了一个Process类来表示一个进程对象; Process进程对象构造方法1234567def __init__(self, group=None, target=None, name=None, args=(), kwargs=&#123;&#125;)【参数解析】- group：进程所属组，基本不用 - target：进程调用的处理方法对象（可以是一个函数名，也可以是一个可调用的对象（实现了__call__方法的类）） - args：调用对象的位置参数元组 - name：别名 - kwargs：调用对象的关键字参数字典 实例方法12345is_alive()：返回进程是否在运行 start()：启动进程，等待CPU调度 join([timeout])：阻塞当前上下文环境，直到调用此方法的进程终止或者到达指定timeout terminate()：不管任务是否完成，立即停止该进程 run()：start()调用该方法，当实例进程没有传入target参数，stat()将执行默认的run()方法 实例属性12345- authkey：进程的认证密钥(字节字符串) - daemon：守护进程标识，在start()调用之前可以对其进行修改 - exitcode：进程的退出状态码 - name：进程名 - pid：进程 示例1234567891011121314151617from multiprocessing import Processimport os# 定义函数，作为进程任务def run_proc(name): print('进程(%s)运行中: 接收外部信息参数name = %s' % (os.getpid(),name))if __name__ == '__main__': print('当前进程是 %s.' % os.getpid()) # 1. 创建一个进程 p = Process(target=run_proc, args=('test',)) print('子进程将开始...') # 2. 启动进程 p.start() # 3. join方法阻塞进程，等待进程结束再继续执行 p.join() print('子进程结束') Pool进程池 如果要启动大量的子进程，可以用进程池Pool的方式批量创建子进程; 要点 Pool的默认大小是CPU的核数; Pool实例方法 创建进程池：Pool(count); 创建子进程： 1234567# 创建子进程任务，串行执行（需要等待当前子进程执行完毕后，再执行下一个进程）；def apply(self, func, args=(), kwds=&#123;&#125;): pass# 创建子进程任务，并行执行（不用等待当前进程执行完毕，随时根据系统调度来进行进程切换）；def apply_async(self, func, args=(), kwds=&#123;&#125;, callback=None,error_callback=None): pass close()：关闭pool，使其不在接受新的任务； terminate()：结束工作进程，不在处理未完成的任务。 join()：主进程阻塞，等待子进程的退出，join方法要在close或terminate之后使用。 示例1234567891011121314151617181920212223242526from multiprocessing import Poolimport os, time, random# 用于创建子进程的耗时任务函数def long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__ == '__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): # 异步执行一个进程任务，并行任务 # 异步任务进程 p.apply_async(long_time_task, args=(i,)) # 同步任务进程 # p.apply(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') # 调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了； p.close() # join()方法会等待所有子进程执行完毕； p.join() print('All subprocesses done.') subprocess子进程模块 subprocess模块用来创建子进程； subprocess模块允许创建一个新的进程来执行另外的程序，可以与进程进行通信，获取标准的输入、标准输出、标准错误以及返回码等。 subprocess模块常用函数 常用函数表： 函数 描述 run() Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。 call() 执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。 check_call() Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check=True)。 check_output() Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。 getoutput(cmd) 接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。 getstatusoutput(cmd) 执行cmd命令，返回一个元组(命令执行状态, 命令执行结果输出)，其功能类似于commands.getstatusoutput()。 表中常用函数都是基于subprocess.Popen类实现的。 12345【说明】1. 在Python 3.5之后的版本中，官方文档中提倡通过subprocess.run()函数替代其他函数来使用subproccess模块的功能；2. 在Python 3.5之前的版本中，我们可以通过subprocess.call()，subprocess.getoutput()等上面列出的其他函数来使用subprocess模块的功能；3. subprocess.run()、subprocess.call()、subprocess.check_call()和subprocess.check_output()都是通过对subprocess.Popen的封装来实现的高级函数，因此如果我们需要更复杂功能时，可以通过subprocess.Popen来完成。4. subprocess.getoutput()和subprocess.getstatusoutput()函数是来自Python 2.x的commands模块的两个遗留函数。它们隐式的调用系统shell，并且不保证其他函数所具有的安全性和异常处理的一致性。另外，它们从Python 3.3.4开始才支持Windows平台。 常用函数的定义： 123subprocess.call(*popenargs, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None)subprocess.run(*popenargs,input=None, capture_output=False, timeout=None, check=False, **kwargs)//... 123456789【参数说明】- args：要执行的shell命令，默认应该是一个字符串序列，如[&apos;df&apos;, &apos;-Th&apos;]或(&apos;df&apos;, &apos;-Th&apos;)，也可以是一个字符串，如&apos;df -Th&apos;，但是此时需要把shell参数的值置为True。- shell： 如果shell为True，那么指定的命令将通过shell执行。如果我们需要访问某些shell的特性，如管道、文件名通配符、环境变量扩展功能，这将是非常有用的。当然，python本身也提供了许多类似shell的特性的实现，如glob、fnmatch、os.walk()、os.path.expandvars()、os.expanduser()和shutil等。- check： 如果check参数的值是True，且执行命令的进程以非0状态码退出，则会抛出一个CalledProcessError的异常，且该异常对象会包含 参数、退出状态码、以及stdout和stderr(如果它们有被捕获的话)。- stdout, stderr：run()函数默认不会捕获命令执行结果的正常输出和错误输出，如果我们向获取这些内容需要传递subprocess.PIPE，然后可以通过返回的CompletedProcess类实例的stdout和stderr属性或捕获相应的内容；call()和check_call()函数返回的是命令执行的状态码，而不是CompletedProcess类实例，所以对于它们而言，stdout和stderr不适合赋值为subprocess.PIPE；- check_output()函数默认就会返回命令执行结果，所以不用设置stdout的值，如果我们希望在结果中捕获错误信息，可以执行stderr=subprocess.STDOUT。- input：该参数是传递给Popen.communicate()，通常该参数的值必须是一个字节序列，如果universal_newlines=True，则其值应该是一个字符串。universal_newlines：该参数影响的是输入与输出的数据格式，比如它的值默认为False，此时stdout和stderr的输出是字节序列；当该参数的值设置为True时，stdout和stderr的输出是字符串。 示例： 12345import subprocess# 执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。r = subprocess.call(['nslookup', 'www.python.org'])print('result:', r) subproces.Popen() 如果我们需要更复杂功能时，并且要与进程进行复杂的交互，可以利用Popen类来实现； 1&gt; 构造函数概述： 12345678910111213141516# 构造函数class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startup_info=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=()) # 参数说明&gt; args：要执行的shell命令，可以是字符串，也可以是命令各个参数组成的序列。当该参数的值是一个字符串时，该命令的解释过程是与平台相关的，因此通常建议将args参数作为一个序列传递。&gt; bufsize：指定缓存策略，0表示不缓冲，1表示行缓冲，其他大于1的数字表示缓冲区大小，负数 表示使用系统默认缓冲策略。&gt; stdin, stdout, stderr：分别表示程序标准输入、输出、错误句柄。&gt; preexec_fn：用于指定一个将在子进程运行之前被调用的可执行对象，只在Unix平台下有效。&gt; close_fds：如果该参数的值为True，则除了0,1和2之外的所有文件描述符都将会在子进程执行之前被关闭。&gt; shell：该参数用于标识是否使用shell作为要执行的程序，如果shell值为True，则建议将args参数作为一个字符串传递而不要作为一个序列传递。&gt; cwd：如果该参数值不是None，则该函数将会在执行这个子进程之前改变当前工作目录。&gt; env：用于指定子进程的环境变量，如果env=None，那么子进程的环境变量将从父进程中继承。如果env!=None，它的值必须是一个映射对象。&gt; universal_newlines：如果该参数值为True，则该文件对象的stdin，stdout和stderr将会作为文本流被打开，否则他们将会被作为二进制流被打开。&gt; startupinfo和creationflags： 这两个参数只在Windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如主窗口的外观，进程优先级等。 注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。 2&gt; Popen实例方法： 方法 描述 poll() 用于检查子进程（命令）是否已经执行结束，没结束返回None，结束后返回状态码。 wait(timeout=None) 等待子进程结束，并返回状态码；如果在timeout指定的秒数之后进程还没有结束，将会抛出一个TimeoutExpired异常。 communicate() 和子进程交互(发送数据到stdin，并从stdout和stderr读数据，直到收到EOF,要给子进程的stdin发送数据，则Popen时要设置stdin要为PIPE)。等待子进程结束。 send_signal(signal) 发送指定的信号给这个子进程。 terminate() 停止该子进程。 kill() 杀死该子进程。 3&gt; Popen实例属性： 123456789&gt; p.pid: 子进程的PID。&gt; p.returncode: 该属性表示子进程的返回状态，returncode可能有多重情况( None 子进程尚未结束, ==0 子进程正常退出； &gt; 0 子进程异常退出， returncode对应于出错码； &lt; 0—— 子进程被信号杀掉了。)&gt; p.stdin, p.stdout, p.stderr: 子进程对应的一些初始文件，如果调用Popen()的时候对应的参数是subprocess.PIPE，则这里对应的属性是一个包裹了这个管道的 file 对象; 4&gt; 示例： 12345678import subprocesscmd = 'adb devices' # 获取连接设备p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)print(str(p.stdout.read(), encoding='utf-8')) # 打印结果# 阻塞子进程，直到子进程结束。p.communicate()print("end") 进程间通信 Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。 父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。 Queue 在python中，多个线程之间的数据是共享的，多个线程进行数据交换的时候，不能够保证数据的安全性和一致性，所以当多个线程需要进行数据交换的时候，队列就出现了，队列可以完美解决线程间的数据交换，保证线程间数据的安全性和一致性。 三种队列: Python queue模块的FIFO队列先进先出。 class queue.Queue(maxsize) LIFO类似于堆，即先进后出。 class queue.LifoQueue(maxsize) 还有一种是优先级队列级别越低越先出来。 class queue.PriorityQueue(maxsize) 常用方法: queue.qsize() 返回队列的大小 queue.empty() 如果队列为空，返回True,反之False queue.full() 如果队列满了，返回True,反之False queue.full 与 maxsize 大小对应 queue.get([block[, timeout]])获取队列，timeout等待时间（从队列中移除并返回一个数据，通知q可以继续添加数据） queue.get_nowait() 相当queue.get(False) queue.put(item) 写入队列，timeout等待时间（默认的情况，阻塞调用，等待q.get移除数据后继续执行） queue.put_nowait(item) 相当queue.put(item, False) queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号 queue.join() 实际上意味着等到队列为空，再执行别的操作 示例:在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 123456789101112131415161718192021222324252627282930313233from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) # 默认的情况，阻塞调用，等待q.get移除数据后继续执行； q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print('Process to read: %s' % os.getpid()) while True: # 从队列中移除并返回一个数据，通知q可以继续添加数据 value = q.get(True) print('Get %s from queue.' % value)if __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能在pw结束时强行终止: pr.terminate() 多进程的优缺点优点 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。 缺点 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 多线程threading模块Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 线程概念 由于任何进程默认就会启动一个线程，我们把该线程称为主线程,主线程又可以启动新的线程; Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。 主线程实例的名字叫MainThread，子线程的名字在创建时指定，如果不起名字Python就自动给线程命名为Thread-1，Thread-2等。 缺点 多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。 创建线程实例启动一个线程：创建Thread实例，需要传入一个处理函数传入，然后调用start()开始执行； 12345678910111213141516171819import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name) Lock(锁)锁用来解决多个线程间数据共享导致的数据修改错误； 数据共享问题 多进程中，同一个变量，互不影响； 多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 使用锁 多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。 多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。 获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。 锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。 示例123456789101112131415161718192021222324252627282930import time, threading# 假定这是你的银行存款:balance = 0# 创建一个锁lock = threading.Lock()def change_it(n): # 先存后取，结果应该为0: global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(100000): # 先要获取锁,给change_it()上一把锁,其它线程不能访问该方法 lock.acquire() try: change_it(n) finally: lock.release()t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance)# result: 0 GIL全局锁1.现象描述？ 理论上来看一个死循环线程会100%占用一个CPU，用C、C++或Java在n个线程中写相同的死循环，直接可以把n核心跑满，4核就跑到400%，8核就跑到800%，但是Python不会占满n核CPU； 2.python的GIL锁； Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 3.利用多核CPU: 通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。 在Python中，可以使用多线程，但不要指望能有效利用多核。 如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。 Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。 ThreadLocal ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。 在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁,但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦，ThreadLocal类型的全局变量，可以绑定其他变量，并且可以在多个线程中使用它，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。 ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。 示例 创建ThreadLocal全局变量，通过绑定其它变量可以在多个线程中互不影响的特性，解决参数在一个线程中各个函数之间互相传递的问题； 123456789101112131415161718192021import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print('Hello, %s (in %s)' % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')t1.start()t2.start()t1.join()t2.join() 分布式进程 在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。 Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。 例子 需要在linux/mac系统下，windows无法正常运行； 如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？ 原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。 我们先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务： 12345678910111213141516171819202122232425262728293031323334353637# task_master.pyimport random, time, queuefrom multiprocessing.managers import BaseManager# 发送任务的队列:task_queue = queue.Queue()# 接收结果的队列:result_queue = queue.Queue()# 从BaseManager继承的QueueManager:class QueueManager(BaseManager): pass# 把两个Queue都注册到网络上, callable参数关联了Queue对象:QueueManager.register('get_task_queue', callable=lambda: task_queue)QueueManager.register('get_result_queue', callable=lambda: result_queue)# 绑定端口5000, 设置验证码'abc':manager = QueueManager(address=('', 5000), authkey=b'abc')# 启动Queue:manager.start()# 获得通过网络访问的Queue对象:task = manager.get_task_queue()result = manager.get_result_queue()# 放几个任务进去:for i in range(10): n = random.randint(0, 10000) print('Put task %d...' % n) task.put(n)# 从result队列读取结果:print('Try get results...')for i in range(10): r = result.get(timeout=10) print('Result: %s' % r)# 关闭:manager.shutdown()print('master exit.') 1请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。 然后，在另一台机器上启动任务进程（本机上启动也可以）： 123456789101112131415161718192021222324252627282930313233343536# task_worker.pyimport time, sys, queuefrom multiprocessing.managers import BaseManagerfrom multiprocessing import Queue# 创建类似的QueueManager:class QueueManager(BaseManager): pass# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:QueueManager.register('get_task_queue')QueueManager.register('get_result_queue')# 连接到服务器，也就是运行task_master.py的机器:server_addr = '127.0.0.1'print('Connect to server %s...' % server_addr)# 端口和验证码注意保持与task_master.py设置的完全一致:m = QueueManager(address=(server_addr, 5000), authkey=b'abc')# 从网络连接:m.connect()# 获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue()# 从task队列取任务,并把结果写入result队列:for i in range(10): try: n = task.get(timeout=1) print('run task %d * %d...' % (n, n)) r = '%d * %d = %d' % (n, n, n*n) time.sleep(1) result.put(r) except Queue.Empty: print('task queue is empty.')# 处理结束:print('worker exit.') 运行 12345678910111213141516171819202122232425262728293031323334353637383940先启动task_master.py服务进程：$ python3 task_master.py Put task 3411...Put task 1605...Put task 1398...Put task 4729...Put task 5300...Put task 7471...Put task 68...Put task 4219...Put task 339...Put task 7866...Try get results...task_master.py进程发送完任务后，开始等待result队列的结果。现在启动task_worker.py进程：$ python3 task_worker.pyConnect to server 127.0.0.1...run task 3411 * 3411...run task 1605 * 1605...run task 1398 * 1398...run task 4729 * 4729...run task 5300 * 5300...run task 7471 * 7471...run task 68 * 68...run task 4219 * 4219...run task 339 * 339...run task 7866 * 7866...worker exit.task_worker.py进程结束，在task_master.py进程中会继续打印出结果：Result: 3411 * 3411 = 11634921Result: 1605 * 1605 = 2576025Result: 1398 * 1398 = 1954404Result: 4729 * 4729 = 22363441Result: 5300 * 5300 = 28090000Result: 7471 * 7471 = 55815841Result: 68 * 68 = 4624Result: 4219 * 4219 = 17799961Result: 339 * 339 = 114921Result: 7866 * 7866 = 61873956 常用内建模块datetimedatetime是Python处理日期和时间的标准库，主要使用datetime模块中的datatime类来获取时间。 12# 导入datetime类from datetime import datetime 本地时间1234567891011121314151617181920212223from datetime import datetime# 获取当前datetimenow = datetime.now()print(type(now)) # 2018-11-07 16:12:09.036856# 用指定日期时间创建datetimedt = datetime(2015, 4, 19, 12, 20) print(dt) # 2015-04-19 12:20:00# 获取单位时间# 年print(datetime.now().year)# 月print(datetime.now().month)# 日print(datetime.now().day)# 时print(datetime.now().hour)# 分print(datetime.now().minute)# 秒print(datetime.now().second) 时间加减法timedelta对象表示一个时间长度，用来计算两个日期或者时间的差值； 1234567from datetime import datetime, timedeltanow = datetime.now()# 当前时间减2小时print(now + timedelta(hours=2))# 当前时间加2天2小时print(now - timedelta(days=2, hours=2)) 时区时间 UTC时间是格林威治标准时间，比北京时间早了8小时。 创建时区时间 本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。 datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区; 123456789101112131415from datetime import datetime, timedelta, timezone# 获取一个标准UTC时间print(datetime.utcnow())# 获取UTC时间，并强制设置时区为UTC+0:00:utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)print(utc_dt)# 直接获取一个标准UTC+0:00时间print(datetime.now(tz=timezone.utc))# 创建时区UTC+8:00 北京时间tz_utc_8 = timezone(timedelta(hours=8))# 强制设置为UTC+8:00print(datetime.now().replace(tzinfo=tz_utc_8)) 时区转换可以先通过utcnow()拿到当前的UTC时间，再通过astimezone根据时间差转换为任意时区的时间； 12345678910111213from datetime import datetime, timedelta, timezone# 拿到UTC时间，并强制设置时区为UTC+0:00:utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)print(utc_dt)# astimezone()将转换时区为北京时间:bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))print(bj_dt)# astimezone()将转换时区为东京时间:tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))print(tokyo_dt) 时间戳 Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。 1234567891011from datetime import datetime# datetime转timestampprint(datetime.now().timestamp())# timestamp转datetimet = datetime.now().timestamp()print(datetime.fromtimestamp(t))# timestamp转UTC时间print(datetime.utcfromtimestamp(t)) 时间格式化Python time strftime() 函数接收以时间元组，并返回以可读字符串表示的当地时间，格式由参数format决定。 语法1234time.strftime(format[, t])【参数】format -- 格式字符串。t -- 可选的参数t是一个struct_time对象。 时间日期格式化符号python中时间日期格式化符号： 12345678910111213141516171819202122%y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身 示例1234from datetime import datetime# datetime转换为str(格式化时间)print(datetime.now().strftime('%Y-%m-%d %H:%M:%S')) collectionscollections是Python内建的一个集合模块，提供了许多有用的集合类。 namedtuple 利用元组创建对象； namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。 语法1namedtuple(&apos;名称&apos;, [属性list]): 示例123456789101112from collections import namedtuple# 例1：定义一个点对象，拥有两个坐标点Point = namedtuple('Point', ['x', 'y'])p = Point(1, 2)print(p.x, p.y)print(isinstance(p, Point))print(isinstance(p, tuple))# 例2：用坐标和半径表示一个圆Circle = namedtuple('Circle', ['x', 'y', 'r']) deque 加强版list； 使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。 deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈： deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。 1234567from collections import dequeq = deque(['a', 'b', 'c'])q.remove('a')q.append('x')q.appendleft('y')print(q) # deque(['y', 'b', 'c', 'x']) defaultdict dict设置默认值； 使用dict时，当通过dict.[key]访问value时，如果引用的Key不存在，就会报错KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict; 注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。 除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。 1234from collections import defaultdictdd = defaultdict(lambda: 'N/A')print(dd['key']) OrderedDict dict的key支持按顺序迭代； 使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用OrderedDict； OrderedDict的Key会按照插入的顺序排列，不是Key本身排序; 12345678910111213141516171819from collections import OrderedDictd_t = dict()print(d_t)# 创建字典：无序的d = dict([('a', 1), ('b', 2), ('c', 3)])print(d)# 有序字典od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])print(od)# 按照插入的Key的顺序返回od = OrderedDict()od['z'] = 1od['y'] = 2od['x'] = 3print(list(od.keys())) 实现FIFO的dictOrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key; 1234567891011121314151617181920212223242526from collections import OrderedDictclass LastUpdatedOrderedDict(OrderedDict): def __init__(self, capacity): super(LastUpdatedOrderedDict, self).__init__() self._capacity = capacity def __setitem__(self, key, value): containsKey = 1 if key in self else 0 if len(self) - containsKey &gt;= self._capacity: last = self.popitem(last=False) print('remove:', last) if containsKey: del self[key] print('set:', (key, value)) else: print('add:', (key, value)) OrderedDict.__setitem__(self, key, value)d = LastUpdatedOrderedDict(2)d['key1'] = 1d['key2'] = 2d['key3'] = 3d['key4'] = 4print(d) ChainMap 让参数按定义的顺序查找； ChainMap可以把一组dict串起来组成一个逻辑上的dict。ChainMap本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。 使用场景示例什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。 12345678910111213141516171819202122232425from collections import ChainMap# python中的命令行解析最简单最原始的方法是使用sys.argv来实现，更高级的可以使用argparse这个模块。import os, argparse# 构造缺省参数:defaults = &#123; 'color': 'red', 'user': 'guest'&#125;# 构造命令行参数:parser = argparse.ArgumentParser()# 指定程序需要接受的命令参数parser.add_argument('-u', '--user')parser.add_argument('-c', '--color')# 将之前add_argument()定义的参数进行赋值，并返回相关的namespacenamespace = parser.parse_args()command_line_args = &#123;k: v for k, v in vars(namespace).items() if v&#125;# 组合成ChainMap:combined = ChainMap(command_line_args, os.environ, defaults)# 没有任何参数时，打印出默认参数:print('color=%s' % combined['color'])print('user=%s' % combined['user']) Counter Counter是一个简单的计数器，Counter实际上也是dict的一个子类； 示例：统计字符出现的个数？ 12345678from collections import Counterc = Counter()for ch in 'programming': c[ch] = c[ch] + 1print(c) base64 Base64是一种用64个字符来表示任意二进制数据的方法,Base64是一种最常见的二进制编码方法。 base64编解码1234567import base64# base64编码encodeResult = base64.b64encode(b'10000011')print(encodeResult)# base64解码print(base64.b64decode(encodeResult)) urlsafe_b64编解码 urlsafe_b64编码后把字符+和/分别变成-和_； 1234567891011import base64test_str = b'i\xb7\x1d\xfb\xef\xff'# base64编码print(base64.b64encode(test_str))# urlsafe_b64编码(标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种"url safe"的base64编码，其实就是把字符+和/分别变成-和_)safe_encode = base64.urlsafe_b64encode(test_str)print(safe_encode)# urlsafe_b64解码print(base64.urlsafe_b64decode(safe_encode)) 要点 Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。 Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。 由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉; Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了； 例子1234567891011121314151617181920212223242526272829303132#【解码byte非4的倍数用等号补位】import base64# 能处理掉“=”的base64解码函数def safe_base64_decode(s): # 添加等于号 if len(s) % 4 != 0: s = s + bytes('=', encoding='utf-8') * (4 - len(s) % 4) print("1:%s" % s) # 解决字符串和bytes类型 if not isinstance(s, bytes): s = bytes(s, encoding='utf-8') print('s:%s' % s) # 解码 base64_string = base64.b64decode(s) print("base64:%s" % base64_string) return base64_string# 测试:# assert b'abcd' == safe_base64_decode(b'YWJjZA=='), safe_base64_decode('YWJjZA==')# assert b'abcd' == safe_base64_decode(b'YWJjZA'), safe_base64_decode('YWJjZA')# print('ok')# 解码带等号=的bytessafe_base64_decode(b'YWJjZA==')# 字符串转byte再解码safe_base64_decode('YWJjZA==')# 编码长度不是4的倍数时，用等号补位；safe_base64_decode(b'YWJjZA') struct Python提供了一个struct模块来解决bytes和其它数据类型的转换; 根据格式化字符串（参考struct官方文档）的格式来进行bytes和其它数据类型的转换； 主要函数struct模块中最主要的三个函数式pack()、unpack()、calcsize()，语法如下： 123pack(fmt, v1, v2, ...) ------ 根据所给的fmt指令描述的格式将值v1，v2，...转换为一个字符串，后面参数个数要和处理指令一致。unpack(fmt, bytes) ------ 根据所给的fmt指令描述的格式将bytes反向解析出来，返回一个元组。calcsize(fmt) ------ 根据所给的fmt描述的格式返回该结构的大小。 fmt由字节顺序符和格式字符组成（参考struct官方文档）； 示例12345678import struct# pack把任意数据类型变成bytes(&gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。)print(struct.pack('&gt;I', 10240099)) # b'\x00\x9c@c'# unpack把bytes变成相应的数据类型(&gt;表示字节顺序是big-endian,为I：4字节无符号整数和H：2字节无符号整数。)# 此处解释为：字节依次将前四个字节、后两个字节转换成无符号整数；print(struct.unpack('&gt;IH', b'\xf0\xf0\xf0\xf0\x80\x80')) # (4042322160, 32896) hashlibPython的hashlib提供了常见的摘要算法，如MD5，SHA1等等。 摘要算法 任何摘要算法都是把无限多的数据集合映射到一个有限的集合中, 这种碰撞有可能逆推出原文; 摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。 摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。 摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。 摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。 MD5MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。 123456789101112import hashlib# 简单用法md5 = hashlib.md5()md5.update('how to use md5 in python hashlib?'.encode('utf-8'))print(md5.hexdigest())# 数据量很大,分块多次调用md5 = hashlib.md5()md5.update('how to use md5 in '.encode('utf-8'))md5.update('python hashlib?'.encode('utf-8'))print(md5.hexdigest()) SHA1 SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。 比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。 123456import hashlibsha1 = hashlib.sha1()sha1.update('how to use sha1 in '.encode('utf-8'))sha1.update('python hashlib?'.encode('utf-8'))print(sha1.hexdigest()) hmacPython内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。 解决问题场景问题 通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的password_md5对比计算md5(password)的结果，如果一致，用户输入的口令就是正确的。 解决思路 为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。 hmac算法和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。 1234567import hmacmessage = b'Hello, world!'key = b'secret'h = hmac.new(key, message, digestmod='MD5')# 如果消息很长，可以多次调用h.update(msg)print(h.hexdigest()) 可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。 itertools Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。 itertools模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有用for循环迭代的时候才真正计算。 无限迭代函数12345678910111213141516171819202122import itertools,time# count(n)会创建一个自然数从n开始的无限迭代器,n如果不传，默认为0,n可以为负数；natuals = itertools.count(1)print(type(natuals))for n in natuals: print(n) time.sleep(1) # cycle(iterable)会将将传入的iterable按顺序无限迭代cs = itertools.cycle('ABC')for c in cs: print(c) time.sleep(1) # repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：ns = itertools.repeat('A', 3)for n in ns: print(n) time.sleep(1) 多个迭代串联chain()可以把一组迭代对象串联起来，形成一个更大的迭代器： 1234import itertools,timefor c in itertools.chain('ABC', 'XYZ'): print(c) 重复元素分组迭代groupby()把迭代器中相邻的重复元素挑出来放在一起： 123456789import itertools,timefor key, group in itertools.groupby('AAABBBCCAAA'): print(key, list(group))print('------------------------------')# 添加值处理函数，按照不区分大小写来挑选for key, group in itertools.groupby('AaaBBbcCAAa', lambda c: c.upper()): print(key, list(group)) contextlib在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。可以使用try…finally,或者with; with自动关闭资源并不是只有open()函数返回的fp对象才能使用with语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。 1实现上下文管理是通过__enter__和__exit__这两个方法实现的。 1234567891011121314151617181920class Query(object): def __init__(self, name): self.name = name def __enter__(self): print('Begin') return self def __exit__(self, exc_type, exc_value, traceback): if exc_type: print('Error') else: print('End') def query(self): print('Query info about %s...' % self.name)with Query('Bob') as q: q.query() @contextmanager 上下文管理装饰器 @contextmanager让我们通过编写generator来简化上下文管理。 实现with @contextmanager这个decorator接受一个generator，用yield语句把with … as var把变量输出出去，然后，with语句就可以正常地工作了： 12345678910111213141516171819from contextlib import contextmanagerclass Query(object): def __init__(self, name): self.name = name def query(self): print('Query info about %s...' % self.name)@contextmanagerdef create_query(name): print('Begin') q = Query(name) yield q print('End')with create_query('Bob') as q: q.query() 希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现: 1234567891011from contextlib import contextmanager@contextmanagerdef tag(name): print("&lt;%s&gt;" % name) yield print("&lt;/%s&gt;" % name)with tag("h1"): print("hello") print("world") @closing如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。 @closing的实现closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单： 123456@contextmanagerdef closing(thing): try: yield thing finally: thing.close() 使用案例closing的作用就是把任意对象变为上下文对象，并支持with语句。 123456from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen('https://www.python.org')) as page: for line in page: print(line) urllib urllib提供了一系列用于操作URL的功能。 urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。 Get抓取Get请求的信息urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应; 例如，对豆瓣的一个URLhttps://api.douban.com/v2/book/2129650进行抓取，可以看到HTTP响应的头和JSON数据: 12345678from urllib import requestwith request.urlopen('https://api.douban.com/v2/book/2129650') as f: data = f.read() print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', data.decode('utf-8')) 模拟浏览器发送GET请求如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。 例如，模拟iPhone 6去请求豆瓣首页，这样豆瓣会返回适合iPhone的移动版网页： 123456789from urllib import requestreq = request.Request('http://www.douban.com/')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')with request.urlopen(req) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) Post如果要以POST发送一个请求，只需要把参数data以bytes形式传入。 案例：模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入； 1234567891011121314151617181920212223print('Login to weibo.cn...')email = input('Email: ')passwd = input('Password: ')login_data = parse.urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')])req = request.Request('https://passport.weibo.cn/sso/login')req.add_header('Origin', 'https://passport.weibo.cn')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')with request.urlopen(req, data=login_data.encode('utf-8')) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8')) Handler如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理，示例代码如下： 12345678from urllib import requestproxy_handler = request.ProxyHandler(&#123;'http': 'http://www.example.com:3128/'&#125;)proxy_auth_handler = request.ProxyBasicAuthHandler()proxy_auth_handler.add_password('realm', 'host', 'username', 'password')opener = request.build_opener(proxy_handler, proxy_auth_handler)with opener.open('http://www.example.com/login.html') as f: pass XML操作XML有两种方法：DOM和SAX。 DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。 SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。 正常情况下，优先考虑SAX，因为DOM实在太占内存。 SAX解析XML SAX解析的关键函数：from xml.parsers.expat import ParserCreate; 在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。 解析步骤例如：解析一个html节点 1&lt;a href=&quot;/&quot;&gt;python&lt;/a&gt; 会产生3个事件： 123start_element事件，在读取&lt;a href=&quot;/&quot;&gt;时；char_data事件，在读取python时；end_element事件，在读取&lt;/a&gt;时。 定义实现了1中三个事件方法的类； 通过指定ParserCreate实例的三个属性与1中三个方法； 最后调用ParserCreate实例对象的Parse(xml)函数来解析； 案例1234567891011121314151617181920212223242526from xml.parsers.expat import ParserCreateclass DefaultSaxHandler(object): def start_element(self, name, attrs): print('sax:start_element: %s, attrs: %s' % (name, str(attrs))) def end_element(self, name): print('sax:end_element: %s' % name) def char_data(self, text): print('sax:char_data: %s' % text)xml = r'''&lt;?xml version="1.0"?&gt;&lt;ol&gt; &lt;li&gt;&lt;a href="/python"&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/ruby"&gt;Ruby&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;'''handler = DefaultSaxHandler()parser = ParserCreate()parser.StartElementHandler = handler.start_elementparser.EndElementHandler = handler.end_elementparser.CharacterDataHandler = handler.char_dataparser.Parse(xml) 生成XML除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串； 123456L = []L.append(r'&lt;?xml version="1.0"?&gt;')L.append(r'&lt;root&gt;')L.append(encode('some &amp; data'))L.append(r'&lt;/root&gt;')return ''.join(L) HTMLParserHTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML,Python提供了HTMLParser来非常方便地解析HTML。 feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。 特殊字符有两种，一种是英文表示的&nbsp;，一种是数字表示的&#1234;，这两种字符都可以通过Parser解析出来。 12345678910111213141516171819202122232425262728293031323334353637from html.parser import HTMLParserfrom html.entities import name2codepointclass MyHTMLParser(HTMLParser): def error(self, message): pass def handle_starttag(self, tag, attrs): print('&lt;%s&gt;' % tag) def handle_endtag(self, tag): print('&lt;/%s&gt;' % tag) def handle_startendtag(self, tag, attrs): print('&lt;%s/&gt;' % tag) def handle_data(self, data): print(data) def handle_comment(self, data): print('&lt;!--', data, '--&gt;') def handle_entityref(self, name): print('&amp;%s;' % name) def handle_charref(self, name): print('&amp;#%s;' % name)parser = MyHTMLParser()parser.feed('''&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- test html parser --&gt; &lt;p&gt;Some &lt;a href=\"#\"&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;''') 常用第三方模块除了内建的模块外，Python还有大量的第三方模块，所有的第三方模块都会在pypi上注册，只要找到对应的模块名字，即可用pip安装。 Pillow(图像处理)Pillow是图像处理标准库,支持最新Python 3.x,详情见API文档; 安装1$ pip install pillow 操作图像操作图像的缩放、切片、旋转、滤镜、输出文字、调色板等功能。 缩放 打开一张图片并进行缩放： 12345678910111213from PIL import Image# 打开一个jpg图像文件，注意是当前路径:im = Image.open('talor_swift.jpg')# 获得图像尺寸:w, h = im.sizeprint('Original image size: %sx%s' % (w, h))# 缩放到50%:im.thumbnail((w//2, h//2))print('Resize image to: %sx%s' % (w//2, h//2))# 保存图片到本地save(self,filepath,format)# 把缩放后的图像用jpeg格式保存:im.save('thumbnail.jpg', 'jpeg') 模糊 ImageFilter类中预定义了如下滤波方法： 12345678910111213141516171819202122232425262728293031323334• BLUR：模糊滤波• CONTOUR：轮廓滤波• DETAIL：细节滤波• EDGE_ENHANCE：边界增强滤波• EDGE_ENHANCE_MORE：边界增强滤波（程度更深）• EMBOSS：浮雕滤波• FIND_EDGES：寻找边界滤波• SMOOTH：平滑滤波• SMOOTH_MORE：平滑滤波（程度更深）• SHARPEN：锐化滤波• GaussianBlur(radius=2)：高斯模糊&gt;radius指定平滑半径。• UnsharpMask(radius=2, percent=150, threshold=3)：反锐化掩码滤波&gt;radius指定模糊半径；&gt;percent指定反锐化强度（百分比）;&gt;threshold控制被锐化的最小亮度变化。• Kernel(size, kernel, scale=None, offset=0)：核滤波当前版本只支持核大小为3x3和5x5的核大小，且图像格式为“L”和“RGB”的图像。&gt;size指定核大小（width, height）；&gt;kernel指定核权值的序列；&gt;scale指定缩放因子；&gt;offset指定偏移量，如果使用，则将该值加到缩放后的结果上。• RankFilter(size, rank)：排序滤波&gt;size指定滤波核的大小；&gt;rank指定选取排在第rank位的像素，若大小为0，则为最小值滤波；若大小为size * size / 2则为中值滤波；若大小为size * size - 1则为最大值滤波。• MedianFilter(size=3)：中值滤波&gt;size指定核的大小• MinFilter(size=3)：最小值滤波器&gt;size指定核的大小• MaxFilter(size=3)：最大值滤波器&gt;size指定核的大小• ModeFilter(size=3)：波形滤波器选取核内出现频次最高的像素值作为该点像素值，仅出现一次或两次的像素将被忽略，若没有像素出现两次以上，则保留原像素值。&gt;size指定核的大小； 示例： 12345678from PIL import Image, ImageFilter# 打开一个jpg图像文件，注意是当前路径:im = Image.open('taylor_swift.jpg')# 应用高斯模糊滤镜im2 = im.filter(ImageFilter.GaussianBlur(radius=10))# 保存图片到本地save(self,filepath,format)im2.save('blur.jpg', 'jpeg') 绘图PIL的ImageDraw提供了一系列绘图方法，让我们可以直接绘图。 生成字母验证码图片用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片: 12345678910111213141516171819202122232425262728293031323334from PIL import Image, ImageDraw, ImageFont, ImageFilterimport random# 随机字母:def rnd_char(): return chr(random.randint(65, 90))# 随机颜色1:def rnd_color(): return random.randint(64, 255), random.randint(64, 255), random.randint(64, 255)# 随机颜色2:def rnd_color2(): return random.randint(32, 127), random.randint(32, 127), random.randint(32, 127)# 设定验证码图片的宽高240x60:width = 240height = 60# 创建图片image = Image.new('RGB', (width, height), (122, 235, 66))# 创建Font对象:font = ImageFont.truetype('SF_Arch_Rival.ttf', 36)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素的颜色:for x in range(width): for y in range(height): draw.point((x, y), fill=rnd_color())# 输出文字:for t in range(4): draw.text((60 * t + 10, 10), rnd_char(), font=font, fill=rnd_color2())# 模糊:image = image.filter(ImageFilter.BLUR)image.save('code.jpg', 'jpeg') requests(处理url)处理URL资源比urllib更方便； 安装1$ pip install requests GET请求使用GET请求1234567891011121314151617181920212223242526import requests# GET请求访问豆瓣首页内容r = requests.get('https://www.douban.com/')# 获取请求的http状态码print(r.status_code)# 获取请求的url内容print(r.text)# 获取实际请求的URLprint(r.url)# requests自动检测编码，可以使用encoding属性查看print(r.encoding)# 无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象print(type(r.content))# 获取响应头print(r.headers)print(r.headers['Content-Type'])# requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：print(r.cookies['ts'])# 要在请求中传入Cookie，只需准备一个dict传入cookies参数：cs = &#123;'token': '12345', 'status': 'working'&#125;r = requests.get(url, cookies=cs)# 控制请求的超时时间# 2.5秒后超时r = requests.get(url, timeout=2.5) GET请求带参数123import requestsr = requests.get('https://www.douban.com/search', params=&#123;'q': 'python', 'cat': '1001'&#125;) 响应数据格式Json12345import requests# 指定请求响应数据的格式为jsonr = requests.get('https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json')print(r.json()) 请求头添加header1234import requests# 请求添加headerr = requests.get('https://www.douban.com/', headers=&#123;'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit'&#125;) POST请求POST请求和GET请求用法类似，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据; 请求参数 requests默认使用application/x-www-form-urlencoded对POST数据编码。 12345678import requestsr = requests.post( 'https://accounts.douban.com/login', data=&#123; 'form_email': 'abc@example.com', 'form_password': '123456' &#125;) 如果要传递JSON数据，可以直接传入json关键字参数,内部自动序列化为JSON; 123456import requestsurl = 'https://accounts.douban.com/login'params = &#123;'key': 'value'&#125;# json格式的参数（内部自动序列化为JSON）r = requests.post(url, json=params) 上传文件：上传文件需要更复杂的编码格式，但是requests把它简化成files参数； 123456import requestsurl = 'xxx'# 在读取文件时，注意务必使用'rb'即二进制模式读取，这样获取的bytes长度才是文件的长度upload_files = &#123;'file': open('report.xls', 'rb')&#125;r = requests.post(url, files=upload_files) chardet(编码检测) 用它来检测编码类型； 使用chardet检测编码非常容易，chardet支持检测中文、日文、韩文等多种语言。详情参考官方API文档 安装1$ pip install chardet 常用编码检查123456789101112131415161718192021import chardet# 检测ascii字节编码r = chardet.detect(b'Hello, world!')print(r)# &#123;'encoding(编码)': 'ascii', 'confidence': 1.0(正确的概率是1.0（即100%）), 'language': ''&#125;# 检测GBK编码的中文data = '离离原上草，一岁一枯荣'.encode('gbk')r = chardet.detect(data)print(r)# 检测UTF-8编码data = '离离原上草，一岁一枯荣'.encode('utf-8')r = chardet.detect(data)print(r)# 检测日文编码data = '最新の主要ニュース'.encode('euc-jp')r = chardet.detect(data)print(r) psutil(系统信息) 在Python中获取系统信息可以使用subprocess模块，另一个更简单的方法是使用psutil这个第三方模块。 psutil还可以获取用户信息、Windows服务等很多有用的系统信息，具体请参考psutil的官网：https://github.com/giampaolo/psutil; 安装1$ pip install psutil 获取CPU信息123456789import psutilprint('CPU逻辑数量：', psutil.cpu_count())print('CPU物理核心：', psutil.cpu_count(logical=False))print('统计CPU的用户／系统／空闲时间：', psutil.cpu_times())# 类似top命令的CPU使用率，每秒刷新一次，累计10次for x in range(10): print(psutil.cpu_percent(interval=1, percpu=True)) 获取内存信息1234567import psutilprint('物理内存信息：', psutil.virtual_memory())print('交换内存信息：', psutil.swap_memory())# 物理内存信息： svmem(total=8461451264, available=2556604416, percent=69.8, used=5904846848, free=2556604416)# 交换内存信息： sswap(total=13561724928, used=10279280640, free=3282444288, percent=75.8, sin=0, sout=0)# 返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。而交换区大小是1073741824 = 1 GB。 获取磁盘信息可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息： 12345import psutilprint('磁盘分区信息：', psutil.disk_partitions())print('磁盘使用情况：', psutil.disk_usage('/'))print('磁盘IO：', psutil.disk_io_counters()) 获取网络信息psutil可以获取网络接口和网络连接信息; 123456import psutilprint('获取网络读写字节／包的个数：', psutil.net_io_counters())print('获取网络接口信息：', psutil.net_if_addrs())print('获取网络接口状态：', psutil.net_if_stats())print('网络连接信息：', psutil.net_connections()) 获取进程信息 psutil让Python程序获取系统信息； psutil还可以获取用户信息、Windows服务等很多有用的系统信息，具体请参考psutil的官网：https://github.com/giampaolo/psutil； 常用操作方法： 123456789101112131415161718192021222324import psutilprint('所有进程ID：', psutil.pids())# 获取指定进程ID=6856，其实就是当前chrome的进程p = psutil.Process(6856)print('进程名称：', p.name())print('进程工作目录：', p.cwd())print('进程exe路径：', p.exe())print('进程启动的命令行：', p.cmdline())print('父进程ID：', p.ppid())print('父进程：', p.parent())print('子进程列表：', p.children())print('进程状态：', p.status())print('进程用户名：', p.username())print('进程创建时间：', p.create_time())print('进程使用的CPU时间：', p.cpu_times())print('进程使用的内存：', p.memory_info())print('进程打开的文件：', p.open_files())print('进程相关网络连接：', p.connections())print('进程的线程数量：', p.num_threads())print('所有线程信息：', p.threads())print('进程环境变量：', p.environ())print('结束进程：', p.terminate())# print('进程终端：', p.terminal()) Linux ps命令用于显示当前进程 (process) 的状态,psutil还提供了一个test()函数，可以模拟出ps命令的效果。 1print(psutil.test()) 独立的python运行环境virtualenv为python应用提供了隔离的Python运行环境，解决了不同应用间使用相同第三方或者外部模块引起多版本的冲突问题。 需要注意的是，pycharm创建的项目默认安装了virtualenv,并且pycharm terminal默认会进入venv环境。 安装virtualenv1$ pip3 install virtualenv venv环境venv环境是python项目根目录下的venv文件夹，通过命令virtualenv —no-site-packages可以让venv文件夹变为一个不带任何第三方包的“干净”的Python运行环境； 创建项目； 创建并进入venv环境，创建好venv环境后，命令行前面会有(venv)前缀，如下： 123456D:\pytest&gt; $ virtualenv --no-site-packages venvUsing base prefix &apos;/usr/local/.../Python.framework/Versions/3.4&apos;New python executable in venv/bin/python3.4Also creating executable in venv/bin/pythonInstalling setuptools, pip, wheel...done.(venv) D:\pytest&gt; venv环境指定项目的python版本 1$ virtualenv -p /usr/bin/python2.7 my_project 项目venv环境中安装第三方包： 1$ pip install chardet 退出venv环境： 1$ deactivate 进入venv环境： 1234//linux$ source my_project/bin/activate //windows$ my_project\venv\Scripts\activate 图形界面Python支持多种图形界面的第三方库，包括： Tk（Python自带的库Tkinter是支持Tk的） wxWidgets Qt GTK Tkinter Python内置的Tkinter可以满足基本的GUI程序的要求，如果是非常复杂的GUI程序，建议用操作系统原生支持的语言和库来编写. Tk是一个图形库，支持多个操作系统，使用Tcl语言开发； Tk会调用操作系统提供的本地GUI接口，完成最终的GUI。 Tkinter封装了访问Tk的接口,我们的代码只需要调用Tkinter提供的接口就可以了； GUI APIFrameFrame是所有Widget的父容器,Frame则是可以容纳其他Widget的Widget，所有的Widget组合起来就是一棵树。 GUI案例显示文本12345678910111213141516171819202122232425262728from tkinter import *# 从Frame派生一个Application类，这是所有Widget的父容器：class Application(Frame): def __init__(self, master=None): Frame.__init__(self, master) # pack()方法把Widget加入到父容器中 self.pack() self.createWidgets() def createWidgets(self): # 创建一个Label self.helloLabel = Label(self, text='Hello, world!') self.helloLabel.pack() # 创建一个Button self.quitButton = Button(self, text='Quit', command=self.quit) self.quitButton.pack()# 设置窗口在左上角和大小width, height, padx, pady = 300, 300, 0, 0Tk().geometry('%dx%d9+%d+%d' % (width, height, padx, pady))# 实例化Application，并启动消息循环app = Application()# 设置窗口标题:app.master.title('Hello World')# 主消息循环进入GUI界面app.mainloop() 输入和弹窗1234567891011121314151617181920212223242526272829303132from tkinter import *import tkinter.messagebox as messageboxclass Application(Frame): def __init__(self, master=None): Frame.__init__(self, master) self.pack() self.createWidgets() def createWidgets(self): # 创建一个输入框 self.nameInput = Entry(self) self.nameInput.pack() # 创建一个按钮 self.alertButton = Button(self, text='Hello', command=self.hello) self.alertButton.pack() def hello(self): name = self.nameInput.get() or 'world' # 显示一个弹窗 messagebox.showinfo('Message', 'Hello, %s' % name)# 设置窗口在左上角和大小width, height, padx, pady = 300, 300, 0, 0Tk().geometry('%dx%d9+%d+%d' % (width, height, padx, pady))app = Application()# 设置窗口标题:app.master.title('Hello World')# 主消息循环:app.mainloop() turtle Python内置了turtle库，基本上100%复制了原始的Turtle Graphics（海龟绘图）的所有功能。 turtle可以执行一个绘制图形的过程，绘制出各种复杂的图形； 案例绘制一个长方形1234567891011121314151617181920212223242526# 导入turtle包的所有内容:from turtle import *# 设置笔刷宽度:width(4)# 前进:forward(200)# 右转90度:right(90)# 笔刷颜色:pencolor('red')forward(100)right(90)pencolor('green')forward(200)right(90)pencolor('blue')forward(100)right(90)# 调用done()使得窗口等待被关闭，否则将立刻关闭窗口:done() 循环绘制5个五角星12345678910111213141516from turtle import *def drawStar(x, y): pu() goto(x, y) pd() # set heading: 0 seth(0) for i in range(5): fd(40) rt(144)for x in range(0, 250, 50): drawStar(x, 0)done() 绘制一棵分型树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from turtle import *# 设置色彩模式是RGB:colormode(255)lt(90)lv = 14l = 120s = 45width(lv)# 初始化RGB颜色:r = 0g = 0b = 0pencolor(r, g, b)penup()bk(l)pendown()fd(l)def draw_tree(l, level): global r, g, b # save the current pen width w = width() # narrow the pen width width(w * 3.0 / 4.0) # set color: r = r + 1 g = g + 2 b = b + 3 pencolor(r % 200, g % 200, b % 200) l = 3.0 / 4.0 * l lt(s) fd(l) if level &lt; lv: draw_tree(l, level + 1) bk(l) rt(2 * s) fd(l) if level &lt; lv: draw_tree(l, level + 1) bk(l) lt(s) # restore the previous pen width width(w)speed("fastest")draw_tree(l, 4)done() 网络编程用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。 TCP/IP 互联网的协议简称TCP/IP协议. IP协议IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 IPv4IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。 IPv6IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334. TCP协议TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。 一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。 三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 TCP协议栈的弱点TCP连接的资源消耗，其中包括：数据包信息、条件状态、序列号等。通过故意不完成建立连接所需要的三次握手过程，造成连接一方的资源耗尽。 端口80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。 TCP编程socket Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。 同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。 socket使用步骤示例1234567891011121314151617181920212223242526272829303132333435# 导入socket库:import socket# 1. 创建一个socket:# 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。# SOCK_STREAM指定使用面向流的TCP协议s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 2. 建立连接:s.connect(('www.sina.com.cn', 80))# 3. 发送数据:s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')# 4. 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: # 中断链接 breakdata = b''.join(buffer)# 5. 关闭连接:s.close()# 6. 处理结果# 把HTTP头打印出来，网页内容保存到文件header, html = data.split(b'\r\n\r\n', 1)print(header.decode('utf-8'))# 把接收的数据写入文件:with open('sina.html', 'wb') as f: f.write(html) 客户端客户端使用socket请求服务端并获得响应； 大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 服务器和客户端编程相比，服务器编程就要复杂一些。 服务端处理思路 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 CS通信示例创建一个服务端，用来接收到用户的链接，当接收到用户输入的信息时，都将接收的内容加上“我不明白”再发回去，用户输入exit时，客户端退出socket连接。 实现步骤如下： 服务端代码： 123456789101112131415161718192021222324252627282930313233343536373839import socketimport threadingimport times = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 绑定监听端口:# 可以用0.0.0.0绑定到所有的网络地址# s.bind(('0.0.0.0', 9999))# 可以用127.0.0.1绑定到本机地址,此时客户端必须同时在本机运行才能连接s.bind(('127.0.0.1', 9999))# 开始监听端口（传入的参数指定等待连接的最大数量）s.listen(5)print('Waiting for connection...')# 每个连接都必须创建新线程（或进程）来处理# 单线程在处理连接的过程中，无法接受其他客户端的连接；def tcplink(sock, addr): print('Accept new connection from %s:%s...' % addr) sock.send(b'Welcome!') while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode('utf-8') == 'exit': break sock.send(('我不明白"%s"是什么!' % data.decode('utf-8')).encode('utf-8')) sock.close() print('Connection from %s:%s closed.' % addr)# 服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() 客户端代码： 12345678910111213141516171819import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('127.0.0.1', 9999))# 接收欢迎消息:print(s.recv(1024).decode('utf-8'))# 通信：接收用户输入信息进行通信while True: inputStr = input("请输入信息，按回车发送：") if inputStr == 'exit': s.send(b'exit') s.close() print('通信结束！') break else: s.send(inputStr.encode('utf-8')) print(s.recv(1024).decode('utf-8')) UDP编程 TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 UDP的使用与TCP类似，但是不需要建立连接。此外，客户端不需要调用connect建立连接和服务端不需要调用listen，并且服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。 示例服务端和客户端使用UDP通信，服务端接收客户端信息，加上hello后，再返回给客户端； 服务端代码： 12345678910111213141516import socket# SOCK_DGRAM指定了这个Socket的类型是UDPs = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口# UDP不需要调用listen()方法，而是直接接收来自任何客户端的数据s.bind(('127.0.0.1', 9999))# 此处省略多线程的写法print('Bind UDP on 9999...')while True: # 接收数据(recvfrom()方法返回数据和客户端的地址与端口) data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) # 直接调用sendto()就可以把数据用UDP发给客户端 s.sendto(b'Hello, %s!' % data, addr) 客户端代码： 1234567891011import socketimport times = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8')) time.sleep(1)s.close() 实现收发电子邮件名词解释 MUA：Mail User Agent——邮件用户代理。 MTA：Mail Transfer Agent——邮件传输代理，就是那些Email服务提供商，比如网易、新浪等等。 MDA：Mail Delivery Agent——邮件投递代理。 收发邮件流程1发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人 要编写程序来发送和接收邮件，本质上就是： 编写MUA把邮件发到MTA； 编写MUA从MDA上收邮件; 协议发邮件时，MUA和MTA使用的协议就是SMTP：Simple Mail Transfer Protocol，后面的MTA到另一个MTA也是用SMTP协议。 收邮件时，MUA和MDA使用的协议有两种：POP：Post Office Protocol，目前版本是3，俗称POP3；IMAP：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。 SMTP服务器配置邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。 类似的，从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。 特别注意：代理客户端收发邮件，需要本地配置邮件的登录信息，并且，目前大多数邮件服务商都需要手动打开SMTP发信和POP收信的功能，否则只允许在网页登录; SMTP发送邮件 SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。 Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。 发文本邮件 构造邮件内容： 123456from email.mime.text import MIMEText# 构造MIMEText对象时传入的参数：# 第一个参数就是邮件正文，# 第二个参数是MIME的subtype，传入'plain'表示纯文本，最终的MIME就是'text/plain'，# 第二个参数utf-8编码保证多语言兼容性。msg = MIMEText('hello, send by Python...', 'plain', 'utf-8') 邮件主题、发件人、收件人信息并不是通过SMTP协议发给MTA，而是包含在发给MTA的文本中的，如果没有，可能无法发送； 主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from email.mime.text import MIMETextimport smtplibfrom email.utils import parseaddr, formataddrfrom email.header import Header# 格式化一个邮件地址(真实姓名+邮件地址)# (注意不能简单地传入name &lt;addr@example.com&gt;,如果包含中文，需要通过Header对象进行编码)def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, 'utf-8').encode(), addr))######################################################### 用户邮件服务信息配置 ########################################################## 通过SMTP发出去# 输入Email地址和口令:# from_addr = input('From: ')from_addr = 'xxx@163.com'# password = input('Password: ')password = 'xxx'# 输入收件人地址:# msg['To']接收的是字符串而不是list，如果有多个邮件地址，用,分隔即可。# to_addr = input('To: ')to_addr = 'xxx@qq.com'# 输入SMTP服务器地址:# smtp_server = input('SMTP server: ')smtp_server = 'smtp.163.com'################################################################################################################# 构造邮件内容 ########################################################## 发送内容为：纯文本# 构造邮件文本对象# msg = MIMEText('hello, send by Python...', 'plain', 'utf-8')# 发送内容为：HTMLmsg = MIMEText('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;' + '&lt;p&gt;send by &lt;a href="http://www.python.org"&gt;Python&lt;/a&gt;' '&lt;img height="92px" src="https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png" width="272px" alt="Google" /&gt;&lt;/p&gt;' + '&lt;/body&gt;&lt;/html&gt;', 'html', 'utf-8')# 发件人msg['From'] = _format_addr('发件人姓名 &lt;%s&gt;' % from_addr)# 收件人姓名可能被邮件服务商替换成注册用户名msg['To'] = _format_addr('收件人姓名 &lt;%s&gt;' % to_addr)msg['Subject'] = Header('邮件标题', 'utf-8').encode()################################################################################################################# 发邮件服务 ########################################################## SMTP协议默认端口是25server = smtplib.SMTP(smtp_server, 25)# 打印出和SMTP服务器交互的所有信息server.set_debuglevel(1)# login()方法用来登录SMTP服务器server.login(from_addr, password)# 发邮件# 由于可以一次发给多个人，所以传入一个list# 邮件正文是一个str，as_string()把MIMEText对象变成strserver.sendmail(from_addr, [to_addr], msg.as_string())server.quit()######################################################## 发送附件带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，所以，可以构造一个MIMEMultipart对象代表邮件本身，然后往里面加上一个MIMEText作为邮件正文，再继续往里面加上表示附件的MIMEBase附件对象即可； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from email import encodersfrom email.mime.base import MIMEBasefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport smtplibfrom email.utils import parseaddr, formataddrfrom email.header import Header# 格式化一个邮件地址(真实姓名+邮件地址)# (注意不能简单地传入name &lt;addr@example.com&gt;,如果包含中文，需要通过Header对象进行编码)def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, 'utf-8').encode(), addr))######################################################### 用户邮件服务信息配置 ########################################################## 通过SMTP发出去# 输入Email地址和口令:# from_addr = input('From: ')from_addr = 'xxx@163.com'# password = input('Password: ')password = 'xxx'# 输入收件人地址:# msg['To']接收的是字符串而不是list，如果有多个邮件地址，用,分隔即可。# to_addr = input('To: ')to_addr = 'xxx@qq.com'# 输入SMTP服务器地址:# smtp_server = input('SMTP server: ')smtp_server = 'smtp.163.com'################################################################################################################# 构造邮件内容 ########################################################## 邮件对象:msg = MIMEMultipart()# 添加发件人msg['From'] = _format_addr('发件人姓名 &lt;%s&gt;' % from_addr)# 添加收件人姓名可能被邮件服务商替换成注册用户名msg['To'] = _format_addr('收件人姓名 &lt;%s&gt;' % to_addr)# 添加邮件标题msg['Subject'] = Header('邮件标题', 'utf-8').encode()# 添加邮件正文是MIMEText:msg.attach(MIMEText('send with file...', 'plain', 'utf-8'))# 添加附件就是加上一个MIMEBase，从本地读取一个图片:with open('./taylor_swift.jpg', 'rb') as f: # 设置附件的MIME和文件名，这里是png类型: mime = MIMEBase('image', 'jpg', filename='taylor_swift.png') # 加上必要的头信息: mime.add_header('Content-Disposition', 'attachment', filename='taylor_swift.png') mime.add_header('Content-ID', '&lt;0&gt;') mime.add_header('X-Attachment-Id', '0') # 把附件的内容读进来: mime.set_payload(f.read()) # 用Base64编码: encoders.encode_base64(mime) # 添加到MIMEMultipart: msg.attach(mime)################################################################################################################# 发邮件服务 ########################################################## SMTP协议默认端口是25server = smtplib.SMTP(smtp_server, 25)# 打印出和SMTP服务器交互的所有信息server.set_debuglevel(1)# login()方法用来登录SMTP服务器server.login(from_addr, password)# 发邮件# 由于可以一次发给多个人，所以传入一个list# 邮件正文是一个str，as_string()把MIMEText对象变成strserver.sendmail(from_addr, [to_addr], msg.as_string())server.quit()######################################################## 发送图片邮件服务商一般自动屏蔽邮件正文的图片，如果将图片添加邮件html正文，需要先上传图片，然后按照顺序编号cid:x引用图片即可； 在上传附件的代码后添加如下代码： 123msg.attach(MIMEText('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;' + '&lt;p&gt;&lt;img src="cid:0"&gt;&lt;/p&gt;' + '&lt;/body&gt;&lt;/html&gt;', 'html', 'utf-8')) 同时支持HTML和Plain格式如果我们发送HTML邮件，收件人通过浏览器或者Outlook之类的软件是可以正常浏览邮件内容的，但是，如果收件人使用的设备太古老，查看不了HTML邮件怎么办？ 办法是在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。 利用MIMEMultipart就可以组合一个HTML和Plain，要注意指定subtype是alternative： 12345678msg = MIMEMultipart('alternative')msg['From'] = ...msg['To'] = ...msg['Subject'] = ...msg.attach(MIMEText('hello', 'plain', 'utf-8'))msg.attach(MIMEText('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;', 'html', 'utf-8'))# 正常发送msg对象... 加密SMTP使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。 只需要在创建SMTP对象后，立刻调用starttls()方法，就创建了安全连接。 示例某些邮件服务商，例如Gmail，提供的SMTP服务必须要加密传输。我们来看看如何通过Gmail提供的安全SMTP发送邮件。必须知道，Gmail的SMTP端口是587，因此，修改代码如下： 1234567smtp_server = 'smtp.gmail.com'smtp_port = 587server = smtplib.SMTP(smtp_server, smtp_port)server.starttls()# 剩下的代码和前面的一模一样:server.set_debuglevel(1)... SMTP发件总结使用Python的smtplib发送邮件十分简单，只要掌握了各种邮件类型的构造方法，正确设置好邮件头，就可以顺利发出。 构造一个邮件对象就是一个Messag对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下： 1234567Message+- MIMEBase +- MIMEMultipart +- MIMENonMultipart +- MIMEMessage +- MIMEText +- MIMEImage 这种嵌套关系就可以构造出任意复杂的邮件。你可以通过email.mime文档查看它们所在的包以及详细的用法。 POP3收取邮件收取邮件就是编写一个MUA作为客户端，从MDA把邮件获取到用户的电脑或者手机上。收取邮件最常用的协议是POP协议，目前版本号是3，俗称POP3。 Python内置一个poplib模块，实现了POP3协议，可以直接用来收邮件。 收邮件 注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。 要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类来解析原始文本，变成可阅读的邮件对象。 收取邮件分两步： 用poplib把邮件的原始文本下载到本地； 用email解析原始文本，还原为邮件对象。 用Python的poplib模块收取邮件分两步：第一步是用POP3协议把邮件获取到本地，第二步是用email模块把原始邮件解析为Message对象，然后，用适当的形式把邮件内容展示给用户即可。 通过POP3获取邮件POP3协议本身很简单，以下面的代码为例，我们来获取最新的一封邮件内容： 用POP3获取邮件其实很简单，要获取所有邮件，只需要循环使用retr()把每一封邮件内容拿到即可。真正麻烦的是把邮件的原始内容解析为可以阅读的邮件对象。 如下获取邮件的代码（包含删除邮件）： 123456789101112131415161718192021222324252627282930313233343536373839404142import poplibfrom email.parser import Parser# 1.输入邮件地址, 口令和POP3服务器地址:email = input('Email: ')password = input('Password: ')pop3_server = input('POP3 server: ')# 2.连接到POP3服务器:server = poplib.POP3(pop3_server)# 可以打开或关闭调试信息:server.set_debuglevel(1)# 可选:打印POP3服务器的欢迎文字:print(server.getwelcome().decode('utf-8'))# 身份认证:server.user(email)server.pass_(password)# 3.stat()返回邮件数量和占用空间:print('Messages: 邮件数量：%s 占用空间: %s' % server.stat())# list()返回所有邮件的编号，编号即索引从1开始:resp, mails, octets = server.list()# 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]，内容为邮件编号和占用空间；print('邮件列表',mails)# 获取最新一封邮件, 注意索引号从1开始:index = len(mails)resp, lines, octets = server.retr(index)# lines存储了邮件的原始文本的每一行,# 可以获得整个邮件的原始文本:msg_content = b'\r\n'.join(lines).decode('utf-8')# print('邮件原始内容为：', msg_content)# 稍后解析出邮件:msg = Parser().parsestr(msg_content)# print('邮件原始内容为：', msg)# 可以根据邮件索引号直接从服务器删除邮件:# server.dele(index)# 关闭连接:server.quit() 解析邮件解析邮件的过程和上一节构造邮件正好相反，因此，先导入必要的模块，只需要一行代码就可以把邮件内容解析为Message对象： 12345678from email.parser import Parserfrom email.header import decode_headerfrom email.utils import parseaddrimport poplib...msg = Parser().parsestr(msg_content) 但是这个Message对象本身可能是一个MIMEMultipart对象，即包含嵌套的其他MIMEBase对象，嵌套可能还不止一层。所以我们要递归地打印出邮件Message对象的层次结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 解码邮件内容# 邮件的Subject或者Email中包含的名字都是经过编码后的str，要正常显示，就必须decode：def decode_str(s): value, charset = decode_header(s)[0] if charset: value = value.decode(charset) return value# 文本邮件的内容也是str，还需要检测编码，否则，非UTF-8编码的邮件都无法正常显示：def guess_charset(msg): charset = msg.get_charset() if charset is None: content_type = msg.get('Content-Type', '').lower() pos = content_type.find('charset=') if pos &gt;= 0: charset = content_type[pos + 8:].strip() return charset# 打印出邮件Message对象的层次结构# indent用于缩进显示:def print_info(msg, indent=0): if indent == 0: print('------------打印邮件简介------------') for header in ['From', 'To', 'Subject']: value = msg.get(header, '') if value: if header == 'Subject': value = decode_str(value) else: hdr, addr = parseaddr(value) name = decode_str(hdr) value = u'%s &lt;%s&gt;' % (name, addr) print('%s%s: %s' % (' ' * indent, header, value)) print('------------打印邮件简介-end-----------') if msg.is_multipart(): parts = msg.get_payload() for n, part in enumerate(parts): print('%spart %s' % (' ' * indent, n)) print('%s--------------------' % (' ' * indent)) print_info(part, indent + 1) else: content_type = msg.get_content_type() if content_type == 'text/plain' or content_type == 'text/html': content = msg.get_payload(decode=True) charset = guess_charset(msg) if charset: content = content.decode(charset) print('%sText: %s' % (' ' * indent, content + '...')) else: print('%sAttachment: %s' % (' ' * indent, content_type)) 数据的存储定义数据的存储格式，主要有以下方式： 文本文件存储：每条数据一行，字段用逗号隔开； json文本文件存储：数据以json的格式保存本地； SQLite MySQL SQLiteSQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。 使用SQLite Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。 在Python中操作数据库时，要先导入数据库对应的驱动，然后，通过Connection对象和Cursor对象操作数据。 要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。 使用try:…except:…finally:…确保关闭掉Connection对象和Cursor对象； 必须提交事务，修改的操作才会生效； SQLite的sql中的参数占位符是问号?; python操作数据库查询表的结果是list，list的每一个元素是tuple； 示例代码如下： 12345678910111213141516171819202122232425262728293031323334# 导入SQLite驱动:import sqlite3# 连接到SQLite数据库# 数据库文件是test.db# 如果文件不存在，会自动在当前目录创建:conn = sqlite3.connect('test_sqlite.db')# 创建一个Cursor:cursor = conn.cursor()# 执行一条SQL语句，创建user表:cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')# 继续执行一条SQL语句，插入一条记录:cursor.execute("insert into user (id, name) values ('1', 'zhangsan')")cursor.execute("insert into user (id, name) values ('2', 'lisi')")# 通过rowcount获得插入的行数:print(cursor.rowcount)# 执行查询语句:cursor.execute('select * from user where id=?', ('1',))# 获得查询结果集:values = cursor.fetchall()print(values)# 关闭Cursor:cursor.close()# 提交事务(必须提交事务，修改的操作才会生效)conn.commit()# 关闭Connection:conn.close() 如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，例如： 1cursor.execute('select * from user where name=? and pwd=?', ('abc', 'password')) MySQL安装MySQL驱动12345678//mysql官方驱动// --allow-external允许外部地址的标签，只有打上该标签pip方可下载外部地址模块pip install mysql-connector-python --allow-external mysql-connector-python//如果加--allow-external失败，就去掉pip install mysql-connector-python//如果上面的命令安装失败，可以试试另一个驱动：pip install mysql-connector 操作MySQL 执行INSERT等操作后要调用commit()提交事务； 操作MySQL同操作Sqlite相同，但是MySQL的SQL中的参数占位符是%s。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334# 1. 导入MySQL驱动:import mysql.connector# 2. 连接数据库config = &#123; 'host': 'localhost', 'user': 'root', 'password': '123456', 'database': 'test', 'port': 3306, 'charset': 'utf8'&#125;conn = mysql.connector.connect(**config)# 3. 初见cursor对象操作数据库cursor = conn.cursor()# 4. 创建user表:cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')# 5. 插入一行记录，注意MySQL的占位符是%s:cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])print(cursor.rowcount)# 6. 提交事务（必须提交事务才能修改数据）:conn.commit()cursor.close()# 运行查询:cursor = conn.cursor()cursor.execute('select * from user where id = %s', ('1',))values = cursor.fetchall()print(values)# 关闭Cursor和Connection:cursor.close()conn.close() ORMORM即Object-Relational Mapping，把关系数据库的表结构映射到对象上。ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。 SQLAlchemy在Python中，最有名的ORM框架是SQLAlchemy。 安装1$ pip install sqlalchemy 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 1. 导入:from sqlalchemy import Column, String, create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_base# 2. 创建对象的基类:Base = declarative_base()# 3. 定义User对象:class User(Base): # 表的名字: __tablename__ = 'user' # 表的结构: id = Column(String(20), primary_key=True) name = Column(String(20))# 4. 初始化数据库连接: create_engine('数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名')engine = create_engine('mysql+mysqlconnector://root:123456@localhost:3306/test')# 5. 创建DBSession类型(DBSession对象可视为当前数据库连接):DBSession = sessionmaker(bind=engine)# 6. ORM对数据库进行操作# 6.1 利用ORM:向数据库表中添加一行记录# 创建session对象:session = DBSession()# 创建新User对象:new_user = User(id='5', name='Bob')# 添加到session:session.add(new_user)# 提交即保存到数据库:session.commit()# 关闭session:session.close()# 6.2 利用ORM:向数据库表查询一行记录# 创建Session:session = DBSession()# 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:user = session.query(User).filter(User.id == '5').one()# 打印类型和对象的name属性:print('type:', type(user))print('name:', user.name)# 关闭Session:session.close() web开发HTTP状态码响应代码： 200表示成功； 3xx表示重定向； 4xx表示客户端发送的请求有错误； 5xx表示服务器端处理时发生了错误； HTTP格式每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。 Body： Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。 当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。 WSGIWSGI(Web Server Gateway Interface),WSGI接口定义非常简单，它只要求Web开发者实现一个函数，WSGI的处理函数，针对每个HTTP请求进行响应； Python内置了一个WSGI服务器，这个模块叫wsgiref，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。 无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。 复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。 http请求信息1234//请求方式：GET/POST/PUT/DELETEmethod = environ[&apos;REQUEST_METHOD&apos;]//请求的地址，返回一个listpath = environ[&apos;PATH_INFO&apos;] 根据请求响应如果通过判断请求信息来响应结果，项目将难以维护，此时就需要web框架了； 12345678def application(environ, start_response): method = environ[&apos;REQUEST_METHOD&apos;] path = environ[&apos;PATH_INFO&apos;] if method==&apos;GET&apos; and path==&apos;/&apos;: return handle_home(environ, start_response) if method==&apos;POST&apos; and path=&apos;/signin&apos;: return handle_signin(environ, start_response) ... 示例如下，hello.py文件中定义用来响应客户端请求的函数，server.py利用wsgiref定义一个服务监听请求，响应application函数返回的结果； 123456# hello.pydef application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) body = '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % (environ['PATH_INFO'][1:] or 'web') return [body.encode('utf-8')] 123456789101112# server.py# 从wsgiref模块导入:from wsgiref.simple_server import make_server# 导入我们自己编写的application函数:from hello import application# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:httpd = make_server('', 8000, application)print('Serving HTTP on port 8000...')# 开始监听HTTP请求:httpd.serve_forever() web框架 Flask: 轻量级 Web 应用框架(hot); Django：全能型Web框架； web.py：一个小巧的Web框架； Bottle：和Flask类似的Web框架； Tornado：Facebook的开源异步Web框架。 Flask Flask 是Python比较流行的Web框架; Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。Flask没有默认使用的数据库、窗体验证工具。用 extension增加其他功能。 然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。此文章时的最新版本为1.0.2。 安装Flask1pip install -U Flask WebAPI核心概念 Flask通过Python的装饰器在内部自动地把URL和处理函数给关联起来; Flask自带的Server在端口5000上监听; Flask通过request.form[‘name’]来获取表单的内容。 示例Flask框架，编写接口来支持GET/POST请求返回html; 123456789101112131415161718192021222324252627282930from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def home(): return '&lt;h1&gt;Home&lt;/h1&gt;'@app.route('/signin', methods=['GET'])def signin_form(): return '''&lt;form action="/signin" method="post"&gt; &lt;p&gt;&lt;input name="username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;button type="submit"&gt;Sign In&lt;/button&gt;&lt;/p&gt; &lt;/form&gt;'''@app.route('/signin', methods=['POST'])def signin(): # 需要从request对象读取表单内容： if request.form['username'] == 'admin' and request.form['password'] == 'password': return '&lt;h3&gt;Hello, admin!&lt;/h3&gt;' return '&lt;h3&gt;Bad username or password.&lt;/h3&gt;'if __name__ == '__main__': app.run() jinja2模板技术模板技术，我们以MVC模式进行开发： Controller层：Controller负责业务逻辑，即处理请求URL的函数； View层：HTML文档作为view层的UI模板，嵌入了一些变量 和指令，根据我们动态传入的数据，替换后，得到最终的HTML，发送给用户； Model层：是用来传给View的数据，通常dict作为Model； 通过MVC，我们在Python代码中处理M：Model和C：Controller，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。 jinja2 Flask通过render_template()函数来实现模板的渲染，具体html中支持模板渲染需要是jinja2。 和Web框架类似，Python的模板也有很多种。Flask默认支持的模板是jinja2，所以我们先直接安装jinja2： 1pip install jinja2 jinja2-API在Jinja2模板中: 模板文件：一定要把html模板放到templates目录下，templates和server.py服务文件在同级目录下； 12345project|- server.py|- templates |- home.html |- signin.html 变量：用表示一个需要替换的变量。 语法指令：很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用 1&#123;% ... %&#125; 表示指令，逻辑判断的语法就写在指令中。 1234&lt;!--比如循环输出的代码--&gt;&#123;% for i in page_list %&#125; &lt;a href="/page/&#123;&#123; i &#125;&#125;"&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125; 示例使用mvc模式简单的实现一个用户登录的功能！ 1.编写模板(templates): 首页模板home.html: 123456789&lt;!--用来显示首页的模板--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style="font-style:italic"&gt;Home&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 登录页面模板from.html: 12345678910111213141516171819&lt;!--用来显示登录表单的模板--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Please Sign In&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% if message %&#125;&lt;p style="color:red"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&#123;% endif %&#125;&lt;form action="/signin" method="post"&gt; &lt;legend&gt;Please sign in:&lt;/legend&gt; &lt;p&gt;&lt;input name="username" placeholder="Username" value="&#123;&#123; username &#125;&#125;"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" placeholder="Password" type="password"&gt;&lt;/p&gt; &lt;p&gt; &lt;button type="submit"&gt;Sign In&lt;/button&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录成功页面模板signin-ok.html: 123456789&lt;!--登录成功的模板：--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Welcome, &#123;&#123; username &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Welcome, &#123;&#123; username &#125;&#125;!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2.编写Controller/Model层：server.py 1234567891011121314151617181920212223242526from flask import Flask, request, render_templateapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def home(): return render_template('home.html')@app.route('/signin', methods=['GET'])def signin_form(): return render_template('form.html')@app.route('/signin', methods=['POST'])def signin(): username = request.form['username'] password = request.form['password'] if username == 'admin' and password == 'password': return render_template('signin-ok.html', username=username) return render_template('form.html', message='Bad username or password', username=username)if __name__ == '__main__': app.run() 其它模板框架除了Jinja2，常见的模板还有： 123- Mako：用&lt;% ... %&gt;和$&#123;xxx&#125;的一个模板；- Cheetah：也是用&lt;% ... %&gt;和$&#123;xxx&#125;的一个模板；- Django：Django是一站式框架，内置一个用&#123;% ... %&#125;和&#123;&#123; xxx &#125;&#125;的模板。 异步IO在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。 解决IO阻塞的方法： 多线程； 异步IO； 多线程解决IO阻塞解决方式因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。 性能问题多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。 由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。 异步IO解决IO阻塞解决IO阻塞问题的另一种解决方法是异步IO。 在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。 协程协程，又称微线程，纤程。英文名coroutine（协同程序）。即多个程序系统完成工作的过程； 概念子程序 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，子程序调用总是一个入口，一次返回，调用顺序是明确的。一个线程就是执行一个子程序。 协程和子程序 而协程的调用和子程序不同。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 特点优势 协程可以看成子程序的切换，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，因此协程有着极高的执行效率。和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 协程是一个线程执行，利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 协程的实现Python对协程的支持是通过generator实现的。 在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。 示例解释协程传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高； 123456789101112131415161718192021222324import timedef consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) time.sleep(1) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 注意到consumer函数是一个generator，把一个consumer传入produce后： 首先调用c.send(None)启动生成器； 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； consumer通过yield拿到消息，处理，又通过yield把结果传回； produce拿到consumer处理的结果，继续生产下一条消息； produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 asyncio asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持,asyncio提供了完善的异步IO支持； asyncio可以实现单线程并发IO操作. asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。 asyncio使用步骤 用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from异步调用另一个coroutine实现异步操作。 @asyncio.coroutine把一个generator函数逻辑标记为coroutine类型，处理函数的内部异步操作需要在coroutine中通过yield from完成；然后，我们就把这个coroutine扔到EventLoop中执行。 yield from语法可以方便地异步调用另一个耗时逻辑的coroutine； coroutine类型函数的多次调用，可以封装成一组Task然后并发执行。 EventLoop等待asyncio.wait(tasks)并发执行多个任务； 关闭EventLoop； asyncio并发示例示例1：实现并发执行两个耗时逻辑！ 12345678910111213import threadingimport asyncio@asyncio.coroutinedef hello(): print('Hello world! (%s)' % threading.currentThread()) yield from asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread())loop = asyncio.get_event_loop()tasks = [hello(), hello()]loop.run_until_complete(asyncio.wait(tasks))loop.close() 两个coroutine是由同一个线程并发执行的。asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。 示例2：用asyncio的异步网络连接来获取sina、sohu和163的网站首页! 123456789101112131415161718192021222324import asyncio@asyncio.coroutinedef wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) reader, writer = yield from connect header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host writer.write(header.encode('utf-8')) # writer.drain()执行写操作 yield from writer.drain() while True: line = yield from reader.readline() if line == b'\r\n': break print('%s header &gt; %s' % (host, line.decode('utf-8').rstrip())) # Ignore the body, close the socket writer.close()loop = asyncio.get_event_loop()# 3个连接由一个线程通过coroutine并发完成。tasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]loop.run_until_complete(asyncio.wait(tasks))loop.close() async/await 新异步IO语法； 为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让异步执行coroutine的代码更简洁易读。 使用请注意，async和await是针对coroutine的新语法，要使用新的语法，只需要对asyncio做两步简单的替换： 把@asyncio.coroutine替换为async； 把yield from替换为await。 示例代码并发执行异步任务打印hello！ 1234567891011import asyncioasync def hello(): print("Hello world!") r = await asyncio.sleep(1) print("Hello again!")loop = asyncio.get_event_loop()tasks = [hello(), hello()]loop.run_until_complete(asyncio.wait(tasks))loop.close() aiohttp 服务器端实现单线程+coroutine并发IO操作; asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。 asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。 安装aiohttp1pip install aiohttp 使用创建aiohttp的初始化函数init()，init()也是一个coroutine，在函数中loop.create_server()则利用asyncio创建TCP服务。 示例编写一个HTTP服务器，分别处理以下URL： 12/ - 首页返回b&apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;；/hello/&#123;name&#125; - 根据URL参数返回文本hello, %s!。 代码实现： 1234567891011121314151617181920import asynciofrom aiohttp import webasync def index(request): await asyncio.sleep(0.5) return web.Response(body=b&apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;)async def hello(request): await asyncio.sleep(0.5) text = &apos;&lt;h1&gt;hello, %s!&lt;/h1&gt;&apos; % request.match_info[&apos;name&apos;] return web.Response(body=text.encode(&apos;utf-8&apos;))app = web.Application()app.router.add_routes([ web.get(&apos;/&apos;, index), web.get(&apos;/hello/&#123;name&#125;&apos;, hello)])print(&apos;Server started at http://127.0.0.1:8080...&apos;)web.run_app(app) 或者用loop: 123456789101112131415161718192021222324import asynciofrom aiohttp import webasync def index(request): await asyncio.sleep(0.5) return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;')async def hello(request): await asyncio.sleep(0.5) text = '&lt;h1&gt;hello, %s!&lt;/h1&gt;' % request.match_info['name'] return web.Response(body=text.encode('utf-8'))async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/&#123;name&#125;', hello) srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000) print('Server started at http://127.0.0.1:8000...') return srvloop = asyncio.get_event_loop()loop.run_until_complete(init(loop))loop.run_forever()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6转码工具babel7.x的配置]]></title>
    <url>%2F2018%2F08%2F30%2Fweb%2FJavaScript%2FES6%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7babel7.x%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录ES6转码工具babel7.x的配置。 babel简介Babel是一种工具链，主要用于将ECMAScript 2015+代码转换为能够运行在当前或旧版浏览器环境中的向后兼容版本的JavaScript； 必备工具包安装12345678910111213//核心库yarn add @babel/core -D //babel核心库【required】yarn add @babel/cli -D //babel命令行js转义工具yarn add @babel/polyfill -S //新API垫片库，如Promise/Arrary.include...; 【required】//presets预设库yarn add @babel/preset-env -D //es2015+预设 【required】yarn add @babel/preset-react -D //JSX和React的预设//plugins插件库@babel/runtime -S //【required】@babel/runtime-corejs2 -S //【required】@babel/plugin-transform-runtime -D //自动添加引用并去除冗余重复的引用，依赖runtime和corejs【required】 babel7配置配置到babel.config.js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * babel v7.0.0配置 * @type &#123;&#123;presets: *[], plugins: *[]&#125;&#125; */// let env = process.env.NODE_ENV;// env === "production";//---------------------------------------// const presets = [ ... ];// const plugins = [ ... ];// if (process.env["ENV"] === "prod") &#123;// plugins.push(...);// &#125;// module.exports = &#123; presets, plugins &#125;;//---------------------------------------module.exports = &#123; //预设作为转义的依赖 presets: [ [ "@babel/preset-env", &#123; /** * useBuiltIns(配置是否自动引入polyfill) * 1&gt; entry: 全局查找替换引入polyfill的方式(import '@babel/polyfill'-&gt;require()); * 2&gt; usage: 在需要用到polyfill的引用时，会自动加上,此设置下不可使用import引入polyfill的方式。 * 3&gt; false: 不适用； */ useBuiltIns: 'usage', debug: true, //debug模式会在控制台打印出所有插件中的log，已经插件的版本； targets: &#123; //指定要支持的最小环运行境的版本(浏览器和node) //查询的方式配置需要兼容浏览器环境 browsers: [ "last 2 versions", "ie &gt; 8", ], //单独配置需要最小兼容的浏览器环境 // "chrome": "41", // "ie": "8", // "edge": "12", // "firefox": "46", // "safari": "10", // "ios": "10", android: "4.0.3", //node环境配置 node: "current", //使用当前版本的node,可以直接使用版本号(如：6.10) &#125;, //是否将ES6的模块化语法转译成其他类型 //可选配置包括："amd"|"umd"|"systemjs"|"commonjs"|false,默认使用"commonjs"。即，将代码中的ES6的import转为require。 modules: 'commonjs', //强制开启某些模块，默认为[] // "include": [], //禁用某些模块，默认为[] // "exclude": [], &#125; ], ["@babel/preset-react"] ], /** * 插件配置 * 插件指示Babel如何对代码进行转换 */ plugins: [ [ //自动引入需要的runtime工具库,并自动去除重复引用,需要提前安装需要的工具包； "@babel/plugin-transform-runtime", &#123; //以下是默认配置 // corejs: false, //通过ES3实现了大部分的ES5、6、7的垫片库； // helpers: true, //是否自动引入helper(babel的一些工具函数) // regenerator: true, //是否自动引入regenerator(来自facebook用于实现generator functions) // useESModules: false &#125; ] ] //---------------------------------- //针对不同环境进行选择性配置，7.0新增 // overrides: []&#125;;]]></content>
      <categories>
        <category>大前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less使用笔记]]></title>
    <url>%2F2018%2F08%2F28%2Fweb%2FCSS%2Fless%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录less的使用笔记。 概述Less是一门CSS预处理语言，使用方式类似sass。 参考网站 less官网 使用less 安装less： 1$ yarn -D add less 编译less文件： less包bin目录中有lessc文件用来执行编译less文件为css文件； 变量概述less使用@符号定义和使用变量； 变量定义变量123456789101112131415//1.用一个变量来定义另一个变量；@colorVar: #fff;@myColor: @colorVar;#testId::before &#123; color: @myColor;&#125;//2.@符号加一个变量值是字符串等于另一个变量名组合的变量；@contentVar: 'hello world';@myContent: 'contentVar';#testId::after &#123; content: @@myContent;&#125; 变量运算变量运算: 运算符和变量之间一定要加空格，否则会被认为是变量名； 12- 加减法时：以第一个数据的单位为基准;- 乘除法时：注意单位一定要统一; 示例： 12345678910@width: 300px;@color: #222;#operation &#123; width: @width - 20; height: @width - 20*5; margin: (@width - 20)*5; color: @color * 2; background-color: @color + 111; border-color: @color + #111;&#125; 变量的类型1234567891011121314151617181920212223242526272829303132333435363738// 1.值变量：@theme-color: red;.app &#123; width: 100px; height: 200px; background-color: @theme-color;&#125;// 2.选择器变量：变量名必须使用大括号包裹；@classSelector: wrap;.@&#123;classSelector&#125; &#123; color: #999; width: 50%;&#125;@idSelector: wrap;#@&#123;idSelector&#125; &#123; color: #666;&#125;//3.属性变量：变量名必须使用大括号包裹；@borderStyle: border-style;#wrap &#123; @&#123;borderStyle&#125;: solid;&#125;//4. url变量：可用于给地址加统一前缀；@baseImageUrl: "http://www.lewei.cool";.myImage &#123; background: url("@&#123;baseImageUrl&#125;/dog.png");&#125;//5. 样式表变量：指一组样式，使用时需要在变量后加圆括号()来引入;@listBackground: &#123; background: red; &#125;;.listBox &#123; @listBackground();&#125; 样式嵌套 less支持选择器多级嵌套，但是层级越深效率月低，推荐限制在两个层级； 1234567891011.box &#123; .title &#123; color: #000; &#125; #item &#123; font-size: 12pt; #content &#123; color: red; &#125; &#125;&#125; 嵌套内引用父选择器名，可以使用&amp;代表父选择器名； 1234567891011#header &#123; &amp;:after &#123; content: "Less is more!"; &#125; .title &#123; font-weight: bold; &#125; &amp;_content &#123; margin: 20px; &#125;&#125; 媒体查询嵌套：缺点是每一个元素都会编译出自己的@media样式表，并不会合并。 12345678910#main &#123; @media screen &#123; @media (max-width: 768px) &#123; width: 100px; &#125; &#125; @media tv &#123; width: 2000px; &#125;&#125; mix混合器方法mix混合器方法用来优化代码，将多次使用的样式封装到公共的方法来获取，提高代码的质量； 无参方法无参数混合器方法: 混合器方法必须使用.做前缀； 定义时：可以不加括号，但是不推荐。不加括号不仅代表混合器方法，也代表一个样式表，都会被单独编译； 使用时：引用时，直接引入选择器或者引入选择器并且加括号,两种引用方式等价； 123456789101112.mix-card() &#123; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58);&#125;.myCard &#123; .mix-card;&#125;#myCard &#123; .mix-card();&#125; 带参方法12345678910111213141516171819202122232425// 1&gt; 普通带参数方法：.me-padding(@top,@right,@bottom,@left) &#123; padding: @top @right @bottom @left;&#125;.myArg &#123; .me-padding(3px, 3px, 4px, 4px);&#125;// 2&gt; 默认参数方法：.me-margin(@top: 6px,@right: 6px,@bottom: 6px,@left: 6px) &#123; margin: @top @right @bottom @left;&#125;#my-margin-default &#123; .me-margin;&#125;#my-margin &#123; .me-margin(11px, 11px);&#125;#my-margin-all &#123; .me-margin(11px, 11px, 11px, 11px);&#125; 全参关键字全部参数关键字：arguments 1234567.mix-args(@width,@style,@color) &#123; border: @arguments;&#125;#me-args &#123; .mix-args(1px, solid, blue);&#125; 匹配模式混合器方法的匹配模式: 与面向对象中的多态相似; 如果匹配的参数使用常量做标识，使用时会优先使用匹配程度最高的方法，如果匹配程度相同，将合并样式。 如果匹配的参数是变量，使用@_标识； 12345678910111213141516171819202122232425262728293031323334353637// 示例：显示各个方向上的三角形箭头？//常量匹配模式.triangle(top,@width:20px,@color:#f00) &#123; border-width: @width; border-color: transparent transparent @color transparent; border-style: dashed dashed solid dashed;&#125;.triangle(bottom,@width:20px,@color:#f00) &#123; border-width: @width; border-color: @color transparent transparent transparent; border-style: solid dashed dashed dashed;&#125;.triangle(right,@width:20px,@color:#f00) &#123; border-width: @width; border-color: transparent transparent transparent @color; border-style: dashed dashed solid dashed;&#125;.triangle(left,@width:20px,@color:#f00) &#123; border-width: @width; border-color: transparent @color transparent transparent; border-style: dashed solid dashed dashed;&#125;//变量匹配模式，与常量匹配程度相同；.triangle(@_,@width:20px,@color:#f00) &#123; width: 0; height: 0; overflow: hidden;&#125;.arrow &#123; .triangle(bottom, 100px);&#125; 方法命名空间使用命名空间方法时，使用符号&gt;标识的直接子方法的父方法不能加括号； 12345678910.namespace() &#123; background: #723232; .d(@w:300px) &#123; width: @w; &#125;&#125;#namespace &#123; .namespace &gt; .d(1px);&#125; 数量不定的参数方法接受数量不定的参数，可以使用…表示，用arguments关键字引用; 123456789101112.boxShadow(...) &#123; box-shadow: @arguments;&#125;.textShadow(@a,...) &#123; text-shadow: @arguments;&#125;#main &#123; .boxShadow(1px, 4px, 30px, red); .textShadow(1px, 4px, 30px, red);&#125; 批量important方法使用important,来让混合器方法内部样式批量添加important，直接在方法名后加上important关键字即可； 12345678.level-border &#123; border: solid 1px red; margin: 50px;&#125;#main &#123; .level-border !important;&#125; 条件筛选方法Less没有if…else表达式，less用when…and/not来做条件匹配； 1234567891011121314151617181920#condition &#123; // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999)&#123; border: @style @color @width; &#125; // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222) &#123; background: @color; &#125; // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px), (@size&lt;100px) &#123; font-size: @size; &#125;&#125;#condition &#123; #condition&gt; .border(200px, #999, solid); #condition .background(#111); #condition &gt; .font(40px);&#125; 循环方法Less并没有提供for循环功能，可以使用递归去实现。 12345678.generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1));&#125;.generate-columns(4); 继承extend是Less的一个伪类。它可继承所匹配声明中的全部样式。extend扩展样式必须放在选择器最后面; 1234567891011121314151617181920212223242526272829.animation() &#123; transition: all .3s ease-out; .animationChild &#123; transform: scale(0); &#125;&#125;.test&#123; width: 100px;&#125;//继承单个选择器样式#extend1 &#123; &amp;:extend(.animation);&#125;#extend2 &#123; &amp;:extend(.animation .animationChild);&#125;//继承多个选择器样式#extend3 &#123; &amp;:extend(.animation .hide,.test);&#125;//继承某个选择器的所有样式#extend4 &#123; &amp;:extend(.animation all);&#125; 引用外部样式less使用外部样式 普通导入并使用外部样式： 12@import "outerLess";@import "outerLess.less"; 导入外部样式文件，但不编译到css，只会编译引用到的样式【推荐导入方式】： 1234@import (reference) "outerLess";.title&#123; .outerThemeColor;&#125; @import (once)导入方式，@import语句的默认行为,相同的文件只会被导入一次，随后的导入文件的重复代码都不会解析： 1@import (once) "outerLess"; @import (multiple)导入方式，允许导入多个同名文件,每个文件的样式都会被解析一遍，会出现个重复的样式： 12@import (multiple) "outerLess";@import (multiple) "outerLess"; 属性避免编译属性避免编译，可以将属性添加到引号内，并在属性引号前加~ 123.not-build &#123; width: ~'calc(300px-20px)';&#125; 内置函数less内置一些辅助函数，详见官网。 示例123#fn-style&#123; color: color('#ff0');&#125;]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建的GitHubPage中支持Mathjax数学公式]]></title>
    <url>%2F2018%2F08%2F02%2FBlog%2FHexo%E6%90%AD%E5%BB%BA%E7%9A%84GitHubPage%E4%B8%AD%E6%94%AF%E6%8C%81Mathjax%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[文章概述 在hexo中，你会发现我们不能用Latex语法来书写数学公式，这对于书写学术博客来说是很大的不便，因为我们会经常碰到很多的数学公式推导，但是我们可以通过安装第三方库来解决这一问题，本篇文章介绍配置步骤。 Hexo支持Mathjax的配置步骤如下： 使用Kramed渲染引擎第一步： 使用Kramed代替Marked hexo 默认的渲染引擎是 marked，但是 marked 不支持 mathjax。 kramed 是在 marked 的基础上进行修改。我们在工程目录下执行以下命令来安装kramed: 1234//卸载原来的渲染引擎$ npm uninstall hexo-renderer-marked --save//安装kramed$ npm install hexo-renderer-kramed --save 更改your-project/node_modules/hexo-renderer-kramed/lib/renderer.js，更改内容如下： 12345// Change inline math rulefunction formatText(text) &#123; // Fit kramed's rule: $$ + \1 + $$ return text.replace(/`\$(.*?)\$`/g, '$$$$$1$$$$');&#125; 改为： 1234// Change inline math rulefunction formatText(text) &#123; return text;&#125; 使用mathjax渲染库第二步: 停止使用hexo-math,配置hexo-renderer-mathjax 安装和卸载： 1234//首先，如果你已经安装 hexo-math, 请卸载它：$ npm uninstall hexo-math --save//安装 hexo-renderer-mathjax 包：$ npm install hexo-renderer-mathjax --save 更新Mathjax的CDN链接： 打开your-project/node_modules/hexo-renderer-mathjax/mathjax.html,把底部的script链接更改为： 1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt; 更改默认转义规则第四步: 更改默认转义规则 因为 hexo 默认的转义规则会将一些字符进行转义，比如 _ 转为 , 所以我们需要对默认的规则进行修改. 打开your-project/node_modules/kramed/lib/rules/inline.js文件： 1&gt; 修改: 1escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, 更改为:1escape: /^\\([`*\[\]()# +\-.!_&gt;])/, 2&gt; 修改: 1em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 更改为:1em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 主题配置开启mathjax在主题的配置文件 _config.yml 中开启 Mathjax， 找到 mathjax 字段添加如下代码： 12mathjax: enable: true 博客中使用数学公式在博客的头部配置中开启Mathjax，添加以下内容： 123456789101112131415---title: Testing Mathjax with Hexocategory: blogtags: blogdate: 2017/05/03mathjax: true---### 前言&lt;!-- more --&gt;### 使用数学公式$\sum_&#123;i=0&#125;^N\int_&#123;a&#125;^&#123;b&#125;g(t,i)\text&#123;d&#125;t$ 效果如下： $\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说webpack4.x]]></title>
    <url>%2F2018%2F03%2F03%2Fweb%2Ftools%2F%E7%BB%86%E8%AF%B4webpack4.x%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章细说webpack4.x。 webpack 4.xwebpack打包工具 打包思想根据一个入口js文件，通过依赖关系查找需要用到的所有资源，进行打包。 作用 打包(将多个文件打包成一个js文件，减少服务器压力); 转化(通过loader将less,sass,ts文件转化成浏览器可以识别的文件); 优化(单页应用复杂度越来越高，webpack可以对项目进行优化)； webpack结构 入口：entry 出口：output 转化器：loaders 插件：plugins 开发服务器：devServer 模式：mode(分为开发模式和生产模式)； webpack所需环境 安装node; 安装yarn; 使用方式webpack简单打包 初始化config.json文件； 安装webpack支持库； 打包指定的js文件； 初始化config.json执行如下命令，默认配置一路enter即可： 1$ npm init 安装webpackwebpack4.x将webpack-cli工具分离出来，所以需要安装webpack和webpack-cli两个库，执行如下命令： current version: webpack 4.16.1 webpack-cli 3.0.8 1$ npm install --save-dev webpack webpack-cli webpack打包指定js文件 创建dist目录作为打包目录，目录内创建index.html，引用bundle.js文件，此文件就是打包后的js文件； 创建index.js，根据选择器向index.html中输入hello world; 通过webpack命令将index.js文件打包到dist目录下，在powshell下执行如下命令： 1$ node_modules/.bin/webpack src/index.js --output dist/bundle.js 将打包命令配置到package.json脚本： 12345&#123; "scripts": &#123; "build-webpack-js-file": "node_modules/.bin/webpack src/index.js --output dist/bundle.js", &#125;&#125; 这种手动打包单个js文件的方式，最终生成bundle.js和main.js文件，main.js是webpack自动生成的，这是因为没有配置webpack.config.js标准打包方法的原因，目前属于多余文件，可以不用管； webpack配置文件打包webpack.config.js 简介webpack.config.js是webpack的配置文件； 配置文件构成webpack.config.js是webpack的配置文件，结构如下： 1234567891011121314151617181920212223const path = require('path');module.exports=&#123; //入口配置: 字符串 表示入口js文件名，json key可以自定义 值即入口js文件路径; entry: &#123; enter: './src/index.js' &#125;, //出口配置 output: &#123; //path：打包输出的路径地址，必须是绝对路径 path: path.resolve(__dirname, 'dist'), //打包输出js的文件名 filename: "bundle.js" &#125;, //插件 plugins: [], //转换规则 module: &#123; rules: [], &#125;, //开发服务器 devServer: &#123;&#125;&#125;; 配置打包执行脚本config.json中配置webpack打包执行脚本（带执行进度）： 1234567891011&#123; "scripts": &#123; //普通打包，webpack4会有警告,消除警告使用mode模式打包，有优化作用； "build-webpack": "node_modules/.bin/webpack --progress", //普通打包：配置文件名称自定义 "build-webpack-alias-config-js": "webpack --config webpack.config.js", //webpack4 mode打包模式：开发模式和生产模式 "build-webpack-mode-dev": "node_modules/.bin/webpack --mode development --progress", "build-webpack-mode-prod": "node_modules/.bin/webpack --mode production --progress" &#125;&#125; 出口-入口entryentry作为webpack打包的入口，可以接受如下值： string：字符串表示的路径文件； json对象：key可以自定义，值为入口js文件路径； 数组：可以配置多入口，数组内js文件按顺序执行打包， outputoutput表示出口配置，可配置属性如下： path：打包输出的路径地址，必须是绝对路径； 12//必须使用绝对路径的形式；path: path.resolve(__dirname, &apos;./dist&apos;), filename：出口打包js结果文件名; 1234//指定确切的文件名：filename: &quot;bundle.js&quot;//动态指定输出的文件名，多用做多出口：filename: &quot;[name].bundle.js&quot; 出入口配置单入口单出口可以使用字符路径、数组、json对象配置单入口，单入口写法：12345678910//写法一：stringentry: './src/index.js',//写法二：jsonentry: &#123; enter: './src/index.js'&#125;,//写法三：arrayentry: ['./src/index.js'], 12345//单出口配置output: &#123; path: path.resolve(__dirname, './dist'), filename: "bundle.js"&#125;, 多入口单出口数组的方式配置多入口，配置方式如下：12//数组的方式配置多入口entry: ['./src/index.js','./src/index2.js'], 12345//单出口配置output: &#123; path: path.resolve(__dirname, './dist'), filename: "bundle.js"&#125;, 多入口多出口使用json对象配置入口，需要同时动态配置出口文件名； 123456789101112//多入口entry: &#123; index: './src/index.js', index2: './src/index2.js'&#125;,//多出口动态文件名output: &#123; path: path.resolve(__dirname, './dist'), //多出口打包文件名动态配置输出文件名 filename: "[name].bundle.js"&#125;, 插件开发服务器插件webpack-dev-server插件，用于配置开发服务器，在devServer配置项中配置. 下载 current version: 3.1.4 1$ yarn add webpack-dev-server -D 配置服务12345678910111213141516171819202122const webpack= require('webpack');module.exports = &#123; plugins: [ //添加支持热更新的插件，配合devServer使用 new webpack.HotModuleReplacementPlugin(), ], //开发服务器 devServer: &#123; //设置服务器访问的基本目录 contentBase: path.resolve(__dirname, 'dist'), //服务器的ip地址，localhost: host: 'localhost', //服务器端口号： port: 8888, //启动服务后自动打开页面，此时不需要在config.json脚本中使用--open： //可在打包脚本最后加' --open'启动服务后在浏览器中打开 open: true, //开启热更新，需要配置webpack自带的热更新插件 hot: true &#125;&#125; 配置执行脚本config.json中添加执行启动访问本地服务的执行脚本： 12345678&#123; &quot;scripts&quot;: &#123; //--open表示服务启动后在浏览器中打开； &quot;start-dev-server-open&quot;: &quot;node_modules/.bin/webpack-dev-server --mode development --progress --open&quot;, //devServer中如果配置open=true,则启动服务后也直接在浏览器中打开； &quot;start-dev-server&quot;: &quot;node_modules/.bin/webpack-dev-server --mode development --progress&quot; &#125;,&#125; 热更新插件webpack自带HotModuleReplacementPlugin插件来支持热更新，及时更新修改的地方； 使用1234567891011121314const webpack = require('webpack');module.exports = &#123; plugins: [ //添加支持热更新的插件，配合devServer使用 new webpack.HotModuleReplacementPlugin(), ], //开发服务器 devServer: &#123; //... //开启热更新，需要配置webpack自带的热更新插件 hot: true &#125;&#125; 静态资源文件输出插件有一些静态文件，如excel、word文档等需要原样打包输出，可以使用copy-webpack-plugin插件。 安装1$ yarn add copy-webpack-plugin -D 使用webpack.config.js中使用： 1234567891011121314//静态资源文件原样拷贝输出插件const CopyWebpackPlugin = require('copy-webpack-plugin'); module.exports=&#123; plugin:[ //静态资源输出：即将一些文档等静态资源原样打包 new CopyWebpackPlugin([&#123; //文件源 from: path.resolve(__dirname, 'src/assets'), //目标文件夹 to: './assets' &#125;]), ]&#125; ProvidePlugin(优雅使用第三方库)ProvidePlugin是webpack自带的插件，用于向全局提供一个入口，来使用第三方工具包，不同于import导入的方式使用第三方库,ProvidePlugin配置的第三方库只有在真正使用时才会被打包； 使用例如：使用jquery库的方式，在安装jquery后只需配置如下插件，即可在js文件中直接使用第三方库，而无需import: 123456789module.exports=&#123; plugins: [ //优雅的使用第三方库(推荐：用到的时候才会打包) new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;), ]&#125; purify-css(消除冗余样式) ???按此配置后，js文件中的样式都会清除 去除没用到的css需要用到purifycss-webpack插件，而这个插件又依赖于purify-css。使用glob工具包配合处理符合条件的路径文件； 注意：purify-css只能消除分离出来的css文件中的冗余代码，所以需要与分离css插件一起使用。 安装1$ npm i -D purifycss-webpack purify-css glob 使用123456789101112131415161718192021222324252627282930313233343536//这里以mini-css-extract-plugin来分离cssconst MiniCssExtractPlugin = require("mini-css-extract-plugin"); //分离css插件（官方推荐）const PurifyCSSPlugin = require('purifycss-webpack'); //消除css冗余代码的插件const glob = require('glob'); //glob用来扫描匹配文件路径const publicPath = '../';moudle.exports=&#123; plugins: [ //分离css到单独css文件的插件（官方推荐） new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', &#125;), //消除冗余css样式 new PurifyCSSPlugin(&#123; //glob.sync来进行同步读取匹配的文件路径 paths: glob.sync(path.join(__dirname, 'src/*.html')), &#125;), ], module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: publicPath, &#125; &#125;, 'css-loader', 'sass-loader', ] &#125;, ] &#125;&#125; clean-webpack-pluginclean-webpack-plugin的作用是每次编译钱清除原来的编译文件; 安装 current version: 0.1.19 1234//yarn$ yarn add clean-webpack-plugin -D//npm$ npm i clean-webpack-plugin --D 使用123456moudle.exports=&#123; plugins: [ //一般直接填入需要清除的目录即可 new CleanWebpackPlugin(['dist']), ]&#125;; uglifyjs-webpack-plugin(过时)uglifyjs-webpack-plugin用来优化js的插件，主要用在js压缩，webpack4.x版本使用’—mode production’编译打包来替代； 安装 current version: 1.2.7 1$ npm i -D uglifyjs-webpack-plugin 使用直接引入，并配置到插件即可； 123456789//js压缩插件（使用--mode production代替）const UglifyJsPlugin = require('uglifyjs-webpack-plugin'); moudle.exports=&#123; plugins: [ //压缩js(使用--mode production代替) new UglifyJsPlugin(), ]&#125;; html-webpack-pluginhtml-webpack-plugin是html文件处理插件 作用 为html文件引入外部资源，如script、link，每次编译后，会为引入的资源的地方为文件名动态添加hash，防止引用缓存的外部文件问题； 可以为入口js文件生成html，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面； 使用步骤 current version: 3.2.0 安装： 1$ npm i html-webpack-plugin -D webpack.config.js中配置： 12345678910111213141516//引入const HtmlWebpackPlugin=require('html-webpack-plugin');//插件配置module.exprots&#123; plugins: [ // new HtmlWebpackPlugin(), new HtmlWebpackPlugin(&#123; //生成的html在资源文件引用处添加序列码，防止引用缓存； hash: true, //生成html文件指定标题，需要在模板html的title标签使用&lt;%= htmlWebpackPlugin.options.title%&gt;取标题； title: 'hello webpack', //为入口js文件生成的html文件模板： template: './src/index.html' &#125;), ],&#125; 此时打包，就会根据入口js文件，动态生成html文件； 如果需要多入口生成多个html文件，参照配置chunks属性； 可配置属性总览1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const HtmlWebpackPlugin=require('html-webpack-plugin');moudle.exports &#123; entry: &#123; index: './src/index.js', index2: './src/index2.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: "[name].bundle.js" &#125;, //插件 plugins: [ // new HtmlWebpackPlugin(), new HtmlWebpackPlugin(&#123; //生成的html在资源文件引用处添加序列码，防止引用缓存； hash: true, //------------------------------- //生成html文件指定标题，需要在模板html的title标签使用&lt;%= htmlWebpackPlugin.options.title%&gt;取标题； // title: 'hello webpack', //------------------------------- //为入口js文件生成的html文件模板： template: './src/index.html', //------------------------------- //指定根据入口js生成html的文件名 // filename: 'app.html', //------------------------------- //inject用于配置打包的js引入的位置，即script标签的位置，默认body底部； //true 默认值，script标签位于html文件的 body 底部; //body script标签位于html文件的 body 底部; //head script标签位于html文件的 head中; //false 不插入生成的js文件，这个几乎不会用到的; // inject: 'head', //------------------------------- //favicon: 为网页添加标签logo // favicon: './src/resources/logo.jpg', //------------------------------- //html压缩配置 // minify:&#123; // //移除属性的引号 // removeAttributeQuotes: true, // //移除空白符 // collapseWhitespace: true // &#125; //------------------------------- //配置哪些js文件打包后需要被引用； //chunks:['index'] &#125;), ],&#125; template为入口js文件生成的html文件模板： 1template: &apos;./src/index.html&apos; filename打包js入口文件，生成的html文件的名称； 1filename: &apos;app.html&apos;, title生成html文件指定标题，需要在模板html的title标签使用&lt;%= htmlWebpackPlugin.options.title%&gt;取标题； 1title: &apos;hello webpack&apos;, hash设置为true,生成的html在资源文件引用处添加序列码，防止引用缓存； 1hash: true, injectinject用来标识script标签应该放在html的哪里，有四个值：true body head false; true 默认值，script标签位于html文件的 body 底部; body script标签位于html文件的 body 底部; head script标签位于html文件的 head中; false 不插入生成的js文件，这个几乎不会用到的; favicon给你生成的html文件添加标签栏图标 ,值是一个路径： 1favicon: &apos;./src/resources/logo.jpg&apos; cache默认是true的，表示内容变化的时候才生成一个新的文件。 chunks当使用json对象配置多入口时，chunks接受一个数组，数组内是入口的key，表示html模板需要引用的js入口文件,不配置时默认是全部引用; 案例：根据多入口生成多个html文件。 123456789101112131415161718entry: &#123; index: path.resolve(__dirname, './src/index.js'), devor: path.resolve(__dirname, './src/devor.js'), main: path.resolve(__dirname, './src/main.js')&#125;plugins: [ new httpWebpackPlugin(&#123; filename: 'index.html', template: './src/index.html', chunks: ['index','main'] &#125;), new httpWebpackPlugin(&#123; filename: 'app.html', template: './src/index.html', chunks: ['devor','main'] &#125;)] minifyhtml压缩配置，详细请参考官方文档 123456minify:&#123; //移除属性的引号 removeAttributeQuotes: true, //移除空白符 collapseWhitespace: true&#125; loaderwebpack通过在模块中配置loader来处理各种类型的文件； babel-loaderbabel-loader用来对js进行转码成es5 安装12//babel转码工具包：$ npm install --save-dev babel-loader babel-core babel-preset-env 配置babel配置文件[推荐].babelrc作为babel的配置文件，简单配置如下： 1234&#123; //预设转码规则数组，按顺序从后到前查找对应api进行转码； &quot;presets&quot;: [&quot;env&quot;]&#125; 配置loader123456789101112131415161718192021222324module.exports=&#123; module: &#123; //转换规则 rules: [ //处理js文件 &#123; test: /\.(js)$/, //排除node_modules里的js文件 exclude: /(node_modules)/, use: ['babel-loader'] &#125;, //可以直接在webpack.config.js文件内部配置babel //&#123; // test: /\.(js|jsx)$/, // exclude: /(node_modules)/, // use: &#123; // loader: 'babel-loader', // options: &#123; // presets: ['env', 'react'] // &#125; // &#125; //&#125;, ]&#125; react转码安装react支持包1$ npm install --save react react-dom babel-preset-react babel配置支持react转码.babelrc作为babel的配置文件，简单配置如下： 1234&#123; //预设转码规则数组，按顺序从后到前查找对应api进行转码； &quot;presets&quot;: [&quot;env&quot;,&quot;react&quot;]&#125; 配置loader12345678910111213module.exports=&#123; module: &#123; //转换规则 rules: [ //处理js文件 &#123; test: /\.(js|jsx)$/, //排除node_modules里的js文件 exclude: /(node_modules)/, use: ['babel-loader'] &#125;, ]&#125; url-loader处理外部资源的引用，如图片，url-loader依赖于file-loader。 安装 current version: file-loader 1.1.11 url-loader 1.0.1 1$ npm install --save-dev url-loader file-loader 使用1&gt; webpack.config.js配置文件中配置loader： 123456789101112131415161718192021222324moudle.exports=&#123; module: &#123; rules: [ //处理图片资源 &#123; test: /\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; //打包到资源文件的文件大小阀值,低于阀值图片文件以base64引用，不会分离出来 limit: 8192, //打包后存放（输出）的目录 outputPath: 'resources/images', //打包后图片文件的存放目录+文件全称 // name: 'resource/[name].[ext]' name: '[name].[ext]' &#125; &#125; ] &#125; ] &#125;&#125; 2&gt; js文件中使用文件资源： 12//直接引用图片资源import img from './image.png' 12345//css中引用body&#123; background: url("./resources/bear.jpg") no-repeat; color: #fff;&#125; css-loader处理css样式，依赖于style-loader 安装 current version: css-loader 1.0.0 style-loader 0.21.0 1$ npm install --save-dev css-loader style-loader 直接配置css-loader1&gt; webpack.config.js配置文件中配置loader： 123456789101112131415161718192021moudle.exports=&#123; module: &#123; rules: [ &#123; //匹配规则，即匹配哪些文件； test: /\.css$/, //直接使用css-loader，css样式会打包在js文件里 //方式一：直接用use关键字，值为loader数组，数组内的loader按照依赖顺序进行加载，style-loader必须放在最前面； use: ['style-loader', 'css-loader'], //方式二：直接用loader关键字，值为loader数组，style-loader必须放在最前面； // loader: ['style-loader', 'css-loader'], //方式三：数组接收json对象，可对loader进行单独配置； // use: [ // &#123;loader:'style-loader'&#125;, // &#123;loader:'css-loader'&#125;, // &#123;loader:'sass-loader'&#125; // ] &#125;, ] &#125;&#125; 2&gt; js文件中引用css样式： 1import './index.css'; 分离css分离css，一般都会讲css样式进行分离，分离为独立的css文件，做法有两种，使用extract-text-webpack-plugin或mini-css-webpack-plugin（推荐）. extract-text-webpack-plugin(过时) current version: 4.0.0-beta.0 1&gt; 安装： 12//webpack4，需要next版本$ npm install --save-dev extract-text-webpack-plugin@next 2&gt; 使用： 12345678910111213141516171819202122232425const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin'); //分离css插件const publicPath = '../';moudle.exports=&#123; plugins: [ //分离css到单独css文件的插件 new ExtractTextWebpackPlugin('css/[name].css'), ], module: &#123; rules: [ &#123; test: /\.css$/, //配合插件分离出css到单独的css文件 use: ExtractTextWebpackPlugin.extract(&#123; //依赖回调 fallback: "style-loader", //使用的loader use: "css-loader", //css引用外部资源的根目录 publicPath: publicPath, &#125;), &#125;, ] &#125;&#125; mini-css-webpack-plugin1&gt; 安装： current version: 0.4.1 1$ npm install --save-dev mini-css-extract-plugin 2&gt; 使用： 12345678910111213141516171819202122232425262728const MiniCssExtractPlugin = require("mini-css-extract-plugin"); //分离css插件（官方推荐）const publicPath = '../';moudle.exports=&#123; plugins: [ //分离css到单独css文件的插件（官方推荐） new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', &#125;) ], module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: publicPath, &#125; &#125;, 'css-loader' ] &#125;, ] &#125;&#125; sass-loadersass-loader用来将.sass或.scss文件转成.css文件的，同css-loader使用方式类似。 安装sass-loader依赖于node-sass,需要同时安装，node-sass需要翻墙； current version: ndoe-sass 4.9.2 sass-loader 7.0.3 1$ npm install sass-loader node-sass webpack --save-dev 直接使用12345678910moudle.exports=&#123; module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: ['style-loader','css-loader','sass-loader'], &#125;, ] &#125;&#125; 分离cssextract-text-webpack-plugin12345678910111213141516171819202122232425const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin'); //分离css插件const publicPath = '../';moudle.exports=&#123; plugins: [ //分离css到单独css文件的插件 new ExtractTextWebpackPlugin('css/[name].css'), ], module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, //配合插件分离出css到单独的css文件 use: ExtractTextWebpackPlugin.extract(&#123; //依赖回调 fallback: "style-loader", //使用的loader use: ['css-loader','sass-loader'], //css引用外部资源的根目录 publicPath: publicPath, &#125;), &#125;, ] &#125;&#125; mini-css-webpack-plugin1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require("mini-css-extract-plugin"); //分离css插件（官方推荐）const publicPath = '../';moudle.exports=&#123; plugins: [ //分离css到单独css文件的插件（官方推荐） new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', &#125;) ], module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: publicPath, &#125; &#125;, 'css-loader', 'sass-loader' ] &#125;, ] &#125;&#125; postcss-loader(兼容性前缀)css3新增了一些属性，但是针对不同内核的浏览器，需要加不同的前缀才会有效， 如webkit等内核的浏览器，需要加-webkit-才会起作用，这里主要使用postcss-loader工具包里的autoprefixer插件，可以在打包时自动添加相关属性的前缀； 安装 current version: postcss-loader 2.1.6 autoprefixer 9.0.1 1$ npm i -D postcss-loader autoprefixer 使用1&gt; 新建postcss配置文件: postcss.config.js: 12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125;; 2&gt; webpack.config.js中配置postcss-loader: 123456789101112131415161718192021222324252627282930//这里以mini-css-extract-plugin来分离cssconst MiniCssExtractPlugin = require("mini-css-extract-plugin"); //分离css插件（官方推荐）const publicPath = '../';moudle.exports=&#123; plugins: [ //分离css到单独css文件的插件（官方推荐） new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', &#125;) ], module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: publicPath, &#125; &#125;, 'css-loader', 'sass-loader', 'postcss-loader' ] &#125;, ] &#125;&#125; optimization(优化配置)optimization配置项用于在webpack配置文件中优化webpack配置，同时它替代了CommonsChunkPlugin(提取公共模块)插件的功能。 配置示例(带注释)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859module.exports=&#123; //webpack4优化配置 optimization: &#123; //[runtimeChunk] //可以配置成true，single或者对象，用自动计算当前构建的一些基础chunk信息，类似之前版本中的manifest信息获取方式。 //用来提取entry chunk中的runtime部分函数，形成一个单独的文件，这部分文件不经常变换，方便做缓存。 runtimeChunk: &#123; //运行时模块名 name: 'manifest' &#125;, //分离第三方库、公共代码，打包到单独文件 splitChunks: &#123; //chunks表示操作代码块的范围，有三个可选值：initial(初始块)、async(按需加载块)、all(全部块)，默认为all; chunks: "async", //压缩前的最小模块大小，默认为0(小于30kb的模块不值得再单独发送一次请求); minSize: 30000, //最小被引用次数，默认为1； minChunks: 1, //最大的按需(异步)加载次数，默认为1； maxAsyncRequests: 5, //最大的初始化加载次数，默认为1； maxInitialRequests: 3, //拆分出来块的名字(Chunk Names)，默认由块名和hash值自动生成； name: true, //打包的分组(分类打包) cacheGroups: &#123; //默认分组设置：可以设为false,则不使用默认缓存（default:false） default: &#123; minChunks: 2, //缓存的优先级 priority: -20, //表示可以使用已经存在的块，即如果满足条件的块已经存在就使用已有的，不再创建一个新的块; reuseExistingChunk: true, &#125;, //打包node_modules工具包内的代码 vendor: &#123; //正则匹配目录 test: /[\\/]node_modules[\\/]/, //打包后的js包名称 name: 'vendor', chunks: 'initial', reuseExistingChunk: false, priority: -10, //强制执行 // enforce: true &#125;, //打包公共的文件 commons: &#123; //匹配需要打包的目录：src/commons目录下的js文件： test: /[\\/]src[\\/]commons[\\/]/, name: "commons", chunks: "all", minSize: 0, priority: 1 &#125;, &#125; &#125; &#125;&#125; eslint代码检查配置ESLint是js中目前比较流行的插件化的静态代码检测工具. 非必须 安装12345678910$ yarn add eslint $ yarn add eslint-loader$ yarn add babel-eslint$ yarn add eslint-config-airbnb//eslint报错格式$ yarn add eslint-friendly-formatter//依赖的插件$ yarn add eslint-plugin-import$ yarn add eslint-plugin-jsx-a11y$ yarn add eslint-plugin-react 配置loaderwebpack.config.js文件配置支持的loader: 1234567891011121314151617181920module.exports =&#123; //转换规则 rules: [ //eslint:js代码检测工具 &#123; test: /\.(js|jsx)$/, loader: "eslint-loader", //编译前检查 enforce: "pre", //指定检查的目录 include: [path.resolve(__dirname, './src')], exclude: /node_modules/, //这里的配置项参数将会被传递到eslint的CLIEngine options: &#123; //指定错误报告的格式规范 formatter: require('eslint-friendly-formatter') &#125; &#125;, ]&#125; 添加eslint配置文件loader中配置了eslint后，还需要配置.eslintrc.js为eslint的配置文件，程序默认会加载它。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859module.exports = &#123; //限定配置文件的使用范围：作用根目录 root: true, //指定eslint的解析器 parser: 'babel-eslint', //通过babel-eslint来检测ES6代码 //设置解析器选项 parserOptions: &#123; //按照模块的方式解析 sourceType: 'module' &#125;, //引用第三方的插件 plugins: [ "react" ], //声明在代码中的自定义全局变量 // globals:&#123;&#125;, //指定代码运行的宿主环境 env: &#123; //表示可以使用浏览器的方法 browser: true, node: true, jquery: true, &#125;, //指定eslint规范：此处使用第三方airbnb规则； ！！！ //extends: 'airbnb', //启用额外的规则或覆盖默认的规则 /* 语法格式：key: array * array的第一个值是错误级别,如下： * &gt; "off" or 0 - 关闭规则 * &gt; "warn" or 1 - 将规则视为一个警告（不会影响退出码） * &gt; "error" or 2 - 将规则视为一个错误 (退出码为1） */ rules: &#123; //强制使用一致的缩进 // "indent": ["error", 2], //强制使用一致的反勾号、双引号或单引号 // "quotes": ["error", "double"], //要求或禁止使用分号代替 // "semi": ["error", "always"], //禁用console // "no-console": "error", //[es6规则] //要求箭头函数的参数使用圆括号 // "arrow-parens": 0 //强制使用Windows风格换行符; "linebreak-style": ["error", "windows"], //在花括号中允许空格??? import&#123;&#125;还需要有空格 // "object-curly-spacing": ["error", "always", &#123;"arraysInObjects": false, "objectsInObjects": false&#125;] &#125;&#125;; 执行检查webpack按照上述配置好了eslint-loader，基本可以正常编译，如果打开了extends规则，就需要按照提示更改错误。 调试webpack4.xwebpack4.x devServer的—mode production启动模式，可以直接在浏览器直观看到与项目编译前目录结构一样的源码，方便我们进行调试。 1234//config.json文件的执行脚本配置如下："scripts": &#123; "start-dev-server": "node_modules/.bin/webpack-dev-server --mode development"&#125; webpack3.xwebpack3.x需要在webpack.config.js文件中配置devtool为source-map即可在浏览器中查看与项目编译前目录结构一项的源码。 注意：source-map开启调试时尽量关闭压缩，上线时要关闭source-map。 123module.exports = &#123; devtool: "source-map",&#125;]]></content>
      <categories>
        <category>大前端</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-banner项目的使用]]></title>
    <url>%2F2017%2F10%2F11%2FAndroid%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2FBanner%2Fandroid-banner%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录开源的Banner库：android-banner 的使用。android-banner实现了一般banner循环轮播的效果，一页只显示一张图片，也可以一页显示一张图和相邻两个图片的一部分，此项目仅仅是banner展示图片，没有多余的诸如指示器、页面切换动画等效果代码，详见效果图和案例代码。 概述注：本banner仅仅是banner，不包含指示器、变换动画、图片加载器等多余的代码，作者认为这些部件完全应该分离出来，详细用法见案例app。 项目地址 overview usageGradle123dependencies &#123; compile &apos;com.liusong.android:banner:1.0.0&apos;&#125; ProGuard1-keep class com.lw.banner.** &#123;*;&#125; Layout1234&lt;com.lw.banner.Banner android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="160dp" /&gt; xml中可设置的一些属性 属性名称 属性值类型 作用 delayTime integer 循环轮播时间间隔 scrollDuration integer banner滚动过程持续时间 isAutoPlay boolean 是否自动轮播 scrollable boolean banner是否可以手动滑动 pageMargin dimension banner页面之间的间隔 pageLimit integer banner预加载页面数 leftPageWidth dimension 当前页面左侧页面可以显示的宽度 rightPageWidth dimension 当前页面右侧页面可以显示的宽度 emptyImage reference banner为空时的占位图片资源引用 案例：xml中设置循环轮播时间间隔12345&lt;com.lw.banner.Banner android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="160dp" app:delayTime="1000"/&gt; Code1234List&lt;String&gt; urls=getUrls();banner.setImages(urls) .setImageLoader(new GlideImageLoader()) .init(); 代码中可以配置的一些属性：12345678910111213141516171819202122232425banner.setImages(Arrays.asList(imgRes)) //设置图片资源 //.setImageLoader(new FrescoImageLoader()) // 设置fresco图片加载器 .setImageLoader(new GlideImageLoader()) //设置Glide图片加载器 //.setPageTransformer(true, new PageScaleYTransformer()) //页面切换动画 .setOnItemClickListener(new Banner.OnItemClickListener() &#123; @Override public void callBack(int position) &#123; Toast.makeText(MainActivity.this, "position=" + position, Toast.LENGTH_SHORT).show(); &#125; &#125;) //设置banner点击监听 //.setScrollable(false) // 禁用banner手动滑动 //.setDelayTime(1000) // 循环轮播时间间隔 //.setPageLimit(4) // 设置预加载页面数量 //.setPageMargin(20) // banner页面之间的间隔 //.setRightPageWidth(50) // 当前页面右侧页面可以显示的宽度 //.setLeftPageWidth(50) // 当前页面左侧页面可以显示的宽度 //.setEmptyImageRes(R.mipmap.no_banner) // banner为空时占位图 //.setEmptyImageScaleType(ImageView.ScaleType.FIT_CENTER) // 占位图的缩放类型,默认FIT_XY .isAutoPlay(true) // 设置自动循环轮播 .init();// 拿到占位图ImageView对象ImageView emptyView = mBinding.banner2.getEmptyView();emptyView.setImageResource(R.mipmap.mn_01);// 拿到BannerViewPager对象BannerViewPager bannerViewPager = mBinding.banner2.getBannerViewPager(); 生命周期中控制循环轮播的周期123456789101112@Overrideprotected void onStart() &#123; super.onStart(); //开始轮播 banner.startAutoPlay();&#125;@Overrideprotected void onStop() &#123; super.onStop(); //结束轮播 banner.stopAutoPlay();&#125; 参考https://github.com/youth5201314/banner]]></content>
      <categories>
        <category>Android</category>
        <category>开源项目</category>
        <category>banner</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源项目</tag>
        <tag>banner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux笔记]]></title>
    <url>%2F2017%2F10%2F10%2Fweb%2FReact%2FRedux%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录Redux的笔记。 reduxRedux的设计思想 Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面。 基本API操作或View交互会产生一个Action,Action运送数据到Store,Store接受Action后产生一个state,View改变。 Store(数据存储)概念Store就是保存数据的地方,Store对象包含所有数据，整个应用只能有一个Store; createStore创建Store Redux提供createStore这个函数，用来生成Store，createStore函数接受另一个函数作为参数，返回新生成的Store对象。 12import &#123; createStore &#125; from 'redux';const store = createStore(fn); createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。 123//window.STATE_FROM_SERVER就是整个应用的状态初始值//注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。let store = createStore(todoApp, window.STATE_FROM_SERVER) createStore的实现createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的。 12345678910111213141516171819202122const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; Store的三个方法 store.getState() store.dispatch() store.subscribe() 12import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); 获取状态1store.getState() store.dispatch(发Action)store.dispatch()是View发出Action的唯一方法。 发出一个Action： 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 结合Action Creator： 1store.dispatch(addTodo('Learn Redux')); 监听函数概念Store允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。1store.subscribe() 使用只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 解除监听store.subscribe方法返回一个函数，调用这个函数就可以解除监听。12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); State(数据)概念 如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。 当前时刻的State，可以通过store.getState()拿到。 1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux规定，一个State对应一个View。只要State相同，View就相同。你知道State，就知道View 是什么样，反之亦然。 Action(改变state操作)概念Action描述当前发生的事情。改变State的唯一办法，就是使用Action。它会运送数据到 Store。 要点Action是一个对象。其中的type属性是必须的，表示Action的名称。其他属性可以自由设置； 12345//Action 的名称是ADD_TODO，它携带的信息是字符串Learn Reduxconst action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; Action Creator(生成Action)View 要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。 1234567891011const ADD_TODO = '添加 TODO';//addTodo函数就是一个 Action Creator。function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); Reducer(获取State)概念Store 收到 Action 以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。 要点Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 实际应用实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 生成State纯函数reducer 不得改写参数 不能调用系统 I/O 的API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 生成不变的新State Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个View对应的State总是一个不变的对象 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; Reducer拆分Reducer函数负责生成State。由于整个应用只有一个State对象，包含所有数据，对于大型应用来说，这个State 必然十分庞大，导致Reducer函数也十分庞大。 Reducer生成State示例123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 上面代码中，三种Action分别改变State的三个属性: ADD_CHAT：chatLog属性 CHANGE_STATUS：statusMessage属性 CHANGE_USERNAME：userName属性 我们可以把Reducer函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的Reducer即可。如下： 12345678//Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性:const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 拆分合并工具Redux 提供了一个combineReducers方法，用于Reducer的拆分。只要定义各个子 Reducer函数，然后用这个方法，将它们合成一个大的 Reducer。 12345678910//combineReducers方法将三个子 Reducer 合并成一个大的函数import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 要点 State的属性名必须与子Reducer同名，如果不同名，就要采用下面的写法： 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; Redux工作流程相关概念梳理 Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。 View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。 Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。 工作流程 用户发出Action; 1store.dispatch(action); Store自动调用Reducer，并且传入两个参数：当前State和收到的Action,Reducer会返回新的State; 1let nextState = todoApp(previousState, action); Store就会调用监听函数,监听State变化； 12// 设置监听函数store.subscribe(listener); 监听函数可以通过store.getState()得到当前状态。如果使用的是React，这时可以触发重新渲染 View。 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 示例：计数器简单的计数器Counter，唯一的作用就是把参数value的值，显示在网页上，并为Counter添加递增和递减的Action： 12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); Reducer异步处理概念 Action发出以后，Reducer立即算出State，这叫做同步； Action发出以后，过一段时间再执行Reducer，这就是异步。 中间件 我们可以store.dispatch这一步添加中间件来增加其功能； 之前我们知道createStore可以接受两个参数，reducer和一个初始状态，此处介绍，他可以接受第三个参数applyMiddleware，来应用中间件，初始状态参数可以省略。 applyMiddlewareapplyMiddleware作用是将所有中间件组成一个数组，依次执行（log类型的中间件要放在数组最后）； 异步操作的基本思路同步操作只要发出一种Action即可，异步操作的差别是它要发出三种Action： 操作发起时的 Action； 操作成功时的 Action； 操作失败时的 Action； 【注意】此处三种action，但是实际操作中值会发起两次Action对象，即：操作时发起Action,操作结束发起一次Action. redux-thunk中间件store.dispatch方法正常情况下，参数只能是对象，不能是函数.这里我们借助中间件redux-thunk来改造store.dispatch，让他可以接收函数作为参数，这样我们可以利用接收的函数作为参数，在操作结束后再发起Action,从而实现异步的目的。 改造写法使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。123456789import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); redux-promise中间件 既然Action Creator可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是用redux-promise中间件让Action Creator返回一个Promise对象。 redux-promise中间件使得store.dispatch方法可以接受Promise对象作为参数. 引入中间件12345678import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import promiseMiddleware from &apos;redux-promise&apos;;import reducer from &apos;./reducers&apos;;const store = createStore( reducer, applyMiddleware(promiseMiddleware)); 生成Action的两种方式使用redux-promise中间件时，Action Creator有两种写法：方法1. 返回的Action是一个Promise对象： 123456789const fetchPosts = (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; &#123; type: 'FETCH_POSTS', payload: response.json() &#125;);&#125;); 方法2. 返回的Action的属性是一个Promise对象： 123456789101112131415//这需要从redux-actions模块引入createAction方法import &#123; createAction &#125; from 'redux-actions';class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props // 发出同步 Action dispatch(requestPosts(selectedPost)); // 发出异步 Action dispatch(createAction( 'FETCH_POSTS', fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) )); &#125; 【注解】dispatch方法发出的是异步Action，只有等到操作结束，这个 Action 才会实际发出。注意，createAction的第二个参数必须是一个 Promise 对象。 react-reduxRedux的作者封装的一个React专用的Redux库React-Redux,来进行state管理； 安装1yarn add react-redux -S 对组件分类React-Redux将所有组件分成两大类： UI 组件（presentational component）,UI组件负责UI的呈现，容器组件负责管理数据和逻辑; 容器组件（container component）,负责管理数据和业务逻辑。 UI组件 因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。 UI组件有以下几个特征： 只负责UI的呈现，不带有任何业务逻辑； 没有状态（即不使用this.state这个变量）； 所有数据都由参数（this.props）提供； 不使用任何Redux的API； 容器组件 负责管理数据和业务逻辑，不负责UI的呈现； 带有内部状态； 使用Redux的API； connect()React-Redux 提供connect方法，用于从UI组件生成容器组件。connect的意思，就是将这两种组件连起来； connect的用法：可接收两个方法参数，分别负责输入输出逻辑的方法，根据UI组件生成容器组件； 123456789import &#123; connect &#125; from 'react-redux'//VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件;const VisibleTodoList = connect( //负责输入逻辑：即将state映射到UI组件的参数（props）； mapStateToProps, //负责输出逻辑: 即将用户对UI组件的操作映射成Action。 mapDispatchToProps)(TodoList) //TodoList是UI组件 mapStateToProps() mapStateToProps是一个函数，作为connect函数的第一个参数,作用是建立一个从UI组件外部的state对象输入到UI组件的props对象的映射关系。 【函数结构】 mapStateToProps的第一个参数总是state对象； 可以使用第二个参数，代表容器组件的props对象，使用组件的props作为参数后，如果容器组件的参数发生变化，也会引发UI组件重新渲染。 【工作逻辑】 mapStateToProps函数会订阅Store，每当state更新的时候，就会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。 connect方法可以省略mapStateToProps参数，那样的话，UI组件就不会订阅Store，就是说 Store 的更新不会引起UI组件的更新。 【示例代码】： 注释：mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表UI组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出todos的值。1234567891011121314151617const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case &apos;SHOW_ALL&apos;: return todos case &apos;SHOW_COMPLETED&apos;: return todos.filter(t =&gt; t.completed) case &apos;SHOW_ACTIVE&apos;: return todos.filter(t =&gt; !t.completed) default: throw new Error(&apos;Unknown filter: &apos; + filter) &#125;&#125; mapDispatchToProps() mapDispatchToProps是connect函数的第二个参数，用来建立UI组件的参数到store.dispatch方法的映射。它定义了哪些用户的操作应该当作Action，传给Store，它可以是一个函数，也可以是一个对象。 【mapDispatchToProps是一个函数】 mapDispatchToProps是一个函数会得到dispatch和ownProps（UI组件的props对象）两个参数，返回一个对象，该对象的每个键值对都是一个映射，定义了UI 组件的参数怎样发出Action。 12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 【mapDispatchToProps是一个对象】如果mapDispatchToProps是一个对象，它的每个键名也是对应UI组件的同名参数，键值应该是一个函数，会被当作Action creator，返回的Action会由Redux自动发出。 123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; Provider组件React-Redux提供Provider组件，可以让容器组件拿到state: 根组件使用Provider: 1234567891011121314import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( //Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。 &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 子组件就可以从context拿到store： 12345678910111213141516171819class VisibleTodoList extends Component &#123; componentDidMount() &#123; const &#123; store &#125; = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); &#125; render() &#123; const props = this.props; const &#123; store &#125; = this.context; const state = store.getState(); // ... &#125;&#125;VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object&#125; react-redux工作流程示例以下用react-redux来实现一个计数器示例的步骤： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import ReactDOM from 'react-dom'import &#123; createStore &#125; from 'redux'import &#123; Provider, connect &#125; from 'react-redux'//【1. 定义一个计数器UI组件】class Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Counter.propTypes = &#123; value: PropTypes.number.isRequired, onIncreaseClick: PropTypes.func.isRequired&#125;//【2. 定义输入内容到UI组件，和UI组件输出Action】// Map Redux state to component propsfunction mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;//Action Creatorconst increaseAction = &#123; type: 'increase' &#125;// Map Redux actions to component propsfunction mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;//【3. 使用connect方法生成容器组件】// Connected Componentconst App = connect( mapStateToProps, mapDispatchToProps)(Counter)//【4. Reducer接收action生成新state】// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125;//【5. 生成store对象】const store = createStore(counter)//【6. 根组件包裹Provider】ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) provider结合react-router使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。1234567const Root = (&#123; store &#125;) =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/Router&gt; &lt;/Provider&gt;);]]></content>
      <categories>
        <category>大前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router 4.x笔记]]></title>
    <url>%2F2017%2F10%2F10%2Fweb%2FReact%2Freact-router4.x%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录react-router 4.x的笔记。 参考资料 Github仓库：https://github.com/ReactTraining/react-router 官方文档：https://reacttraining.com/react-router/web/guides/quick-start 官方文档翻译：http://reacttraining.cn/web/api/BrowserRouter 简介 React Router是React官方推荐的标准路由库，用来管理一个多视图的React应用中那些来回切换的页面URL。 React Router V4基于Lerna管理多个Repository。此代码库包括： 包名 描述 react-router React Router 核心组件 react-router-dom 用于 DOM 绑定的 React Router react-router-native 用于React Native的 React Router react-router-redux React Router 和 Redux 的集成 react-router-config 静态路由配置帮助助手 React Router V4遵循了Reac的理念：万物皆组件。因此 Route、Link、Switch等都是一个普通的组件。 1组件里也可以添加router，路由放在组件中，需要的时候再去定义； React Router V4的特点是：声明式、可组合。 插件安装react-router-domreact-router-dom提供了BrowserRouter,Route,Link等api,我们可以通过dom的事件控制路由，对比react-router多出了 DOM类组件。如果搭配redux，你还需要使用react-router-redux。 安装1$ npm install react-router-dom -S 引入在react应用中，引入相关路由组件即可使用： 1import &#123;HashRouter as Router, Link, Route, Switch&#125; from &apos;react-router-dom&apos;; 内置组件简介常用的组件有： Router：路由； Route：路由规则； Switch：包裹Route,避免多次匹配； Link：与Route平级，相当于a标签，用来设置与Route的路径对应的地址，导航作用； NavLink：同Link,新增了一些状态控制api; Redirect: url重定向； Router 在 React Router 4中，你可以将各种组件及标签放进 组件中，他的角色也更像是Redux中的 。不同的是是用来保持与store的更新，而是用来保持与location的同步。示例如下： 使用示例123456789101112&lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/about"&gt;关于&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/topics"&gt;主题列表&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path="/" component=&#123;Home&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;Route path="/topics" component=&#123;Topics&#125;/&gt; &lt;/div&gt;&lt;/Router&gt; 概述 Router组件下只允许存在一个子元素； Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由： 1234&lt;BrowserRouter&gt;：使用HTML5提供的history API（pushState，replaceState和popstate事件）来保持UI和URL的同步；&lt;HashRouter&gt;：使用URL的hash (例如：window.location.hash) 来保持UI和URL的同步,兼容老的浏览器，最终的url中会有明显的#(http://example.com/#/about)；&lt;MemoryRouter&gt;：能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写)；&lt;StaticRouter&gt;：从不会改变地址； 注意：BrowserRouter 如果使用BrowserRouter，path配置时，最好不要使用双斜线，webpack服务二次刷新页面会报错‘cannot get …’,需要配置devServer添加如下配置： 12345678devServer: &#123; //... historyApiFallback: &#123; // Paths with dots should still use the history fallback. // See https://github.com/facebookincubator/create-react-app/issues/387. disableDotRule: true, &#125;,&#125; Route概述Route控制了路径对应显示的组件或要渲染的内容，path属性与Link的to属性进行匹配。 属性path path(string)：路由的匹配路径； 12//【示例】&lt;Route path="/users/:id" component=&#123;User&#125;/&gt; path通配符传参： 【常用通配符】(为了区分，中括号内的是通配符) 1234567&gt; [:paramName]：参数通配符；1&gt; paramName匹配URL的一个部分，直到遇到下一个/、?、#为止;2&gt; 这个路径参数在组件中，可以通过this.props.params.paramName取出;3&gt; 目标组件页面可以通过render返回的函数中添加route（props）参数来获取参数值：&#123;route.match.params.id&#125;。&gt; [()]：()表示URL的这个部分是可选的。&gt; [*]：*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。&gt; [**]：** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。 【通配符示例】 1234567891011121314151617181920212223//【传参通配符】&lt;Route path=&quot;/hello/:name&quot;&gt;// 匹配 /hello/michael// 匹配 /hello/ryan//【其他通配符】&lt;Route path=&quot;/hello(/:name)&quot;&gt;// 匹配 /hello// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=&quot;/files/*.*&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/hello.html&lt;Route path=&quot;/files/*&quot;&gt;// 匹配 /files/ // 匹配 /files/a// 匹配 /files/a/b&lt;Route path=&quot;/**/*.jpg&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/path/to/file.jpg exact exact(bool): 为true时，要求路径与location.pathname（即path）必须完全匹配; 测试路径 path exact 是否匹配 /one /one/two true 否 /one /one/two false 是 12//【示例】&lt;Route exact path="/one" component=&#123;About&#125;/&gt; strict strict(bool): true的时候，匹配url时，结尾斜线也要匹配； 测试路径 path strict 是否匹配 /one/ /one true 否 /one/ /one/ true 是 /one/ /one/two true 是 12//【示例】&lt;Route strict path="/one/" component=&#123;About&#125;/&gt; component component：表示path对应显示的组件； 12【注意】&lt;Route component&gt;的优先级要比&lt;Route render&gt;高，所以不要在同一个&lt;Route&gt;中同时使用这两个属性。 1234567//【示例】//路由：&lt;Route path="/user/:username" component=&#123;User&#125;/&gt;//渲染的组件：利用match获取参数；const User = (&#123; match &#125;) =&gt; &#123; return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125; render render(func)：以函数方式返回渲染的内容，可替代要显示的component； 12//【示例】&lt;Route path="/home" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt; children children(func): 与render属性的工作方式基本一样，不管地址匹配与否都会被调用; Link用于控制路由跳转的； API属性 to(string|object)：要跳转的路径或地址； replace(bool)：为true时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为false时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为false； 示例代码12345678910111213141516import &#123; Link &#125; from 'react-router-dom'//to: string&lt;Link to="/a/123"&gt;xxx&lt;/Link&gt;&lt;Link to="/about"&gt;关于&lt;/Link&gt;//to: object&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt;//replace &lt;Link to="/courses" replace /&gt; NavLink是的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数; API属性12345&gt; activeClassName(string)：设置选中样式，默认值为 active；&gt; activeStyle(object)：当元素被选中时, 为此元素添加样式；&gt; exact(bool)：为true 时, 只有当地址完全匹配 class 和 style 才会应用；&gt; strict(bool)：为true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线；&gt; isActive(func)：判断链接是否激活的额外逻辑的功能； activeClassName activeClassName(string)：设置选中样式类选择器，默认值为active； 1234&lt;NavLink to="/xxx" activeClassName="selected"&gt;显示xxx&lt;/NavLink&gt; activeStyle activeStyle(object)：当元素被选中时, 为此元素直接添加样式； 1234567&lt;NavLink to="/faq" activeStyle=&#123;&#123; fontWeight: 'bold', color: 'red' &#125;&#125;&gt;FAQs&lt;/NavLink&gt; exact exact(bool)：为true 时, 只有当地址完全匹配 class 和 style 才会应用； 1234&lt;NavLink exact to="/profile"&gt;Profile&lt;/NavLink&gt; strict strict(bool)：为true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线； 1234&lt;NavLink strict to="/events/"&gt;Events&lt;/NavLink&gt; isActive isActive(func)：判断链接是否激活的额外逻辑的功能； 12345678910111213// 当event id为奇数的时候，激活链接const oddEvent = (match, location) =&gt; &#123; if (!match) &#123; return false &#125; const eventID = parseInt(match.params.eventID) return !isNaN(eventID) &amp;&amp; eventID % 2 === 1&#125;&lt;NavLink to="/events/123" isActive=&#123;oddEvent&#125;&gt;Event 123&lt;/NavLink&gt; SwitchSwitch常常会用来包裹多个Route，根据path匹配一个Route，它里面不能放其他元素，仅用来匹配显示一个路由，避免路由的重复匹配问题。 Redirect渲染将导航到新位置。新位置将覆盖历史堆栈中的当前位置，如服务器端重定向（HTTP 3xx）。 属性to to(string|object): 要重定向到的网址或位置; 123456&lt;Redirect to="/somewhere/else"/&gt;&lt;Redirect to=&#123;&#123; pathname: '/login', search: '?utm=your+face', state: &#123; referrer: currentLocation &#125;&#125;&#125;/&gt; push push(bool)：当为true时，重定向会将新条目推入历史记录，而不是替换当前条目。 1&lt;Redirect push to="/somewhere/else"/&gt; from from(string)：匹配需要要重定向的路径名。这只能用于在内部呈现时匹配位置。 1234&lt;Switch&gt; &lt;Redirect from='/old-path' to='/new-path'/&gt; &lt;Route path='/new-path' component=&#123;Place&#125;/&gt;&lt;/Switch&gt; 示例代码根据登录或未登录渲染不同改的内容：12345import &#123; Route, Redirect &#125; from 'react-router'&lt;Route exact path="/" render=&#123;() =&gt; ( loggedIn ? (&lt;Redirect to="/dashboard"/&gt;) : (&lt;PublicHomePage/&gt;))&#125;/&gt; Route内置对象react router提供了几个重要的内置对象，用来获取页面路由的信息，如下： location； history； match； matchmatch(这里称匹配对象)包含与Route的path匹配的信息； 获取方式componentRoute component中使用this.props.match获取match, 或者使用箭头函数传入一个match:12345&lt;Route path="/user/:username" component=&#123;User&#125;/&gt;const User = (&#123; match &#125;) =&gt; &#123; return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125; renderRoute render中使用({ match }) =&gt; ()方式获取： 12345&lt;Route path=&#123;`$&#123;this.props.match.path&#125;/:id`&#125; render=&#123;(&#123;match&#125;) =&gt; &#123; return (&lt;div&gt;当前组件是带参数的A,参数是：&#123;match.params.id&#125;&lt;/div&gt;); &#125;&#125;/&gt; childrenRoute children中用({ match }) =&gt; ()方式获取： 1&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; (//...)&#125;/&gt; 属性match对象包含以下属性： params(object)：根据path路径(url)解析相关参数信息； isExact(bool): 如果匹配整个URL，则为true（不包括尾部斜杠字符）; path(string)：用于匹配的路径模式。 用于构建嵌套的Route； url(string): URL的匹配部分。 用于构建嵌套的Link; location页面的位置信息； 简介location代表应用程序现在的位置，您希望它去的位置，甚至是它的位置。 它看起来像这样： 123456789&#123; key: 'ac3df4', // not with HashHistory! pathname: '/somewhere' search: '?some=search-string', hash: '#howdy', state: &#123; [userDefined]: true &#125;&#125; 获取方式与match类似 history浏览器的路由历史，获取方式同match类似； 属性方法history对象通常具有以下属性和方法： length - (number) 历史堆栈中的条目数； action - (string) 当前操作（PUSH，REPLACE或POP）； location - (object) 目前的location对象。 push(path, [state]) - (function) 将新条目推送到历史堆栈。 replace(path, [state]) - (function) 替换历史堆栈上的当前条目。 go(n) - (function) 通过n个条目移动历史堆栈中的指针； goBack() - (function) 回退一条历史； goForward() - (function) 前进一条历史； block(prompt) - (function) 组织导航； 案例简单传参路由显示带参数组件A和不带参数组件B： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123;HashRouter as Router, Link, Route, Switch&#125; from 'react-router-dom';class A extends React.Component &#123; render() &#123; return ( &lt;div&gt; Component A 接受的参数是：&#123;this.props.match.params.id&#125; &lt;/div&gt; ); &#125;&#125;class B extends React.Component &#123; render() &#123; return ( &lt;div&gt;Component B&lt;/div&gt; ); &#125;&#125;//Link用作跳转导航class Wrapper extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Link to="/a/123"&gt;显示组件A，带参数&lt;/Link&gt; &lt;br/&gt; &lt;Link to="/b"&gt;显示组件B&lt;/Link&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;//定义router路由规则,用于匹配Link做跳转导航；ReactDOM.render( &lt;Router&gt; &lt;Wrapper&gt; &#123;/*带参数*/&#125; &lt;Route path="/a/:id" component=&#123;A&#125;/&gt; &lt;Route path="/b" component=&#123;B&#125;/&gt; &lt;/Wrapper&gt; &lt;/Router&gt;, document.getElementById('app')); 相同路径匹配真假参数 子组件中使用Route来匹配带参数和不带参数path,使用Switch来进行匹配; 路径结构相同时：区分子路径是否是参数的办法是，将参数通配路径置后； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#123;HashRouter as Router, Link, Route, Switch&#125; from 'react-router-dom';class A extends React.Component &#123; render() &#123; return ( &lt;div&gt; Component A &#123;/*子组件内部switch匹配对应路由规则*/&#125; &lt;Switch&gt; &#123;/*path不是完全匹配,如果需要完全等于某路径,需要path前面加上exact关键字*/&#125; &lt;Route exact path=&#123;`$&#123;this.props.match.path&#125;`&#125; render=&#123;() =&gt; &#123; return (&lt;div&gt;当前组件是不带参数的A&lt;/div&gt;); &#125;&#125;/&gt; &#123;/*路径结构相似，为了区分子路径名和通配参数，需要将带通配的参数Route放在后面；*/&#125; &lt;Route exact path=&#123;`$&#123;this.props.match.path&#125;/sub`&#125; render=&#123;() =&gt; &#123; return (&lt;div&gt;当前组件是与带参数的A路径结构相同，但是sub不是参数&lt;/div&gt;); &#125;&#125;/&gt; &lt;Route path=&#123;`$&#123;this.props.match.path&#125;/:id`&#125; render=&#123;(route) =&gt; &#123; return (&lt;div&gt;当前组件是带参数的A,参数是：&#123;route.match.params.id&#125;&lt;/div&gt;); &#125;&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; ); &#125;&#125;class B extends React.Component &#123; render() &#123; return ( &lt;div&gt;Component B&lt;/div&gt; ); &#125;&#125;//Link用作跳转导航class Wrapper extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;Link to="/a/sub"&gt;显示组件A的sub路径，不带参数&lt;/Link&gt; &lt;br/&gt; &lt;Link to="/a/123"&gt;显示组件A，带参数&lt;/Link&gt; &lt;br/&gt; &lt;Link to="/a"&gt;显示组件A，不带参数&lt;/Link&gt; &lt;br/&gt; &lt;Link to="/b"&gt;显示组件B&lt;/Link&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;//定义router路由规则,用于匹配Link做跳转导航；ReactDOM.render( &lt;Router&gt; &lt;Wrapper&gt; &#123;/*带参数*/&#125; &lt;Route path="/a" component=&#123;A&#125;/&gt; &lt;Route path="/b" component=&#123;B&#125;/&gt; &lt;/Wrapper&gt; &lt;/Router&gt;, document.getElementById('app'));]]></content>
      <categories>
        <category>大前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记]]></title>
    <url>%2F2017%2F10%2F01%2Fweb%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章是React学习笔记。 创建react项目创建新的react项目 这种方式创建的react项目，已经为你配置好了Babel和webpack，你可以零配置使用，这种方式灵活性不好，所有的配置都自动被配置好了。 需要Node &gt;= 6, 按如下步骤： 12345678//1.安装创建项目插件：npm install -g create-react-app//2.创建项目：create-react-app my-appcd my-app//3.启动项目：npm start 在已有项目中添加react初始化config.json文件，安装react和react-dom库即可支持react开发，为了更好的开发效率，建议使用webpack配置babel-loader来支持ES6和JSX语法； 默认安装最新版，注意react相关库应保持版本一致； 通过Yarn安装React: 12yarn inityarn add react react-dom 通过npm安装React: 12npm initnpm install --save react react-dom JSXJSX是对JavaScript语法的扩展，具有JavaScrip的全部能力，JSX可以生成React“元素”。 JSX概述JSX可以直接使用html的写法，如下就可以看做一个JSX表达式： 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 表达式写法规则 jsx表达式写在{}里，可以用花括号{}把任意的JavaScript表达式嵌入到JSX中。 JSX本身其实也是一种表达式,可以在if语句或者是for循环中使用JSX： 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; 组件命名：大写字母开头。 1const SpecificStory = ...; 属性名：使用camelCase小驼峰命名来定义组件属性的名称，包括html模板里的标签属性名。 JSX中用点表示法来引用组件： 12// 引用MyComponents模块中的DatePicker组件&lt;MyComponents.DatePicker color="blue" /&gt;; 属性值概念：标签内部设置的成员值； 属性赋值方式 使用引号来定义以字符串为值的属性： 1const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;; 使用花括号{}来定义以JavaScript表达式为值的属性： 1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; 123//使用...作为扩展操作符来传递属性对象：const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;;return &lt;Greeting &#123;...props&#125; /&gt;; 模板样式 jsx语法定义的html模板用括号()括起来，可以防止编辑工具自动在行尾加分号； 给标签元素设置样式，有两种方式： 通过给标签的style属性指定一个样式对象； 使用css样式文件集中管理样式； 指定样式对象给jsx语法定义的html模板内的标签，添加style属性，属性值设置为一个样式对象： 12345678910let x_style = &#123; color: 'b'+'lue' //允许样式带逻辑&#125;;let jsx = ( &lt;div&gt; &lt;h1 style=&#123;styles&#125;&gt;Hello, world!&lt;/h1&gt; &lt;h3 style=&#123;&#123;color:'yellow'&#125;&#125;&gt;Hello, world!&lt;/h3&gt; &lt;/div&gt;); 特点 允许样式值带逻辑语句； 样式对象属性名是用驼峰式命名，没有使用css里的中横杠； CSS样式文件 定义样式文件x.css： 1234567#jsxId &#123; color: blue;&#125;.jsxClass &#123; color: yellow;&#125; jsx文件中导入样式文件使用： 1234567import './x.css';let jsx = ( &lt;div&gt; &lt;h1 id="jsxId"&gt;Hello, world!&lt;/h1&gt; &lt;h1 className="jsxClass"&gt;Hello, world!&lt;/h1&gt; &lt;/div&gt;); JSX语法变量使用123456let name='jason';let jsx = ( &lt;div&gt; &lt;p&gt;I am &#123;name&#125;&lt;/p&gt; &lt;/div&gt;); 条件表达式if语句if不能嵌入在{}里面 12345if (bool) &#123; // ...&#125; else &#123; // ...&#125; 与运算符&amp;&amp; 概述在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。 使用可以通过用花括号{}包裹代码在 JSX 中嵌入‘与运算’表达式。 示例： 1&#123;1 &gt; 0 &amp;&amp; &lt;h2&gt;hello&lt;/h2&gt;&#125; 三目运算符表达式1condition ? true : false 使用示例123456789let flag = false;let name = 'jason';let jsx = ( &lt;div&gt; &#123; flag ? &lt;p&gt;I am &#123;name&#125;&lt;/p&gt; : &lt;p&gt;I am not &#123;name&#125;&lt;/p&gt; &#125; &lt;/div&gt;); 循环方法通过map方法遍历数组生成列表: 12345678let names = ['Jason', 'Lily', 'Simon'];let jsx = ( &lt;div&gt; &#123; names.map((name, index) =&gt; &lt;p key=&#123;index&#125;&gt;hello, I am &#123;name&#125;&lt;/p&gt;) &#125; &lt;/div&gt;); 元素概念元素是构成React应用的最小单位，用来描述你在屏幕上看到的内容。 12// 定义一个元素const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; 与浏览器的DOM元素不同，React中的元素事实上是普通的对象，React DOM可以确保 浏览器DOM的数据内容与React元素保持一致。 注意：元素事实上只是构成组件的一个部分。 根节点用React开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React的话，你可能会需要在不同的部分单独定义React 根节点。 在react项目的public/index.html中，id=”root”的div作为项目的根节点，根节点的内容由React Dom来管理。1&lt;div id="root"&gt;&lt;/div&gt; 元素的渲染一般通过src/index.js中的ReactDOM.render()方法将React元素渲染到根节点。 如下：将定义好的App渲染到根节点。 1234ReactDOM.render( &lt;App/&gt;, document.getElementById('root')); 组件概念组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。 组件的定义 类定义的组件名或者定义组件的函数名，必须以大写字母开头。 函数定义组件使用JavaScript函数定义一个组件： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 该函数是一个有效的React组件，它接收一个单一的“props”对象并返回了一个React元素。 ES6类定义组件1234567// 继承自Component组件类class Welcome extends React.Component &#123; // render方法返回一个渲染结果 render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; React 组件也可以通过数组的形式返回多个元素： 123456789render() &#123; // 不需要使用额外的元素包裹数组中的元素 return [ // 不要忘记 key &lt;li key="A"&gt;First item&lt;/li&gt;, &lt;li key="B"&gt;Second item&lt;/li&gt;, &lt;li key="C"&gt;Third item&lt;/li&gt;, ];&#125; 组件的渲染元素也是一个组件，自定义组件通过render()方法返回渲染出的界面。 阻止组件渲染阻止组件渲染，让View、组件或组件的render方法返回null，而不是它的渲染结果即可实现。 示例： 123456789101112131415// 组件函数function ShowWidget(props) &#123; if (!props.isShow) &#123; return null; &#125; return ( &lt;div className=&quot;isShow&quot;&gt; 显示 &lt;/div&gt; );&#125;// 使用组件时&lt;ShowWidget isShow=&#123;this.state.isShow&#125; /&gt; 注意：阻止组件的渲染，并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。 props组件的属性 概念 props是一种从父级向子级传递数据的方法； 使用时组件内部只能读父组件的属性值，组件不能改变props； 属性的种类继承父组件属性12345class MyComponent extends React.Component&#123; constructor(props)&#123; super(props); &#125;&#125; 默认属性create-react-app创建的项目支持这种写法12345// 定义默认属性static defaultProps=&#123; name:'张三(默认名字)', age:20&#125; props类型检查主要对props的属性进行类型检查。 注意: React.PropTypes 自 React v15.5 起已弃用。请使用 prop-types 库代替。 12// 命令安装prop-types库到node_modules内，并添加到package.json中$ npm install --save prop-types 使用方式给props成员设置类型约束 123456789101112131415import PropTypes from 'prop-types';// 写在组件类内部static propTypes=&#123; name:PropTypes.string, age:PropTypes.number, sex:PropTypes.string.isRequired //必须的&#125;// 写在组件类外部MyClass.propTypes=&#123; name: PropTypes.number // isRequired必须的 id: PropTypes.number.isRequired&#125; 常见约束类型约束类型都在PropTypes模块中 1234567891011121314151617181920var ReactPropTypes = &#123; array: shim, bool: shim, func: shim, number: shim, object: shim, string: shim, symbol: shim, any: shim, arrayOf: getShim, element: shim, instanceOf: getShim, node: shim, objectOf: getShim, oneOf: getShim, oneOfType: getShim, shape: getShim, exact: getShim&#125;; 常用类型约束写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 你可以将属性声明为以下 JS 原生类型 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可被渲染的元素（包括数字、字符串、子元素或数组）。 optionalNode: PropTypes.node, // 指定只传递一个子代，即一个 React 元素 optionalElement: PropTypes.element, // 你也可以声明属性为某个类的实例，这里使用 JS 的 // instanceof 操作符实现。 optionalMessage: PropTypes.instanceOf(Message), // 你也可以限制你的属性值是某个特定值之一 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 限制它为列举类型之一的对象 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 一个指定元素类型的数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 一个指定类型的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 一个指定属性及其类型的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你也可以在任何 PropTypes 属性后面加上 `isRequired` // 后缀，这样如果这个属性父组件没有提供时，会打印警告信息 requiredFunc: PropTypes.func.isRequired, // 任意类型的数据 requiredAny: PropTypes.any.isRequired, // 你也可以指定一个自定义验证器。它应该在验证失败时返回 // 一个 Error 对象而不是 `console.warn` 或抛出异常。 // 不过在 `oneOfType` 中它不起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 不过你可以提供一个自定义的 `arrayOf` 或 `objectOf` // 验证器，它应该在验证失败时返回一个 Error 对象。 它被用 // 于验证数组或对象的每个值。验证器前两个参数的第一个是数组 // 或对象本身，第二个是它们对应的键。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 静态类型检查 像Flow和TypeScript这样的静态类型检查器可以在运行代码之前识别某些类型的问题。 对于大的项目建议使用Flow或者TypeScript来替代PropTypes。 state状态； 概念 状态与属性十分相似，但是状态是私有的，完全受控于当前组件。 对于组件，state是可变的，一般通过改变state来刷新组件。 State 只在交互的时候使用，即随时间变化的数据。 state的定义1234// 方法1：默认静态成员声明；state = &#123; size: 80&#125; 1234567// 方法2：构造器中定义；constructor(props) &#123; super(props); this.state=&#123; size:80 &#125;;&#125; 1234567// 方法3：构造器中定义；constructor(props) &#123; super(props); this.state=(&#123; size:80 &#125;);&#125; 改变state1234// 一般写法this.setState(&#123; comment: 'Hello'&#125;); 123456789101112// 接受一个函数，参数1：先前的状态；参数2：props// 常规函数形式this.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;;&#125;);// 箭头函数形式this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); state异步改变在react中设置state后，state的更新时异步执行的，如果想state更新后立即执行某些逻辑，可以为setState方法添加第二个参数，setState的第二个参数使用一个匿名函数作为异步跟新后的处理函数； 示例： 12345this.setState(&#123; myState: true&#125;, ()=&gt; &#123;//...状态更新后需要立即处理的逻辑；&#125;) 事件的处理 事件名称首字母小写的驼峰式命名法； 事件需要一个处理函数/方法(类中)； 阻止链接打开页面 注：# 表示无效链接 传统的HTML中：通过处理函数返回false来阻止打开默认页面； 123&lt;a href="https://www.baidu.com/" onclick="console.log('The link was clicked.'); return false"&gt; Click me&lt;/a&gt; react中通过调用e.preventDefault()方法来阻止打开默认页面； 1234567891011121314render() &#123; return ( &lt;div className="App"&gt; &lt;a href="https://www.baidu.com/" onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/a&gt; &lt;/div&gt; );&#125;handleClick(e) &#123; // e作为一个事件对象，通常放在参数后面 e.preventDefault();&#125; 监听事件的绑定 在ES6中，方法不再自动绑定this,需要手动bind,并且每次bind都会返回一个新的引用。 使用箭头函数或者构造器绑定的方法可以为事件方法绑定this； 在构造器中绑定this123456789101112131415161718192021222324class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = (&#123; count: 0 &#125;); this.handleClick=this.handleClick.bind(this); &#125; handleClick()&#123; this.setState(&#123; count: this.state.count+1, &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click me&lt;/button&gt; &lt;lable&gt;click count &#123;this.state.count&#125;&lt;/lable&gt; &lt;/div&gt; ); &#125;&#125; 箭头函数绑定this使用箭头函数在定义的时候就绑定好了this指针：即this.event=event; 方式一：在方法调用的地方使用箭头函数： 1234567891011121314151617181920212223class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = (&#123; count: 0 &#125;); &#125; handleClick()&#123; this.setState(&#123; count: this.state.count+1, &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;click me&lt;/button&gt; &lt;lable&gt;click count &#123;this.state.count&#125;&lt;/lable&gt; &lt;/div&gt; ); &#125;&#125; 方式二：在方法声明时，使用箭头函数声明，调用时用this直接调用： 123456789//定义方法时：使用箭头函数返回箭头函数的方式定义；checkColorType= value=&gt;()=&gt;&#123; this.setState(&#123; colorValue: value, &#125;);&#125;;//调用时：直接使用this调用即可；onClick=&#123;this.checkColorType(x)&#125; 生命周期钩子生命周期方法调用图react声明周期图如下： 触发生命周期方法调用示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class MyComponent extends React.Component &#123; //设置默认属性(仅初始化设置一次) static defaultProps=&#123; data: 'default data' &#125;; constructor(props) &#123; super(props); console.log('-------constructor-------'); this.state = (&#123; message: 'null' &#125;); &#125; //将要装载组件 componentWillMount() &#123; console.log('-------componentWillMount-------'); &#125; //组件装载完毕 componentDidMount() &#123; console.log('-------componentDidMount-------'); &#125; //将要接收父组件传来的props componentWillReceiveProps(nextProps, nextContext) &#123; console.log('-------componentWillReceiveProps-------'); &#125; //是否应该更新组件(默认更新) shouldComponentUpdate(nextProps, nextState, nextContext) &#123; console.log('-------shouldComponentUpdate-------'); return true; &#125; //组件将要更新 componentWillUpdate(nextProps, nextState, nextContext) &#123; console.log('-------componentWillUpdate-------'); &#125; //组件更新完毕 componentDidUpdate(nextProps, nextState, nextContext) &#123; console.log('-------componentDidUpdate-------'); &#125; //渲染组件 render() &#123; console.log('-------render-------'); return ( &lt;div&gt; Hello World &lt;/div&gt; ); &#125; //卸载组件 componentWillUnmount() &#123; console.log('-------componentWillUnmount-------'); &#125;&#125;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: 'old props', isShow: true &#125; &#125; //改变属性，触发子组件属性改变 changeData() &#123; this.setState(&#123; data: "new props" &#125;); &#125; //卸载子组件 destroyChildComponent() &#123; this.setState(&#123; isShow: false &#125;); &#125; render() &#123; return ( &lt;div&gt; &#123; this.state.isShow ? &lt;MyComponent data=&#123;this.state.data&#125;/&gt; : null &#125; &lt;button onClick=&#123;() =&gt; this.changeData()&#125;&gt;改变props&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.destroyChildComponent()&#125;&gt;卸载子组件&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;App/&gt;, document.getElementById('app')); 组件间的组合关系纯组件嵌套直接嵌套组件使用： 1234567891011121314151617181920212223242526272829303132class Child extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; hello I am &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;class Father extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; &lt;Child name="张三"/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Father/&gt;, document.getElementById('app')); 子代容器组件 组件中利用props（props.children）传递子内容或标签内容； 组件开始和结束标签的JSX 表达式中，标记之间的内容作为子代（子内容）。使用{props.children}作为子代内容的占位。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243class A extends React.Component &#123; render() &#123; return ( &lt;div&gt; Component A &lt;/div&gt; ); &#125;&#125;class B extends React.Component &#123; render() &#123; return ( &lt;div&gt; Component B &lt;/div&gt; ); &#125;&#125;class Wrapper extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125; &#125; render() &#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Wrapper&gt; &lt;p&gt;子内容嵌套&lt;/p&gt; &lt;A/&gt; &lt;B/&gt; &lt;/Wrapper&gt;, document.getElementById('app')); 子代内容类型 字符串常量： 1&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt; JSX组件标签 1234&lt;MyContainer&gt; &lt;MyFirstComponent /&gt; &lt;MySecondComponent /&gt;&lt;/MyContainer&gt; JavaScript 表达式 通常情况下，插入 JSX 中的 JavsScript 表达式将被认作字符串、React 元素或这些内容的列表。 123456// 以下两个等价&lt;MyComponent&gt;foo&lt;/MyComponent&gt;&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/MyComponent&gt;// 混合类型使用&lt;div&gt;Hello &#123;props.addressee&#125;!&lt;/div&gt;; 12345678910111213// 渲染任意长度的 JSX 表达式的列表很有用function Item(props) &#123; return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;&#125;function TodoList() &#123; const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( &lt;ul&gt; &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125; &lt;/ul&gt; );&#125; 函数 利用props.children 来获得传递的子代： 123456789101112131415function Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 布尔值、Null 和 Undefined 被忽略 false、null、undefined 和 true 都是有效的子代，但它们不会直接被渲染。 下面的表达式是等价的： 123456&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 如果让false、null、undefined和true输出，需要强制转成字符串：1&#123;String(myVariable)&#125;. 组件间通信父组件通信子组件父组件通过设置属性传递给子组件，子组件通过props获取父组件传递的属性； 子组件通信父组件通过在父组件内定义回调函数，在子组件里利用props调用父组件的回调函数即可； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ChildA extends React.Component &#123; constructor(props) &#123; super(props); &#125; //子组件通过调用父组件传递来的changeParentMsg属性，来调用父组件的改变状态的方法 changeParentMsg()&#123; this.props.changeBMsg('A is changing message'); &#125; render() &#123; return ( &lt;div id="childFrame"&gt; &lt;label&gt;childA&lt;/label&gt; &lt;br/&gt; &lt;button onClick=&#123;()=&gt;this.changeParentMsg()&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = (&#123; message: 'null' &#125;); &#125; changeBMsg(msg) &#123; this.setState(&#123; message: msg, &#125;); &#125; render() &#123; return ( &lt;div id="parentFrame"&gt; &lt;lable&gt;parent&lt;/lable&gt; &lt;br/&gt; &lt;label&gt;message : &#123;this.state.message&#125;&lt;/label&gt; &#123;/*父组件定义属性绑定方法*/&#125; &lt;ChildA changeBMsg=&#123;msg =&gt; this.changeBMsg(msg)&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Parent/&gt;, document.getElementById('app')); 兄弟组件通信通过状态提升进行兄弟组件通信； 状态提升子组件A通讯传给父组件，改变父组件的state，父组件再讲state传给兄弟组件；（这种方式为了在兄弟组件中传递数据，把数据放到了父组件里，这种方式叫状态提升） 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ChildA extends React.Component &#123; constructor(props) &#123; super(props); &#125; //子组件通过调用父组件传递来的changeParentMsg属性，来调用父组件的改变状态的方法 changeParentMsg()&#123; this.props.changeBMsg('A is changing message'); &#125; render() &#123; return ( &lt;div id="childFrame"&gt; &lt;label&gt;childA&lt;/label&gt; &lt;br/&gt; &lt;button onClick=&#123;()=&gt;this.changeParentMsg()&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;class ChildB extends React.Component &#123; render() &#123; return ( &lt;div id="childFrame"&gt; &lt;label&gt;childB&lt;/label&gt; &lt;br/&gt; &lt;label&gt;message : &#123;this.props.message&#125;&lt;/label&gt; &lt;/div&gt; ); &#125;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = (&#123; message: 'null' &#125;); &#125; changeBMsg(msg) &#123; this.setState(&#123; message: msg, &#125;); &#125; render() &#123; return ( &lt;div id="parentFrame"&gt; &lt;lable&gt;parent&lt;/lable&gt; &lt;br/&gt; &lt;label&gt;message : &#123;this.state.message&#125;&lt;/label&gt; &#123;/*父组件定义属性绑定方法*/&#125; &lt;ChildA changeBMsg=&#123;msg =&gt; this.changeBMsg(msg)&#125;/&gt; &lt;br/&gt; &lt;ChildB message=&#123;this.state.message&#125;/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Parent/&gt;, document.getElementById('app')); 原生APP交互原生APP调用React原生APP调用React中的方法时，React的方法需要提升到window才能被正常调用，因为react只是js模板语法库，不能像原生js那样使用； 具体实现如下： 原生应用中调用js方法； 12//android WebView调用react的方法并传递参数mWebView.loadUrl("javascript:callJS('hello')"); react中定义方法由原生调用； 1234567891011121314151617181920//react中方法被原生调用import React, &#123;Component&#125; from 'react';export default class Test extends Component &#123; //定义需要被原生调用的方法 callJS(sessionid)&#123; alert('sessionid='+sessionid); console.log("sessionid="+sessionid); &#125; constructor(props) &#123; super(props); //构造其中绑定方法 this.callJS = this.callJS.bind(this); &#125; componentDidMount()&#123; //页面加载完毕后，将方法提升到window对象才能被原生调用到 window.callJS = this.callJS; &#125;&#125;]]></content>
      <categories>
        <category>大前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows平台搭建React Native开发环境]]></title>
    <url>%2F2017%2F09%2F17%2Fweb%2FReactNative%2FWindows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BAReact%20Native%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录Windows平台搭建React Native开发环境。 安装git可以使用git提供的项目版本控制和命令行工具 安装nodejs安装nodejs官网下载nodejs进行安装，可以是推荐版本或者最新版本，官网提示避免7.1版本的nodejs. 如果安装nodejs时，没有选择add nodejs to path自动配置环境变量，需要配置nodejs的根目录作为环境变量，如：“Nodejs\”。 验证安装执行如下命令，显示相应信息说明安装成功： 12$ nodejs -v //显示nodejs对应版本说明安装成功；$ npm -v //显示nodejs自带**包管理工具**npm的版本； 配置npm镜像配置npm的镜像地址，可以加速npm. 配置方法： 命令配置：执行如下两条命令。 12$ npm config set registry https://registry.npm.taobao.org --global$ npm config set disturl https://npm.taobao.org/dist --global 本地配置：修改nodejs\node_modules\npm\npmrcnpmrc文件，在文件的最后一行添加： 1$ registry=https://registry.npm.taobao.org 安装Yarn、React Native的命令行工具(react-native-cli)yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。 react-native-cli是React Native的命令行工具，用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 备注：也可以不用安装Yarn,官网推荐安装。 yarn和react-native-cli同时安装的安装命令： 1$ npm install -g yarn react-native-cli 安装完yarn后同理也要设置镜像源： 12$ yarn config set registry https://registry.npm.taobao.org --global$ yarn config set disturl https://npm.taobao.org/dist --global 配置Android开发环境 安装android sdk、android ndk、android studio。 配置环境变量 新建如下环境变量： ANDROID_HOME=android-sdk/ ANDROID_NDK=android-ndk/ Path中新增环境变量： jdk/bin %ANDROID_HOME% %ANDROID_NDK% mingw/bin (==c语言支持库==) android-sdk/tools android-sdk/platform-tools nodejs/ gradle-3.5/bin (==主要用于方便使用gradle命令==) Android开发推荐安装工具Gradle Daemon开启Gradle Daemon可以极大地提升java代码的增量编译速度。 执行如下命令 $ (if not exist “%USERPROFILE%/.gradle” mkdir “%USERPROFILE%/.gradle”) &amp;&amp; (echo org.gradle.daemon=true &gt;&gt; “%USERPROFILE%/.gradle/gradle.properties”) 创建react-native项目使用如下命令创建项目： 12$ react-native init AwesomeProject //创建react-native项目$ cd AwesomeProject //进入项目根目录 简单的运行react-native项目到手机方式一命令行的方式1$ react-native run-android //安装项目到安卓设备，同时启动react-native服务 安装release版应用1$ react-native run-android --variant=release //需要配置签名 启动本地服务后，打开安装好的app，在app的menu菜单中选择reload来同步服务中的代码。 如果是真机，需要打开react-native应用的“允许应用显示悬浮窗”权限。 在终端下运行命令查看应用对应的日志： 1$ adb logcat *:S ReactNative:V ReactNativeJS:V 方式二 运行项目根目录中android目录的项目到android studio上，编译安装应用到手机设备； 命令单独启动react-native服务 1$ react-native start 悬浮菜单reload项目，及时查看效果； 真机上运行项目细节【1】确保有且仅有一个手机USB连接到电脑：通过adb devices命令检查连接： 1234$ adb devicesList of devices attachedemulator-5554 offline # Google模拟器14ed2fcc device # 真实设备 【2】安装android项目到手机，打开悬悬浮窗权限，启动react-native本地服务；【3】android 5.0以上系统： 注意，这个选项只能在5.0以上版本(API 21+)的安卓设备上使用。 首先把你的设备通过USB数据线连接到电脑上，并开启USB调试（关于如何开启USB调试，参见上面的内容）。 运行命令设置手机访问的端口号：1$ adb reverse tcp:8081 tcp:8081 摇晃设备，或者运行命令 1$ adb shell input keyevent 82 就可以打开开发者悬浮窗菜单，使用Reload JS实时查看应用效果了。 【4】android 5.0以下系统： 首先确保你的电脑和手机设备在同一个Wi-Fi环境下。 在设备上运行你的React Native应用。和打开其它App一样操作。 你应该会看到一个“红屏”错误提示。这是正常的，下面的步骤会解决这个报错。 摇晃设备，或者运行adb shell input keyevent 82，可以打开开发者菜单。 点击进入Dev Settings。 点击Debug server host for device。 输入你电脑的IP地址和端口号（譬如10.0.1.1:8081）。在Mac上，你可以在系统设置/网络里找查询你的IP地址。在Windows上，打开命令提示符并输入ipconfig来查询你的IP地址。在Linux上你可以在终端中输入ifconfig来查询你的IP地址。 回到开发者菜单然后选择Reload JS。 上传项目到github .gitignore中添加如下忽略内容 node_moudles package-lock.json 在nodejs 8.x后会生成package-lock.json文件，此文件不需要上传，可以删掉；原因：nodejs升级到8.x后npm也升级到了5.x版本，相应的，当 node_modules 或 package.json 发生变化时自动生成package-lock.json文件，这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。对比之下，大概是想做类似 Yarn 的功能。坑：如果手动修改了 package.json 文件中已有模块的版本，直接执行npm install不会安装新指定的版本，只能通过npm install xxx@yy更新。 上传项目到github等仓库。 运行别人的react-native项目步骤： 切换到项目根目录； 执行命令：npm install(这个是用来下载node_moudles文件夹的，这个文件夹一般不上传的)； 启动react-native服务，运行app查看效果；]]></content>
      <categories>
        <category>大前端</category>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows平台配置C语言支持环境MinGw]]></title>
    <url>%2F2017%2F09%2F04%2FC%2Fwindows%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AEC%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E7%8E%AF%E5%A2%83MinGw%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录windows平台C语言MinGw支持库配置的笔记。 MinGW-w64 全称：MinGW-w64 - for 32 and 64 bit Windows. 官方地址：https://sourceforge.net/projects/mingw-w64/files/mingw-w64/ 安装方式选择安装版MinGW-W64-install.exe 安装面板如下： 标注： (版本)Version 选择所能接受的最高版本. (架构)Architecture 32位cpu选择i686，64位cpu选择x86_64. (线程模式)Threads 如果使用posix api选择posix，如果使用win32 api选择win32. (异常处理机制)Exception 有三种，根据机器情况进行选择： 1231&gt; sjlj(setjmp/longjmp)(推荐)兼容性好，32位或64位架构都可以使用，但速度慢;2&gt; dwarf速度比SJLJ快，但只能用于32位架构，且有bug，尽量不用;3&gt; seh(zero overhead exception) 速度快，只能用于64位架构; (编译版本)Build revision 选择最高的. 压缩包版网速差的情况下下载压缩包，推荐下载x86_64-posix-seh. 配置环境变量 Path: C:\mingw\mingw64\bin. 验证：cmd-&gt;输入命令：gcc -v 显示gcc版本即可.]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot接入swagger2接口文档]]></title>
    <url>%2F2017%2F06%2F04%2FJava%2FSpring-Boot%2Fspring-boot%E6%8E%A5%E5%85%A5swagger2%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍spring-boot接入swagger2接口文档。 配置步骤 添加maven依赖（2.8.0风格略丑，这里用2.7.0版本）: 12345678910111213&lt;dependencies&gt;&lt;!--swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加swagger配置类: 12345678910111213141516171819202122@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// .apis(RequestHandlerSelectors.basePackage("com.ls.sbe")) // 扫描该包下所有controller文件 .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) // 仅扫描ApiOperation注解的方法 .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("API文档") .description("for spring boot project") .version("1.0.0") .build(); &#125;&#125; 配置相关Controller以及接口方法注解； 启动服务，访问：http://localhost:8083/swagger-ui.html Swagger接口注解Controller接口类注解@Api 概述ApiController接口类说明注解：@Api,作用在XController上。 使用示例1234@Api(tags = "case-api", description = "HTTP请求方法示例")@RestController@RequestMapping(value = "/httpApi")public class HttpApiRestController &#123;&#125; 参数配置： value：controller接口路径或类别名（无效）； tags：controller接口类别名，如果设置这个值、value的值会被覆盖； description：对api资源的描述； basePath：基本路径可以不配置； position：如果配置多个Api 想改变显示的顺序位置； produces：For example, “application/json, application/xml”； consumes：For example, “application/json, application/xml”； protocols：Possible values: http, https, ws, wss； authorizations：高级特性认证时配置； hidden：配置为true 将在文档中隐藏； 接口方法注解@ApiOperation 概述对API接口XController类中，具体接口方法的协议配置注解：@ApiOperation，用在controller的方法上； 使用示例1@ApiOperation(value = "GET请求", notes = "GET请求-参数query",produces = "application/json;charset=UTF-8") 参数配置： value：url的路径值； tags：如果设置这个值、value的值会被覆盖； notes：方法的具体描述； description：对api资源的描述； basePath：基本路径可以不配置； position：如果配置多个Api 想改变显示的顺序位置； produces：Content-Type响应数据类型，For example, “application/json, application/xml”； consumes：For example, “application/json, application/xml”； protocols：Possible values: http, https, ws, wss； authorizations：高级特性认证时配置； hidden：配置为true 将在文档中隐藏； response：返回的对象（如：response = CommonDto.class）； responseContainer：这些对象是有效的 “List”, “Set” or “Map”.，其他无效； httpMethod：”GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”； code：http的状态码 默认 200； extensions：扩展属性； 方法参数注解 @ApiImplicitParams：参数集； @ApiImplicitParam：单个参数； 概述用在controller的方法上，单个参数用@ApiImplicitParam，多个参数用@ApiImplicitParams（内部单个参数用@ApiImplicitParam）。 使用示例123456@ApiImplicitParam(name = "tag", value = "标签", required = true, dataType = "String", paramType = "query")@ApiImplicitParams(&#123; @ApiImplicitParam(name = "tag", value = "标签", required = true, dataType = "String", paramType = "query"), @ApiImplicitParam(name = "tag2", value = "标签2", required = true, dataType = "String", paramType = "query")&#125;) 参数配置： name： 接收参数名； value：接收参数的意义描述； required：参数是否必填（true/false）； defaultValue: 默认值； dataType：参数的数据类型，只作为标志说明，并没有实际验证； hidden：隐藏该属性； example：举例子； 1Long/String等等； paramType：查询参数类型； 12345- path 以地址的形式提交数据；- query 直接跟参数完成自动映射赋值；- body 以流的形式提交 仅支持POST；- header 参数在request headers 里边提交；- form 以form表单的形式提交 仅支持POST； 数据实体类注解概述 @ApiModel 表明这是一个被swagger框架管理的model，用于class上； @ApiModelProperty 这里顾名思义，就是标注在被标注了@ApiModel的class的属性上； 使用示例1234567@ApiModel(description = "返回|请求 对象")public class CommonDto &#123; @ApiModelProperty(value = "标题") private String title; @ApiModelProperty(value = "消息") private String message;&#125; 响应码说明注解@ApiResponses 概述作用在controller内接口方法上，说明一些状态码的含义； 使用示例1234@ApiResponses(&#123; @ApiResponse(code = 300, message = "http 300"), @ApiResponse(code = 4300, message = "http 4300")&#125;)]]></content>
      <categories>
        <category>Java</category>
        <category>Spring-Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring-Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dt类型定义文件支持js语法高亮]]></title>
    <url>%2F2017%2F04%2F01%2Fweb%2Ftools%2Fdt%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81js%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍dt类型定义文件支持js语法高亮的配置。 类型定义文件 类型定义文件是以*.d.ts为后缀的文件，开发者在IDE开发js项目时，使用js工具库同时安装对应的类型定义文件，就可以使用代码提示功能。 类型定义文件库：DefinitelyTyped 下载类型定义文件的方法有两种方式： typings方式； npm方式； typings方式typings是下载类型定义文件的命令行管理工具； 安装typings 计算机全局安装，随处都可使用typings命令访问： 123$ npm install typings --global// 版本号检查$ typings --version 仅安装到指定的项目中： 1$ npm install typings --save-dev 查询类型定义文件通过如下命令查询js工具包的类型定义文件，如果有，则会正常显示，如果没有则无法下载,如下查找react的类型定义文件： 1234// 根据对应的typings名称查找：$ typings search react// 根据名称查找：$ typings search --name react 注：如果安装其他工具包的类型定义文件，可在TypeSearch上搜索，或者利用typings命令查找。 typings.config所有typings命令安装的类型定义文件都会配置到typings.config文件中； 创建typings.config文件： 1$ typings init 如果项目中已有typings.config配置，可执行安装命令，安装配置文件里的类型定义文件： 1$ typings install 或 1$ typings i 下载js工具包的类型定义文件，如下安装node类型定义文件： 1234// 安装到devDependencies，有时可能无效；$ typings install dt~node --save-dev// 安装到devDependencies无效果时，可以安装到全局globalDependencies；$ typings install dt~module --global --save npm方式npm安装类型定义文件，大多配置在package.json文件的devDependencies项中； 如：下载node的类型定义文件： 1$ npm install --save-dev @types/node]]></content>
      <categories>
        <category>大前端</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http-server本地服务工具库的使用]]></title>
    <url>%2F2017%2F03%2F25%2Fweb%2Ftools%2Fhttp-server%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%B7%A5%E5%85%B7%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录http-server本地服务工具库使用的笔记。 http-serverGitHub 简介http-server是一个简单的零配置命令行HTTP服务器, 基于 nodeJs。只需http-server命令即可启动基于当前文件夹的一个http服务器，可被外部访问。 安装全局安装：1$ npm install http-server -g 使用切换到指定目录，输入以下命令即可通过localhost:8080地址访问目录下的文件：1$ http-server 应用到package.json在package.json文件中配置如下：123456&#123; //... &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;http-server -a 0.0.0.0 -p 8000&quot;, &#125;&#125; 【参数说明】 12345678910111213141516-p 端口号 (默认 8080)-a IP 地址 (默认 0.0.0.0)-d 显示目录列表 (默认 &apos;True&apos;)-i 显示 autoIndex (默认 &apos;True&apos;)-e or --ext 如果没有提供默认的文件扩展名(默认 &apos;html&apos;)-s or --silent 禁止日志信息输出--cors 启用 CORS via the Access-Control-Allow-Origin header-o 在开始服务后打开浏览器-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to &apos;3600&apos;). 禁用 caching, 则使用 -c-1.-U 或 --utc 使用UTC time 格式化log消息-P or --proxy Proxies all requests which can&apos;t be resolved locally to the given url. e.g.: -P http://someurl.com-S or --ssl 启用 https-C or --cert ssl cert 文件路径 (default: cert.pem)-K or --key Path to ssl key file (default: key.pem).-r or --robots Provide a /robots.txt (whose content defaults to &apos;User-agent: *\nDisallow: /&apos;)-h or --help 打印以上列表并退出]]></content>
      <categories>
        <category>大前端</category>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs中mime类型文件处理库node-mime]]></title>
    <url>%2F2017%2F03%2F18%2Fweb%2Fnodejs%2Fnodejs%E4%B8%ADmime%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%BA%93node-mime%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍nodejs中mime类型文件处理库node-mime的使用。 概述此文档基于node-mime 2.x版本 node-minemine项目网址 介绍node-mime大多用在node项目或js项目中，用于处理响应在浏览器的打开方式； mime MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。 简单点说，mime是一个互联网标准，通过设定它就可以设定文件在浏览器的打开方式。 使用 npm安装： 1$ npm install mime --save js文件中使用； 1234const mime = require('mime');mime.getType('txt'); // ⇨ 'text/plain'mime.getExtension('text/plain'); // ⇨ 'txt' API 根据文件，查询文件的MIME类型： 1234【语法】getType(path: string): string | null;【参数】- path: 带文件扩展名的文件名或文件路径； 12345678910111213// 示例const mime = require(&apos;mime&apos;);mime.getType(&apos;js&apos;); // ⇨ &apos;application/javascript&apos;mime.getType(&apos;json&apos;); // ⇨ &apos;application/json&apos;mime.getType(&apos;txt&apos;); // ⇨ &apos;text/plain&apos;mime.getType(&apos;dir/text.txt&apos;); // ⇨ &apos;text/plain&apos;mime.getType(&apos;dir\\text.txt&apos;); // ⇨ &apos;text/plain&apos;mime.getType(&apos;.text.txt&apos;); // ⇨ &apos;text/plain&apos;mime.getType(&apos;.txt&apos;); // ⇨ &apos;text/plain&apos;mime.getType(&apos;foo/txt&apos;); // ⇨ nullmime.getType(&apos;bogus_type&apos;); // ⇨ null 根据mime类型，查询文件护展名: 1234【语法】getExtension(mime: string): string | null;【参数】- mime: mime类型； 12345// 示例const mime = require(&apos;mime&apos;);mime.getExtension(&apos;text/plain&apos;); // ⇨ &apos;txt&apos;mime.getExtension(&apos;application/json&apos;); // ⇨ &apos;json&apos;mime.getExtension(&apos;text/html; charset=utf8&apos;); // ⇨ &apos;html&apos; 自定义mime类型： 构造器实例方式： 123456789101112// 示例const Mime = require(&apos;mime/Mime&apos;);// 创建Mime实例，利用构造器自定义mime类型；const typeMap = &#123; &apos;text/abc&apos;: [&apos;abc&apos;, &apos;alpha&apos;, &apos;bet&apos;], &apos;text/def&apos;: [&apos;leppard&apos;]&#125;;const myMime = new Mime(typeMap);myMime.getType(&apos;abc&apos;); // ⇨ &apos;text/abc&apos;myMime.getExtension(&apos;text/def&apos;); // ⇨ &apos;leppard&apos; mime调用自定义方法； 1234【语法】define(mimes: TypeMap, force?: boolean): void;【参数】- mimes：自定义的mime类型map集合，以k-v形式，即：mime类型-[文件扩展名数组]。 123456// 示例const mime = require(&apos;mime&apos;);mime.define(&#123;&apos;text/x-abc&apos;: [&apos;abc&apos;, &apos;abcd&apos;]&#125;);mime.getType(&apos;abcd&apos;); // ⇨ &apos;text/x-abc&apos;mime.getExtension(&apos;text/x-abc&apos;) // ⇨ &apos;abc&apos;]]></content>
      <categories>
        <category>大前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说koa2框架]]></title>
    <url>%2F2017%2F03%2F11%2Fweb%2Fnodejs%2F%E7%BB%86%E8%AF%B4koa2%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍koa2框架的使用。 koa历史 基于2.x 参考资料 Koa GitHub地址：https://github.com/koajs/koa 安装koa npm安装koa到node_modules： 1$ npm install koa --save js文件中引入： 1const Koa = require('koa'); koa概述koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本，此处基于2.x版本； 异步概念koa2完全使用Promise并配合async来实现异步， koa可以把很多async函数组成一个处理链； 异步执行流程每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数，async函数内部，用await next()来调用下一个async函数，async函数按顺序用app.use()注册，next函数也是按注册顺序调用，如果一个async函数内没有调用await next()，则后续的async函数将不再执行。 123456app.use(async (ctx, next) =&gt; &#123; await next(); var data = await doReadFile(); ctx.response.type = 'text/plain'; ctx.response.body = data;&#125;); 123456789【async异步函数参数】- ctx：是由koa传入的封装了request和response的变量，可对ctx操作，设置返回内容; ---------------------------------- ctx.url相当于ctx.request.url; ctx.type相当于ctx.response.type; ----------------------------------- next：是koa传入的将要处理的下一个异步函数；【wait】- wait作用是等待出入的promise执行结束； 中间件每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。 koa-bodyparser模块详见：HTTP服务章节； koa-bodyparser库用来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。 在koa中，我们只需要给ctx.response.body赋值一个JavaScript对象，koa会自动把该对象序列化为JSON并输出到客户端。 非常适合编写rest-api; 处理url使用koa-router路由来集中处理url. koa原生处理koa原生api可以处理url，来响应不同的请求，如下，但是当支持的请求越多就会越混乱；123456789101112131415161718192021222324252627282930313233// 导入koaconst Koa = require('koa');// 创建一个Koa对象表示web app本身:const app = new Koa();app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === '/') &#123; ctx.response.body = 'index page'; &#125; else &#123; await next(); &#125;&#125;);app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === '/test') &#123; ctx.response.body = 'TEST page'; &#125; else &#123; await next(); &#125;&#125;);app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === '/error') &#123; ctx.response.body = 'ERROR page'; &#125; else &#123; await next(); &#125;&#125;);// 在端口3000监听:app.listen(3000);console.log('server on http://localhost:3000/'); koa-router为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射，这样开发者不用每次都去调用await next(),而只需要关心请求的处理。 get请求使用router.get(‘/path’, async fn)来注册一个GET请求。 参数 可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。 示例12345678910111213141516171819202122232425262728const Koa = require('koa');// 注意require('koa-router')返回的是函数:const router = require('koa-router')();const app = new Koa();// log request URL:app.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); await next();&#125;);// add url-route:router.get('/hello/:name', async (ctx, next) =&gt; &#123; var name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;&#125;);router.get('/', async (ctx, next) =&gt; &#123; ctx.response.body = '&lt;h1&gt;Index&lt;/h1&gt;';&#125;);// add router middleware:app.use(router.routes());app.listen(3000);console.log('server on http://localhost:3000/'); post请求请求参数 用post请求处理URL时，post请求通常会发送一个表单，或者JSON，它作为request的body发送，但是Node.js原始request对象、koa提供的request对象，都不提供解析request的body的功能。 koa-bodyparser库用来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。 安装koa-bodyparser库： 1$ npm install --save koa-bodyparser 导入,在router.routes()之前调用： 123456const bodyParser = require('koa-bodyparser');//...const app = new Koa();//...app.use(bodyParser());app.use(router.routes()); 示例一个post请求登录的实例1234567891011121314151617181920212223242526272829303132333435363738394041const Koa = require('koa');// 注意require('koa-router')返回的是函数:const router = require('koa-router')();const bodyParser = require('koa-bodyparser');const app = new Koa();// log request URL:app.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); await next();&#125;);router.get('/', async (ctx, next) =&gt; &#123; ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt; &lt;form action="/signin" method="post"&gt; &lt;p&gt;Name: &lt;input name="name" value="koa"&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input name="password" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Submit"&gt;&lt;/p&gt; &lt;/form&gt;`;&#125;);router.post('/signin', async (ctx, next) =&gt; &#123; var name = ctx.request.body.name || '', password = ctx.request.body.password || ''; console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`); if (name === 'koa' &amp;&amp; password === '12345') &#123; ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`; &#125; else &#123; ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href="/"&gt;Try again&lt;/a&gt;&lt;/p&gt;`; &#125;&#125;);app.use(bodyParser());app.use(router.routes());app.listen(3000);console.log('server on http://localhost:3000/'); HTTP-API封装 创建controller文件夹，用来处理请求业务，包含hell.js和index.js文件； hello.js文件，处理hello页面相关请求： 12345678let fn_hello = async (ctx, next) =&gt; &#123; let name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;&#125;;module.exports = &#123; 'GET /hello/:name': fn_hello&#125;; index.js登录页面处理登录相关请求： 1234567891011121314151617181920212223242526let fn_index = async (ctx, next) =&gt; &#123; ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt; &lt;form action="/signin" method="post"&gt; &lt;p&gt;Name: &lt;input name="name" value="koa"&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input name="password" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Submit"&gt;&lt;/p&gt; &lt;/form&gt;`;&#125;;let fn_signin = async (ctx, next) =&gt; &#123; let name = ctx.request.body.name || '', password = ctx.request.body.password || ''; console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`); if (name === 'koa' &amp;&amp; password === '12345') &#123; ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`; &#125; else &#123; ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href="/"&gt;Try again&lt;/a&gt;&lt;/p&gt;`; &#125;&#125;;module.exports = &#123; 'GET /': fn_index, 'POST /signin': fn_signin&#125;; controller.js文件，用于扫描controller目录里面的js请求处理文件； 123456789101112131415161718192021222324252627282930313233343536373839404142434445const fs = require('fs');// add url-route in /controllers:function addMapping(router, mapping) &#123; for (let url in mapping) &#123; if (url.startsWith('GET ')) &#123; let path = url.substring(4); router.get(path, mapping[url]); console.log(`register URL mapping: GET $&#123;path&#125;`); &#125; else if (url.startsWith('POST ')) &#123; let path = url.substring(5); router.post(path, mapping[url]); console.log(`register URL mapping: POST $&#123;path&#125;`); &#125; else if (url.startsWith('PUT ')) &#123; let path = url.substring(4); router.put(path, mapping[url]); console.log(`register URL mapping: PUT $&#123;path&#125;`); &#125; else if (url.startsWith('DELETE ')) &#123; let path = url.substring(7); router.del(path, mapping[url]); console.log(`register URL mapping: DELETE $&#123;path&#125;`); &#125; else &#123; console.log(`invalid URL: $&#123;url&#125;`); &#125; &#125;&#125;function addControllers(router, dir) &#123; fs.readdirSync(__dirname + '/' + dir).filter((f) =&gt; &#123; return f.endsWith('.js'); &#125;).forEach((f) =&gt; &#123; console.log(`process controller: $&#123;f&#125;...`); let mapping = require(__dirname + '/' + dir + '/' + f); addMapping(router, mapping); &#125;);&#125;module.exports = function (dir) &#123; let controllers_dir = dir || 'controllers', router = require('koa-router')(); addControllers(router, controllers_dir); return router.routes();&#125;; app.js作为程序的入口： 123456789101112131415161718const Koa = require('koa');const bodyParser = require('koa-bodyparser');const controller = require('./controller');const app = new Koa();// log request URL:app.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); await next();&#125;);app.use(bodyParser());app.use(controller());app.listen(3000);console.log('http://localhost:3000'); REST-API规范编写REST API，实际上就是编写处理HTTP请求的async函数，不过，REST请求和普通的HTTP请求有几个特殊的地方： REST请求仍然是标准的HTTP请求，但是，除了GET请求外，POST、PUT等请求的body是JSON数据格式，请求的Content-Type为application/json； REST响应返回的结果是JSON数据格式，因此，响应的Content-Type也是application/json。 REST请求只是一种请求类型和响应类型均为JSON的HTTP请求； rest-url示例 GET请求：获取所有Product的URL： 1GET /api/products GET请求：id为123的Product的URL: 1GET /api/products/123 GET请求：资源还可以按层次组织。例如，获取某个Product的所有评论，使用： 1GET /api/products/123/reviews GET请求：当我们只需要获取部分数据时，可通过参数限制返回的结果集，例如，返回第2页评论，每页10项，按时间排序： 1GET /api/products/123/reviews?page=2&amp;size=10&amp;sort=time POST请求: 新建一个Product，JSON数据参数包含在body中，URL如下： 1POST /api/products PUT请求: 更新一个Product使用PUT请求，例如，更新id为123的Product，其URL如下： 1PUT /api/products/123 DELETE请求：删除一个Product使用DELETE请求，例如，删除id为123的Product，其URL如下： 1DELETE /api/products/123 编写rest-api这里使用koa-bodyparser模块库来让ctx.request.body直接访问解析后的JavaScript对象。 在koa中处理REST请求是非常简单的。bodyParser()这个middleware可以解析请求的JSON数据并绑定到ctx.request.body上，输出JSON时我们先指定ctx.response.type = ‘application/json’，然后把JavaScript对象赋值给ctx.response.body就完成了REST请求的处理。 示例创建Product.js处理product相关的api请求：12345678910111213141516171819202122232425262728293031323334353637// 存储Product列表，相当于模拟数据库:let products = [&#123; name: 'iPhone', price: 6999&#125;, &#123; name: 'Kindle', price: 999&#125;];module.exports = &#123; // localhost:3000/api/products 'GET /api/products': async (ctx, next) =&gt; &#123; // 设置Content-Type: ctx.response.type = 'application/json'; // 设置Response Body: // json object // ctx.response.body = &#123; // products: products // &#125;; // json array ctx.response.body = products; &#125;, // url：localhost:3000/api/products // Content-Type：application/json // params-style-body: &#123;"name":"XBox","price":3999&#125; 'POST /api/products': async (ctx, next) =&gt; &#123; let p = &#123; name: ctx.request.body.name, price: ctx.request.body.price &#125;; products.push(p); ctx.response.type = 'application/json'; ctx.response.body = p; &#125;&#125;; Nunjucks官方文档 Nunjucks官方文档自带中文版翻译； 模板引擎Nunjucks是一个模板引擎，模板引擎就是基于模板配合数据构造出字符串输出的一个组件。 简介Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。 安装1$ npm install nunjucks --save APINunjucks支持在html模板中使用一些NunjucksAPI的逻辑语法； block区块模板可以通过block拆分成许多区块； 123&#123;% block css %&#125;&lt;link rel=&quot;stylesheet&quot; href=&quot;app.css&quot; /&gt;&#123;% endblock %&#125; 模板继承 先定义一个基本的网页框架base.html： 12345&lt;html&gt;&lt;body&gt;&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125;&lt;/body&gt; base.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义： 12345&#123;% extends &apos;base.html&apos; %&#125;&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125; koa2中使用 封装nunjucks，为koa异步函数的ctx添加render属性，用于渲染模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 模板引擎nunjucks封装，目的是给异步函数的ctx添加render方法，来调用模板引擎渲染视图 */const nunjucks = require('nunjucks');function createEnv(path, opts) &#123; let autoescape = opts.autoescape === undefined ? true : opts.autoescape, noCache = opts.noCache || false, watch = opts.watch || false, throwOnUndefined = opts.throwOnUndefined || false, env = new nunjucks.Environment( new nunjucks.FileSystemLoader(path, &#123; noCache: noCache, watch: watch, &#125;), &#123; autoescape: autoescape, throwOnUndefined: throwOnUndefined &#125;); if (opts.filters) &#123; for (let f in opts.filters) &#123; env.addFilter(f, opts.filters[f]); &#125; &#125; return env;&#125;/** * ctx添加render方法，调用时会调用nunjucks模板引擎渲染模板 * @param path * @param opts * @returns &#123;function(*, *)&#125; */function templating(path, opts) &#123; let env = createEnv(path, opts); return async (ctx, next) =&gt; &#123; ctx.render = function (view, model) &#123; ctx.response.body = env.render(view, Object.assign(&#123;&#125;, ctx.state || &#123;&#125;, model || &#123;&#125;)); ctx.response.type = 'text/html'; &#125;; await next(); &#125;;&#125;module.exports = templating; koa中,加载controller网络请求前加载模板引擎配置： 1234567891011121314151617181920212223242526272829const Koa = require('koa');const bodyParser = require('koa-bodyparser');const controller = require('./controller');const templating = require('./templating');const app = new Koa();// log request URL:app.use(async (ctx, next) =&gt; &#123; console.log('----------------start----------------'); console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); await next(); console.log('----------------end----------------');&#125;);// request解析bodyapp.use(bodyParser());// nunjucks模板引擎app.use(templating('views', &#123; noCache: !isProduction, watch: !isProduction&#125;));// 加载所有逻辑处理controller的请求函数app.use(controller());app.listen(3000);console.log('server on http://localhost:3000/'); http请求响应调用模板引擎渲染： 1234567module.exports = &#123; &apos;GET /&apos;: async (ctx, next) =&gt; &#123; ctx.render(&apos;index.html&apos;, &#123; title: &apos;Welcome&apos; &#125;); &#125;&#125;;]]></content>
      <categories>
        <category>大前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs笔记]]></title>
    <url>%2F2017%2F03%2F04%2Fweb%2Fnodejs%2Fnodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录nodejs的笔记。 开发环境安装nodejs下载安装 nodejs官网下载推荐版本，安装时记得添加到环境变量（Add to Path）； nodejs自带npm，是Node.js的包管理工具; 查看安装的版本执行如下命令，会显示相应版本，说明安装成功1234// node的版本$ node -v// npm的版本$ npm -v 语法提示类型定义文件安装类型定义文件类型定义文件配置node支持，来支持node的语法提示； 用npm命令配置到package.json里； 1$ npm install --save-dev @types/node webstorm1file-&gt;settings-&gt;Node.js and NPM -&gt;coding assistance-&gt;enable npmnpm是nodejs自带的包管理工具，用于下载和管理工具包，并配置到config.json文件中； 更新1$ npm i npm@latest -g npm相关配置12# 【查看默认配置】$ npm config ls 配置全局安装目录1&gt; 为prefix指定一个本地目录：1$ npm config set prefix E:\pathName 2&gt; 配置环境变量 1windows系统在环境变量path中追加E:\ProgramFile\dev\nodejs\npm_global_modules 配置国内镜像不推荐配置，配置镜像后有些包下载不下来 还原默认镜像地址npm默认的配置如下，如果配置了一些国内镜像后，下载包出问题，请设置默认配置：1234# 【registry】$ npm config set registry https://registry.npmjs.org/# 【distUrl】$ npm config set disturl undefined config.jsonnpm命令生成config.json文件： 12// 命令生成，会有一些配置，按提示默认填写即可；$ npm init config.json配置文件内容： 123456789101112131415161718&#123; &quot;name&quot;: &quot;webtechstack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;test&quot;, // dependencies里的插件是需要发布到生产环境的。 &quot;dependencies&quot;: &#123;&#125;, // devDependencies里的插件只用于开发环境，不用于生产环境。 &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot; &#125;, // 使用npm run x执行的脚本 &quot;scripts&quot;: &#123;&#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://gitee.com/cnlius/WebTechStack.git&quot; &#125;, &quot;author&quot;: &quot;jason&quot;&#125; 包安装命令 npm可以安装的工具包可在npmjs网站搜索； npm命令安装工具包,一般安装的工具包信息会配置到config.json文件的dependencies（会发布到生产环境）配置项或devDependencies（仅用于开发环境）配置项。 安装最新版本的工具包，如安装koa工具包 1234567891011// 写法一：// 安装到dependencies：$ npm install koa --save// 安装到devDependencies：$ npm install koa --save-dev// 写法二：// 安装到dependencies：$ npm install --save koa // 安装到devDependencies：$ npm install --save-dev koa 安装指定版本的工具包： 1$ npm install --save koa@2.8.1 简写命令123npm i 简写为：npm install--save 简写为：-S；--save-dev 简写为：-D； yarn包管理Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 安装与更新1234//npm安装yarn$ npm install -g yarn//npm更新yarn$ npm install yarn@latest -g npm相关配置12# 【查看默认配置】$ yarn config ls 配置国内镜像不推荐配置，配置镜像后有些包下载不下来 还原默认镜像地址yarn默认的配置如下，如果配置了一些国内镜像后，下载包出问题，请设置默认配置：1234# 【registry】$ yarn config set registry https://registry.yarnpkg.com# 【distUrl】$ yarn config set disturl undefined 常用命令12345678910111213//初始化package.json文件（=npm init）$ yarn init//安装package.json文件配置的工具包到node_module(=npm install)$ yarn//对比npm://安装工具库$ yarn global add x@v.v.v // npm i x@v.v.v -g$ yarn add x@v.v.v // npm i x@v.v.v --save$ yarn add x@v.v.v --dev // npm i x@v.v.v --save-dev//卸载工具库$ yarn remove x //npm uninstall x --save(-dev)//执行package.json文件的script脚本配置项$ yarn run x // npm run x nodejs简介在命令行模式下，可以执行node进入Node交互式环境，也可以执行node hello.js运行一个.js文件。 执行js文件node命令可以直接执行一个已经写好的js文件； 1$ node hello.js node命令行输入node命令，会进入nodejs命令行交互环境，此模式下可以直接执行js代码。 模块CommonJs规范 模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突。 模块加载实质模块加载，实际上是将代码包装到了匿名函数内部，所以模块之间成员名互不冲突。 12345678(function () &#123; // 读取的hello.js代码: var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); // hello.js代码结束&#125;)(); 导入导出模块可以导出一些成员，提供给其他模块导入使用； 导入1var greet = require('./hello'); 导出方法1：module.exports赋值（推荐）； 1可以直接对module.exports赋值； 1234567891011// hello.jsfunction hello() &#123; console.log('Hello, world!');&#125;function greet(name) &#123; console.log('Hello, ' + name + '!');&#125;module.exports = &#123; hello: hello, greet: greet&#125;; 方法二：直接使用exports; 123456789101112// hello.jsfunction hello() &#123; console.log('Hello, world!');&#125;function greet(name) &#123; console.log('Hello, ' + name + '!');&#125;function hello() &#123; console.log('Hello, world!');&#125;exports.hello = hello;exports.greet = greet; 123456【注意】不可以直接对exports赋值，类似下面这样是不允许的：exports = &#123; hello: hello, greet: greet&#125;; 综合示例以下hello模块导出成员提供给world模块使用； hello.js模块 123456'use strict';let title = 'Hello';function greet(name) &#123; console.log(title + ', ' + name + '!');&#125;module.exports = greet; world.js模块 12345'use strict';// 引入hello模块:let greet = require('./hello');let name='world';greet(name); 基本模块global JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。 node.js环境中也有一个全局对象叫global。 console1node命令行输入global.console会直接打印出所有控制台输出方法； 文件相关 __dirname：全局变量，存储的是文件所在的文件目录； __filename：全局变量，存储的是全路径文件名； process process也是Node.js提供的一个对象，它代表当前Node.js进程。 通过process对象可以拿到node运行环境信息. 1234567891011&gt; process === global.process;true&gt; process.version; //node.js的版本&apos;v5.2.0&apos;&gt; process.platform; //当前运行的系统平台&apos;darwin&apos;&gt; process.arch; //当前系统平台架构&apos;x64&apos;&gt; process.cwd(); //返回当前工作目录&apos;/Users/michael&apos;&gt; process.env.NODE_ENV //node的运行环境，NODE_ENV可能是undefined，所以仅用值production用来判断是否是生产环境； 相关方法nextTickprocess.nextTick()：不是立刻执行，而是要等到下一次事件循环执行，nodejs会把此方法的逻辑放到任务队列最后，等到任务执行完成再执行。 1231&gt; process.nextTick()方法是将某个逻辑插入到当前循环任务队列的末尾，早于setTimeout(function()&#123;&#125;,0)执行。2&gt; 可以理解为setTimeout 0是在下次循环开始，而process.nextTick结束后本次循环才完成。3&gt; Promise.resolve()是在process.nextTick之后执行的。 12345678910// test.js// process.nextTick()将在下一轮事件循环中调用:process.nextTick(function () &#123; console.log('nextTick callback!');&#125;);console.log('nextTick was set!');/* 输出：nextTick was set!nextTick callback!*/ 进程事件回调 程序即将退出时的回调； 123process.on('exit', function (code) &#123; console.log('about to exit with code: ' + code);&#125;); js运行环境 很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断： 12345if (typeof(window) === 'undefined') &#123; console.log('node.js');&#125; else &#123; console.log('browser');&#125; 异步文件操作库mzmz仓库地址 介绍mz提供的API和Node.js的fs模块完全相同，但fs模块使用回调，而mz封装了fs对应的函数，并改为Promise。这样，我们就可以非常简单的用await调用mz的函数，而不需要任何回调。 API 判断文件是否存在：fs.exists(filename) 文件模块 Node.js内置的fs模块就是文件系统模块，负责读写文件。 fs模块同时提供了异步和同步的方法； fs模块fs模块引用:1let fs = require('fs'); 文件相关APIBuffer对象 多用于表示二进制文件； Buffer对象和String作转换： 123// Buffer -&gt; Stringvar text = data.toString('utf-8');console.log(text); 123// String -&gt; Buffervar buf = Buffer.from(text, 'utf-8');console.log(buf); 文件信息 fs.stat()，返回一个Stat对象，用于同步获取文件信息； fs.statSync(),返回一个Stat对象，用于同步获取文件信息； stat属性 是否是文件：stat.isFile(); 是否是目录：stat.isDirectory(); 文件大小：stat.size; 创建时间(Date对象)：stat.birthtime; 修改时间(Date对象)： stat.mtime; 示例123456789101112131415161718192021222324252627let fs = require('fs');fs.stat('data.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); console.log('年：'+stat.mtime.getFullYear()); &#125; &#125;&#125;);/*结果如下：isFile: trueisDirectory: falsesize: 12birth time: Thu May 17 2018 17:46:35 GMT+0800 (中国标准时间)modified time: Thu May 17 2018 18:22:49 GMT+0800 (中国标准时间)2018*/ 文件的读写同步和异步读写 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 异步读文件123异步读取时，回调函数接收两个参数：第一个参数代表错误信息，第二个参数代表结果。1&gt; 当正常读取时，err参数为null，data参数为读取到的String。2&gt; 当读取发生错误时，err参数代表一个错误对象，data为undefined。 读取文本文件12345678let fs = require('fs');fs.readFile('data.txt', 'utf-8', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 读二进制文件 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。 Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）； 123456789let fs = require('fs');fs.readFile('image.jpg', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); 同步读文件 除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 同步读取文件需要用try…catch捕获该错误； 12345678let fs = require('fs');try &#123; var data = fs.readFileSync('sample.txt', 'utf-8'); console.log(data);&#125; catch (err) &#123; // 出错了 console.log(err);&#125; 异步写文件 writeFile创建并写入文件； writeFile()的参数依次为：文件名、数据和回调函数。 123- writeFile传入的参数如果数据是String，默认按UTF-8编码写入文本文件；- 如果传入的参数是Buffer，则写入的是二进制文件。- 回调函数由于只关心成功与否，因此只需要一个err参数。 123456789let fs = require('fs');var data = 'how are you!';fs.writeFile('data.txt', data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('ok.'); &#125;&#125;); 同步写文件 writeFileSync()用于同步写文件； 1234'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFileSync('output.txt', data); 文件目录fs提供读取文件目录下所有文件的方法，同读文件类似，提供了同步和异步，方法将返回一个包含“指定目录下所有文件名称”的数组对象。； fs.readdir(path)：异步读； fs.readdirSync(path)：同步读； stream stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 流的方式读写文件是一点一点儿处理文件，用过的部分会被GC，所以占内存少。 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 流API读写流都通过fs模块来创建； 创建读取流：fs.createReadStream(path,options); 12注意：options可以配置highWaterMark设置读取流的缓冲区大小，单位字节；let rs = fs.createReadStream(&apos;data.txt&apos;,&#123;highWaterMark:3,encoding:&apos;utf-8&apos;&#125;); 创建写入流：fs.createWriteStream(path,options); 流处理回调流对象的处理回调事件： data事件表示流的数据已经可以读取了，data事件回调可能会有很多次； end事件表示这个流已经到末尾了，没有数据可以读取了； error事件表示出错了； 示例读流123456789101112131415'use strict';var fs = require('fs');// 打开一个流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;); 写流123456789101112'use strict';var fs = require('fs');var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end(); pipe一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 读写文件 pipe管道完成读写文件的过程，实际上是文件复制的过程； 123456'use strict';let fs = require('fs');let rs = fs.createReadStream('sample.txt');let ws = fs.createWriteStream('copied.txt');rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;); httpNode.js自带的http模块对http请求解析，http模块提供的request和response对象和http协议进行通信。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 相关APIrequest response对象本身是一个Readable Stream; 属性 url: 请求地址； response response对象本身是一个Writable Stream; URL模块解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 123456789101112131415161718192021'use strict';var url = require('url');console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));/*结果如下：Url &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' &#125;*/ 文件路径模块处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录： 12345678'use strict';var path = require('path');// 解析当前文件目录:var workDir = path.resolve('.'); // '/Users/michael'// 文件路径组合: 当前目录+'pub'+'index.html':var filePath = path.join(workDir, 'pub', 'index.html');// '/Users/michael/pub/index.html' HTTP服务器一个简单的http服务器，通过http.createServer(function(request,response))方法创建; 12345678910111213141516171819// 导入http模块:var http = require('http');var url = require('url');// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; var urlInfo = url.parse(request.url, true); // 根据请求url的相对路径来处理请求的逻辑 if(urlInfo.pathname === '/test') &#123; // 将HTTP响应200写入response response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 将HTTP响应的HTML内容写入response: response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;'); &#125;&#125;).listen(8080);// 让服务器监听8080端口://server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); server server支持链式调用； 方法 listen(x): server监听的端口； 文件服务器简单的http服务器处理文件：1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';var fs = require('fs'), url = require('url'), path = require('path'), http = require('http');// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || '.');console.log('Static root dir: ' + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(request.url).pathname; console.log("url: "+request.url); console.log("pathname: "+pathname); // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log('200 ' + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); &#125; &#125;);&#125;);server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); http请求 nodejs的http模块可以直接发送网络请求，请求外部服务器； http模块提供post或者是get方法来发起网络请求； 查询的参数配置，使用queryString模块； queryString模块queryString用作http请求查询参数；12345var querystring = require('querystring');var postData = querystring.stringify(&#123; 'param1' : 'test', 'param2':'1'&#125;); GET get请求: options是带参数的全路径 12345678910111213141516var http = require('http');http.get('http://v.juhe.cn/weixin/query?key=f16af393a63364b729fd81ed9fdd4b7d&amp;pno=1&amp;ps=10', function (response) &#123; var body = []; console.log(response.statusCode); console.log(response.headers); console.log(response); response.on('data', function (chunk) &#123; body.push(chunk); &#125;); response.on('end', function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;); 单独配置查询参数的get请求 12345678910111213141516171819202122232425262728293031323334353637383940var queryString = require('querystring');var http = require('http');var params = queryString.stringify(&#123; key : 'f16af393a63364b729fd81ed9fdd4b7d', pno:1, ps:10&#125;);var options = &#123; hostname: 'v.juhe.cn', path: '/weixin/query?'+params, method: 'GET', headers: &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;&#125;;var req = http.get(options, (res) =&gt; &#123; console.log(`STATUS: $&#123;res.statusCode&#125;`); console.log(`HEADERS: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding('utf8'); // 设置读取的大小 res.read(1024*1024*111); res.on('data', (chunk) =&gt; &#123; console.log("----------request data-----------"); console.log(`BODY: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log("----------request end-----------"); &#125;)&#125;);req.on('error', (e) =&gt; &#123; console.error(e);&#125;);req.end(); POSTpost请求带参数，需要用write将请求参数写入才能完成请求； 1234567891011121314151617181920212223242526272829303132333435363738394041424344var http = require('http');var querystring = require('querystring');var postData = querystring.stringify(&#123; 'key' : 'f16af393a63364b729fd81ed9fdd4b7d', 'pno':'1', 'ps':10&#125;);var options = &#123; hostname: 'v.juhe.cn', path: '/weixin/query', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(postData) &#125;&#125;;var req = http.request(options, (res) =&gt; &#123; console.log(`STATUS: $&#123;res.statusCode&#125;`); console.log(`HEADERS: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding('utf8'); // 设置读取的大小 res.read(1024*1024*111); res.on('data', (chunk) =&gt; &#123; console.log("----------request data-----------"); console.log(`BODY: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log("----------request end-----------"); &#125;)&#125;);req.on('error', (e) =&gt; &#123; console.log(`problem with request: $&#123;e.message&#125;`);&#125;);// 需要写入请求参数，才能执行请求req.write(postData);req.end(); 加解密Nodejs用C/C++实现通用的加密和哈希算法通过cypto模块暴露为js接口，运行速度快。 MD5和SHA1MD5和sha1是常用的哈希算法，用于给任意数据一个“签名”，签名结果通常用一个十六进制的字符串表示； update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把’md5’改成’sha1’，还可以使用更安全的sha256和sha512。 12345678const crypto = require('crypto');const hash = crypto.createHash('md5');// 可任意多次调用update():hash.update('Hello, world!');hash.update('Hello, nodejs!');console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544 Hmac Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥; 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 123456const crypto = require('crypto');const hmac = crypto.createHmac('sha256', 'secret-key');hmac.update('Hello, world!');hmac.update('Hello, nodejs!');console.log(hmac.digest('hex')); // 80f7e22570... AES AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用; AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。 加密结果通常有两种表示方法：hex和base64。 AES加密，加解密秘钥的创建createCipher、createDecipher方法在新的API中废弃，推荐使用createCipheriv，createDecipheriv来创建加解密秘钥；123createCipheriv(algorithm: string, key: any, iv: any)【参数说明】- iv：表示一个初始向量，aes-256-gcm是一个8位的Buffer或字符串； aes192123456789101112131415161718192021222324252627282930313233343536373839const crypto = require('crypto');/** * AES加密 * @param data * @param key * @returns &#123;string&#125; */function aesEncrypt(data, key) &#123; // 秘钥 const cipher = crypto.createCipher('aes192', key); let encrypted = cipher.update(data, 'utf8', 'hex'); // 加上剩余的加密内容 encrypted += cipher.final('hex'); return encrypted;&#125;/** * AES解密 * @param encrypted * @param key * @returns &#123;string&#125; */function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher('aes192', key); let decrypted = decipher.update(encrypted, 'hex', 'utf8'); decrypted += decipher.final('utf8'); return decrypted;&#125;var data = 'Hello';var key = 'Password!';var encrypted = aesEncrypt(data, key);var decrypted = aesDecrypt(encrypted, key);console.log("打印支持的cipher算法："+crypto.getCiphers());console.log('old text: ' + data);console.log('Encrypted text: ' + encrypted);console.log('Decrypted text: ' + decrypted); aes-256-gcmAES加密使用gcm加密算法时， 需要cipher.getAuthTag()在cipher.final()方法完全加密后调用,获取加密秘钥的tag，解密前用decipher.setAuthTag给解密秘钥设置这个tag； key长度 aes-256-gcm/aes-128-gcm/aes-192-gcm算法的key长度是256或128或192除以8； 12345678910111213141516171819202122232425262728var crypto = require('crypto');var algorithm = 'aes-256-gcm';var password = '3zTvzr3p67VC61jmV54rIYu1545x4TlY';var iv = crypto.randomBytes(8);function encrypt(text) &#123; var cipher = crypto.createCipheriv(algorithm, password, iv); var encrypted = cipher.update(text, 'utf8', 'hex'); encrypted += cipher.final('hex'); var tag = cipher.getAuthTag(); return &#123; content: encrypted, tag: tag &#125;;&#125;function decrypt(encrypted) &#123; var decipher = crypto.createDecipheriv(algorithm, password, iv); decipher.setAuthTag(encrypted.tag); var dec = decipher.update(encrypted.content, 'hex', 'utf8'); dec += decipher.final('utf8'); return dec;&#125;var hw = encrypt("hello world");// outputs hello worldconsole.log(decrypt(hw)); Diffie-HellmanDH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。123456789101112131415161718192021222324const crypto = require('crypto');// xiaoming's keys:var ming = crypto.createDiffieHellman(512);var ming_keys = ming.generateKeys();// 素数var prime = ming.getPrime();var generator = ming.getGenerator();console.log('Prime: ' + prime.toString('hex'));console.log('Generator: ' + generator.toString('hex'));// xiaohong's keys:var hong = crypto.createDiffieHellman(prime, generator);var hong_keys = hong.generateKeys();// exchange and generate secret:var ming_secret = ming.computeSecret(hong_keys);var hong_secret = hong.computeSecret(ming_keys);// print secret:console.log('Secret of Xiao Ming: ' + ming_secret.toString('hex'));console.log('Secret of Xiao Hong: ' + hong_secret.toString('hex')); 操作数据库mysql目前使用最广泛的MySQL Node.js驱动程序是开源的node-mysql，可以直接使用npm安装。 注意：目前最新的sequelize不支持mysql库，支持mysql2 安装1$ npm install mysql --save 简单使用1234567891011121314151617181920212223242526272829303132var mysql = require('mysql');// 1. 创建数据库连接var connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : '******', database : 'db_test', port : 3306&#125;);//2.连接数据库//connection.connect();connection.connect(function(err) &#123; if (err) &#123; console.error('error connecting: ' + err.stack); return; &#125; console.log('connected ' + connection.threadId);&#125;);//3.执行sql语句connection.query('SELECT * FROM `user`', function (error, results, fields) &#123; if (error) throw error; console.log(results);&#125;);//4.关闭连接（end方法会确保执行完此前的所有查询）//connection.end();connection.end(function(err) &#123; if (err) &#123; console.error('end error connecting: ' + err.stack); return; &#125; console.log('end connected ' + connection.threadId);&#125;); 连接配置在建立新连接时，可以设置以下参数：123456789101112131415161718- host：连接的数据库地址。（默认:localhost）- port：连接地址对应的端口。（默认:3306）- localAddress: 源IP地址使用TCP连接。（可选）- socketPath:当主机和端口参数被忽略的时候，可以填写一个Unix的Socket地址。- user: mysql的连接用户名。- password: 对应用户的密码。- database: 所需要连接的数据库的名称。（可选）- charset: 连接的编码形式。这就是mysql中的整理。（例如：utf8_general_ci）如果被指定，则作为默认的整理排序规则。（默认：utf8_general_ci）- timezone:用来保存当前本地的时区。（默认：local）- connectTimeout: 设置在连接的时候，超过多久以后未响应则返回失败。（默认：10000）- stringifyObjects: stringify对象代替转换值。issue# 501。（默认：false）- insecureAuth：使用旧（不安全）的连接方式去连接MySQL。（默认：false）- typeCast: 确定列值是否需要转换为本地JavaScript类型。（默认：true）- queryFormat:自定义查询的方式。地址：Custom format.- supportBigNumbers: 如果你使用了BIGINT和DECIMAL格式的表列，那么需要开启这个参数来支持。（默认：false）只有当他们超过JavaScript所能表达的最长的字节的时候，如果没有设置这个参数，则会将过长的数字作为字符串传递。否则，返回对象的长度。如果supportBigNumbers参数被忽略，则这个参数也会被忽略。- dateStrings:一些日期类型(TIMESTAMP, DATETIME, DATE)会以Strings的类型返回，然后转换成JavaScript的日期对象。（默认：false）- debug:是否把连接情况打印到文件。（默认：false）- trace: 生成错误的堆栈跟踪，包括库入口的调用位置（“长堆栈的轨迹”）。一般会造成轻微的性能损失。（默认：true） 终止连接终止连接有两种方式： 调用end()方法，安全，可以确保此前的操作完成，该方法可以有回调函数作参数； 调用destroy()，立即终止销毁连接，不安全，此前的操作可能还没执行，该方法没有回调参数； 12345connection.end(function(err) &#123; // 连接终止&#125;);connection.destroy(); 连接池使用连接池连接可以更容易地共享某个连接，也可以管理多个连接。 当连接完成后，调用connection.release()方法使连接返回到连接池，以便其他人可以再次使用。 如果你想关闭连接并从连接池中删除它，就要使用connection.destroy()方法。在下次需要时连接池会再创建一个新的连接。 当从连接池中恢复之前的某个连接时，会给服务器发送一个ping包以检查连接是否正常。 参数配置接受所有与connection相同的配置参数，除此配置外，连接池还支持一些额外的参数： acquireTimeout（获取超时时间）: 获取连接时，触发连接超时之前的毫秒数。这与connectTimeout略有不同，因为从连接池获取连接并不总会创建连接 （默认值：10000） waitForConnections(连接等待时间）: 当无连接可用或连接数达到上限的时候，判定连接池动作。如果为true，连接池会将请求加入队列，待可用之时再触发操作；如为false，连接池将立即返回错误 （默认值：true) connectionLimit(连接数限制): 所允许立即创建的最大连接数量 (默认值: 10) queueLimit（队列数量限制）: 在调用getConnection返回错误之前，连接池所允许入队列的最大请求数量。如设置为0， 则不限制。 (默认值: 0) 事件连接池事件： 123456789101112131415161718192021222324//获取连接pool.on(&apos;acquire&apos;, function (connection) &#123; console.log(&apos;Connection %d acquired&apos;, connection.threadId);&#125;);//连接事件pool.on(&apos;connection&apos;, function (connection) &#123; connection.query(&apos;SET SESSION auto_increment_increment=1&apos;)&#125;);//队列中等待可用连接pool.on(&apos;enqueue&apos;, function () &#123; console.log(&apos;Waiting for available connection slot&apos;);&#125;);//连接释放回池pool.on(&apos;release&apos;, function (connection) &#123; console.log(&apos;Connection %d released&apos;, connection.threadId);&#125;);//连接池中关闭所有连接:一旦pool.end()被调用，pool.getConnection及其它操作将不再被执行！pool.end(function (err) &#123; // all connections in the pool have ended&#125;); 使用123456789101112131415161718192021222324252627var mysql = require('mysql');var pool = mysql.createPool(&#123; connectionLimit : 10, host : 'localhost', user : 'root', password : 'gogogo15820', database : 'db_test', port : 3306&#125;);// 直接用pool查询pool.query('SELECT * FROM user', function(err, results, fields) &#123; if (err) throw err; console.log(results);&#125;);// 使用共享连接查询pool.getConnection(function(err, connection) &#123; connection.query('SELECT * FROM user ORDER BY ??','create_time',function (error, results, fields) &#123; // 释放连接回连接池 connection.release(); // 销毁连接 // connection.destroy(); if (error) throw error; console.log(results); &#125;);&#125;); 连接池集群详情见官方文档 sql防注入转义为了防止SQL注入，每当需要在SQL查询中使用用户数据时，应该对查询相关信息进行转义。 查询值转义 占位符转义：将查询的值用?占位； escape转义：通过mysql.escape(), connection.escape()或pool.escape()方法参数传入查询值(注意：pool只能用于线程池建立的连接); 不同类型的值转义区别12345678910- 数字不会被转义- 布尔值会被转移成 true / false- Date 对象会被转义成形如 &apos;YYYY-mm-dd HH:ii:ss&apos; 的字符串- Buffer 会被转义成十六进制字符串，如： X&apos;0fa5&apos;- 字符串会被安全地转义- 数组会被转义成列表，例如： [&apos;a&apos;, &apos;b&apos;] 会被转义成 &apos;a&apos;, &apos;b&apos;- 嵌套数组会被转义成多个列表（在大规模插入时），如： [[&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;]] 会被转义成 (&apos;a&apos;, &apos;b&apos;), (&apos;c&apos;, &apos;d&apos;)- 对象的所有可遍历属性会被转义成键值对。如果属性的值是函数，则会被忽略；如果属性值是对象，则会使用其 toString() 方法的返回值。- undefined / null 会被转义成 NULL- NaN / Infinity 将会被原样传入。由于MySQL 并不支持这些值，在它们得到支持之前，插入这些值将会导致MySQL报错。 占位符转义值查询的值用?作为查询值得占位符 注意：sql语句中的任何?，包括注释和字符串都会被转义替换； 1234connection.query('SELECT * FROM user WHERE id=?', 2,function (error, results, fields) &#123; if (error) throw error; console.log(results);&#125;); escape转义值注入示例 1234connection.query('SELECT * FROM user WHERE id=?', ['2 or id=3'],function (error, results, fields) &#123; if (error) throw error; console.log(results);&#125;); mysql.escape(), connection.escape()或pool.escape()防注入写法都类似： 1234connection.query('SELECT * FROM user WHERE id='+connection.escape('2 or id=3'),function (error, results, fields) &#123; if (error) throw error; console.log(results);&#125;); 查询标识转义如果用户提供了不可信的查询标识（数据库名、表名、列名），需要转义： 用mysql.escapeId(identifier), connection.escapeId(identifier) 或 pool.escapeId(identifier) 方法对它进行转义； 1234connection.query('SELECT * FROM user ORDER BY' + connection.escapeId('create_time'),function (error, results, fields) &#123; if (error) throw error; console.log(results);&#125;); 用 ?? 作为占位符来替代你想要转义的标识： 1234connection.query('SELECT * FROM user ORDER BY ??','create_time',function (error, results, fields) &#123; if (error) throw error; console.log(results);&#125;); SequelizeSequelize是一个基于promise的Node.js ORM,目前支持Postgres,MySQL, SQLite和Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 读取和复制等功能. 参考中文文档 博客整理文档 安装 注意sequelize 4.x使用的是mysql2 安装： 12345$ npm install --save sequelize$ npm install --save-dev @types/sequelize//需要mysql2$ npm install --save mysql2$ npm install --save-dev @types/mysql2 特性 ORM全称Object-Relational Mapping，即对象关系映射，可以把关系数据库的表结构映射到对象上。 支持原始sql查询; sequelize操作数据库返回的是promise对象，所有可以使用promise的特性写法，也可以使用ES7的async写法配合koa2使用； 连接数据库Sequelize将在初始化时设置连接池： 单个进程连接到数据库，你最好每个数据库只创建一个实例。 多个进程连接到数据库，则必须为每个进程创建一个实例，但每个实例应具有“最大连接池大小除以实例数”的最大连接池大小。 因此，如果您希望最大连接池大小为90，并且有3个工作进程，则每个进程的实例应具有30的最大连接池大小。 定义config.js文件配置数据库信息： 1234567module.exports = &#123; database: 'db_test', // 使用哪个数据库 username: 'root', // 用户名 password: '******', // 口令 host: 'localhost', // 主机名 port: 3306 // 端口号，MySQL默认3306&#125;; 创建数据库连接： 1234567891011121314151617181920212223242526const Sequelize = require('sequelize');var mysql = require('mysql');const config = require('./config');// 可以简单地使用 uri 连接// const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname');const sequelize = new Sequelize(config.database, config.username, config.password, &#123; host: config.host, dialect: 'mysql', pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000 &#125;&#125;);// 测试连接是否成功sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.'); &#125;) .catch(err =&gt; &#123; console.error('Unable to connect to the database:', err); &#125;); 使用步骤 定义模型对象：定义数据表映射对象模型； 调用操作数据库的方法； 定义模型要定义模型和表之间的映射，请使用define方法。 Sequelize将自动添加createdAt和updatedAt属性； 语法12345sequelize.define(modelName, attributes, options)【参数】- modelName：模型名称；- attributes：成员属性定义；- options：可选设置； 示例123456789101112131415161718let User = sequelize.define('user', &#123; id: &#123; type: Sequelize.INTEGER, // INTEGER autoIncrement: true, //主键自增 primaryKey: true //主键 &#125;, name: Sequelize.STRING, // VARCHAR(255) sex: Sequelize.STRING, // VARCHAR(255) age: Sequelize.INTEGER, // INTEGER create_time: Sequelize.BIGINT // BIGINT&#125;, &#123; // orm自动增加时间戳，可以禁用,禁用后就不会自动插入createdAt和updatedAt时间 timestamps: false, //也可以手动隐藏创建和更新时间 // createdAt: false, // updatedAt: false, tableName: 'user' //表名称默认会加s, 这里可以设置最终的表名；&#125;); 操作数据库增加【语法】12模型对象.create(values?: TAttributes, options?: CreateOptions)模型对象.create(&#123;&#125;,&#123;&#125;); 【参数】 values：为模型的成员属性设置值； options：增加元素的设置； 1- files:[&apos;file_name&apos;] -&gt; 仅增加某条数据的某些字段； Promise方式ES6 Promise方式操作数据库1234567891011// promise方式操作数据库User.create(&#123; name: '李x龙', sex: '男', age: 33, create_time: new Date()&#125;,&#123; fields: [ 'name' ] &#125;).then(result =&gt; &#123; console.log(JSON.stringify(result));&#125;).catch(error =&gt; &#123; console.log(error.stack);&#125;); async异步方式ES7异步方式操作数据库:12345678(async () =&gt; &#123; await User.create(&#123; name:'李云龙', sex:'男', age: 33, create_time:'2018-02-01' &#125;);&#125;)(); 查询查询有两个方法： find: 查询单条数据； findAll: 查询多条数据； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 查询单个实例(async () =&gt; &#123; let user = await User.find(&#123; where: &#123; sex: '女' &#125; &#125;); console.log(user);&#125;)();//查询添加筛选条件(async () =&gt; &#123; let users = await User.findAll(&#123; //设置需要查询的字段，通过嵌套数组给查询的字段重命名（相当于sql中的as） attributes: [['id','userId'], 'name',[sequelize.fn('COUNT', //排除某些字段：attributes: &#123; exclude: ['baz'] &#125; sequelize.col('name')), 'nameCount']], //查询条件 where: &#123; name: '李云龙' &#125;, //id降序排序 order: [['id','DESC']], //分页设置，跳过2条数据，取5条数据 offset:2, limit:5 &#125;); console.log(`user count: $&#123;users.length&#125;`); for (let user of users) &#123; console.log(JSON.stringify(user)); &#125;&#125;)();//聚合函数查询(async () =&gt; &#123; let users = await User.findAll(&#123; //设置需要查询的字段是一个聚合函数，可以使用sql中的函数 attributes: [[sequelize.fn('COUNT', sequelize.col('name')), 'nameCount']], //查询条件 where: &#123; name: '李云龙' &#125; &#125;); console.log(`user count: $&#123;users.length&#125;`); for (let user of users) &#123; console.log(JSON.stringify(user)); &#125;&#125;)();//查询多少条记录(async () =&gt; &#123; let users = await User.count(&#123; where:&#123; name:'李云龙' &#125; &#125;); console.log(`user count: $&#123;users&#125;`);&#125;)(); 删除 删除单个 12345678(async () =&gt; &#123; let user=await User.find(&#123; where:&#123; id:1 &#125; &#125;); await user.destroy();&#125;)(); 批量删除 12345678(async () =&gt; &#123; let count=await User.destroy(&#123; where:&#123; name:'李云龙' &#125; &#125;); console.log(count);&#125;)(); 修改 修改单个实例 123456789(async () =&gt; &#123; let user = await User.find(&#123; where:&#123; id:16 &#125; &#125;); user.name='李寻欢'; await user.save();&#125;)(); 批量修改 12345(async () =&gt; &#123; let user = await User.update(&#123;sex:'女'&#125;,&#123; where:&#123;&#125; &#125;);&#125;)(); API常用方法Sequelize ORM对象方法： authenticate(): 测试连接是否成功； 12345sequelize .authenticate() .then(() =&gt; &#123; console.log('successfully.'); &#125;); 封装以项目根目录为当前目录： 创建config目录作为各种环境数据库配置文件存放目录，创建config-test.js文件用于测试环境的数据库配置，config-prod.js作为生产环境数据库配置： 1234567module.exports = &#123; database: 'db_test', // 使用哪个数据库 username: 'root', // 用户名 password: '', // 口令 ***** host: 'localhost', // 主机名 port: 3306 // 端口号，MySQL默认3306&#125;; 创建config.js文件用于判断加载哪个数据库配置文件： 12345678910const prodConfig = './config/config-prod.js';const testConfig = './config/config-test-db.js';var config = null;if (process.env.NODE_ENV === 'test') &#123; config = require(testConfig);&#125; else &#123; config = require(prodConfig);&#125;module.exports = config; 创建db.js文件，用于创建数据库连接和定义公共数据库映射模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const Sequelize = require('sequelize');const config = require('./config');console.log('init Sequelize...');/** * sequelize数据库连接配置 * @type &#123;sequelize.Sequelize | sequelize&#125; */const sequelize = new Sequelize(config.database, config.username, config.password, &#123; host: config.host, dialect: 'mysql', pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000 &#125;&#125;);/** * model模板 * @param name * @param attributes * @returns &#123;Model&#125; */function defineModel(name, attributes) &#123; //模板属性 let attrs = &#123;&#125;; for (let key in attributes) &#123; let value = attributes[key]; value.allowNull = value.allowNull || false; attrs[key] = value; &#125; //默认的字段 attrs.id = &#123; type: Sequelize.INTEGER, primaryKey: true &#125;; attrs.createdAt = &#123; type: Sequelize.BIGINT, allowNull: false &#125;; attrs.updatedAt = &#123; type: Sequelize.BIGINT, allowNull: false &#125;; attrs.version = &#123; type: Sequelize.BIGINT, allowNull: false &#125;; return sequelize.define(name, attrs, &#123; tableName: name, timestamps: false, //模型生命周期检查钩子 hooks: &#123; //操作数据库开始时设置默认字段 beforeValidate: function (obj) &#123; let date = new Date(); let seconds = date.getSeconds(); if (date.getSeconds() &lt; 10) &#123; seconds = '0' + date.getSeconds(); &#125; let curTime = date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate() + ' ' + date.getHours() + ':' + date.getMinutes() + ':' + seconds; //判断是否是新纪录 if (obj.isNewRecord) &#123; obj.createdAt = curTime; obj.updatedAt = curTime; obj.version = 0; &#125; else &#123; obj.updatedAt = curTime; obj.version++; &#125; &#125; &#125; &#125;);&#125;var db = &#123; defineModel: defineModel&#125;;module.exports = db; 创建models文件夹用于存放数据库操作模板,如：User.js: 1234567const Sequelize = require('sequelize');const db = require('../db');let User=db.defineModel('user', &#123; name: Sequelize.STRING(100)&#125;)module.exports =User; 可以选择性创建model.js文件，用来加载所有model文件夹的模板： 12345678910111213141516const fs = require('fs');//读models文件夹let files = fs.readdirSync(__dirname + '/models');let js_files = files.filter((f)=&gt;&#123; return f.endsWith('.js');&#125;);module.exports = &#123;&#125;;for (let f of js_files) &#123; console.log(`import model from file $&#123;f&#125;`); let name = f.substring(0, f.length - 3); module.exports[name] = require(__dirname + '/models/' + f);&#125; 操作数据库测试： 12345678const User = require('../models/User.js');(async () =&gt; &#123; let user = await User.create(&#123; name:'李二狗' &#125;); console.log(user);&#125;)(); WebSocketHTTP协议是一个请求-&gt;响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 HTML5推出了WebSocket标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。 WebSocket协议 浏览器发起请求： WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求。客户端浏览器建立WebSocket连接的http请求格式：1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 该请求和普通的HTTP请求有几点不同： 12341. GET请求的地址不是类似/path/，而是以ws://开头的地址；2. 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；3. Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；4. Sec-WebSocket-Version指定了WebSocket的协议版本。 服务器响应请求： 12345//101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string CS支持条件客户端（浏览器）-服务端支持WebSocket的条件； 浏览器要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下： Chrome Firefox IE &gt;= 10 Sarafi &gt;= 6 Android &gt;= 4.4 iOS &gt;= 8 服务器由于WebSocket是一个协议，服务器具体怎么实现，取决于所用编程语言和框架本身。Node.js本身支持的协议包括TCP协议和HTTP协议，要支持WebSocket协议，需要对Node.js提供的HTTPServer做额外的开发。已经有若干基于Node.js的稳定可靠的WebSocket实现，我们直接用npm安装使用即可。 WebSocket连接机制安全的WebSocket连接机制和HTTPS类似，首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。 ws模块在Node.js中，使用最广泛的WebSocket模块是ws。 ws模块GitHub地址 使用ws 安装ws: 1$ npm install --save ws 创建server端： 123456789// 导入WebSocket模块:const WebSocket = require('ws');// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; port: 3000&#125;); 创建client端： 12345678910111213const WebSocket = require('ws');let ws = new WebSocket('ws://localhost:3000/test');// 打开WebSocket连接后立刻发送一条消息:ws.on('open', function () &#123; console.log(`[CLIENT] open()`); ws.send('Hello!');&#125;);// 响应收到的消息:ws.on('message', function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`);&#125;); 至此一个CS形式的ws程序就可以运行了… ws和koa同一端口把WebSocketServer绑定到同一个端口的关键代码是先获取koa创建的http.Server的引用，再根据http.Server创建WebSocketServer； 浏览器创建WebSocket时发送的仍然是标准的HTTP请求。无论是WebSocket请求，还是普通HTTP请求，都会被http.Server处理； WS请求会直接由WebSocketServer处理； 实际上，3000端口并非由koa监听，而是koa调用Node标准的http模块创建的http.Server监听的。koa只是把响应函数注册到该http.Server中了。类似的，WebSocketServer也可以把自己的响应函数注册到http.Server中，这样，同一个端口，根据协议，可以分别由koa和ws处理，流程图如下： 绑定统一端口的关键代码如下： 12345678let server = app.listen(3000);// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; server: server&#125;); 识别用户身份把用户登录后的身份写入Cookie，在koa中，可以使用middleware解析Cookie，把用户绑定到ctx.state.user上。WS请求也是标准的HTTP请求，所以，服务器也会把Cookie发送过来，这样，我们在用WebSocketServer处理WS请求时，就可以根据Cookie识别用户身份。 配置反向代理如果网站配置了反向代理，例如Nginx，则HTTP和WebSocket都必须通过反向代理连接Node服务器。HTTP的反向代理非常简单，但是要正常连接WebSocket，代理服务器必须支持WebSocket协议。 我们以Nginx为例，编写一个简单的反向代理配置文件。 详细的配置可以参考Nginx的官方博客：Using NGINX as a WebSocket Proxy 首先要保证Nginx版本&gt;=1.3，然后，通过proxy_set_header指令，设定： 12proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection &quot;upgrade&quot;; Nginx即可理解该连接将使用WebSocket协议。 一个示例配置文件内容如下： 12345678910111213141516171819202122232425server &#123; listen 80; server_name localhost; # 处理静态资源文件: location ^~ /static/ &#123; root /path/to/ws-with-koa; &#125; # 处理WebSocket连接: location ^~ /ws/ &#123; proxy_pass http://127.0.0.1:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; &#125; # 其他所有请求: location / &#123; proxy_pass http://127.0.0.1:3000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;]]></content>
      <categories>
        <category>大前端</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-CentOS(阿里云)系统下搭建Git服务器]]></title>
    <url>%2F2016%2F12%2F17%2FGit%2FLinux-CentOS(%E9%98%BF%E9%87%8C%E4%BA%91)%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[文章概述： 本篇文章记录，在阿里云服务器Linux-CentOs系统下搭建Git服务器的具体实现步骤。 具体实现步骤1. 安装git 首先确认服务器是否安装Git在Xshell中输入命令：$ rpm -qa git结果如下表示已经安装： 如果未安装就安装git在Xshell中输入：$ yum install git 2. 创建一个git用户，用来运行git服务 在Xshell中输入：$ sudo adduser git此时在阿里云服务器的根目录：/home文件夹下新增一个文件夹git 按这个层级建立文件用于存放客户端用户的公钥：/home/git/.ssh/authorized_keys在本地客户端的git bash中通过命令： 1$ ssh-keygen -t rsa -C&quot;youremail@example.com&quot; 或1$ ssh-keygen 命令生成公钥，默认在c盘：用户/.ssh中id_rsa.pub文件是公钥，用记事本打开复制粘贴到服务器的/home/git/.ssh/authorized_keys文件中即可。 3. 服务器中建立git仓库 自己在服务器根目录新建一个专门用于存放仓库的git文件夹通过如下代码创建并初始化仓库,此时是以个空仓库：1$ sudo chown -R git:git sample.git 下一步代码必须执行一次，可能是获取推送权限并防止用户修改工作区，如果不执行的话无法从本地推送到git服务器：1$ sudo chown -R git:git sample.git 4. 禁止git用户登录shell出于安全考虑，创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：git:x:1001:1001:,,,:/home/git:/bin/bash改为：git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 5. 克隆git服务器上建立的sample.git仓库在本地git bash中通过命令定位到某个用于存放克隆文件的文件夹下，输入如下克隆命令：1$ git clone git@xxx.xxx.xxx.xxx:/xxx/git/sample.git 克隆服务器仓库命令的格式为：1git clone git@服务器公网IP:仓库存放于服务器的路径 6. 将本地git仓库与git服务器仓库关联 在本地新建并初始化一个sample仓库，需要和git服务器上的仓库名称相同。git服务器上建立的仓库为sample.git，本地的不用带.git。 服务器和本地的仓库都有了，通过以下步骤将两者关联起来：在本地git bash中定位到本地仓库，输入并执行下方代码： 1$ git remote add sample git@xxx.xxx.xxx.xxx:/xxx/git/sample.git 取消本地仓库与远程仓库关联，执行以下命令 1$ git romote remove origin 在git bash输入：$ git remote -v 可以查看本地git仓库相关联的远程git仓库。 在git bash输入：$ git push -u sample master 推送本地仓库主分支到远程git仓库，首次推送需要加-u。 以后推送直接用在git bash输入：$ git push sample master 即可。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bintray+AndroidStudio发布项目到maven和jcenter]]></title>
    <url>%2F2016%2F12%2F16%2FMaven%2FBintray%2BAndroidStudio%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0maven%E5%92%8Cjcenter%2F</url>
    <content type="text"><![CDATA[文章概述： 本篇文章记录，在Android Studio上，编译项目通过bintray发布到Maven仓库，并同步到Jcenter仓库。 bintray用户配置注册bintray账号在bintray官网注册账号 在官网最底下有个选项才是个人用户注册的入口，如图： 获取API KEY在用户中心，获取用户名和Api Key. bintray上创建项目新建一个maven仓库,然后添加项目 创建Android项目创建工程添加开源module创建工程，然后添加需要开源道bintray的library项目模块，在工程根目录build.gradle中添加bintray-release发布工具引用，和防止乱码配置，具体如下： 123456789101112131415161718192021222324252627buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.3&apos; classpath &apos;com.novoda:bintray-release:0.3.4&apos; &#125;&#125;allprojects &#123; repositories &#123; jcenter() mavenCentral() maven &#123; url &apos;https://dl.bintray.com/liusong/android&apos; &#125; &#125; //防止开源发版乱码问题 tasks.withType(Javadoc) &#123; options&#123; encoding &quot;UTF-8&quot; charSet &apos;UTF-8&apos; links &quot;http://docs.oracle.com/javase/8/docs/api&quot; &#125; &#125;&#125; 配置好后，gradle async 下载发布工具依赖库 开源库的配置在需要发布的moudle的gradle文件中配置发布信息 123456789101112131415apply plugin: 'com.android.library'apply plugin: 'com.novoda.bintray-release'...publish &#123; userOrg = 'liusong'//bintray.com用户名 repoName= 'android' //仓库名 groupId = 'com.liusong.android'//jcenter上的路径 artifactId = 'banner'//项目名称 publishVersion = '1.0.0'//版本号 desc = 'a banner library for android app'//描述，不重要 website = 'https://github.com/cnlius/android-banner'//网站 licences = ['Apache-2.0']&#125; 发布开源项目终端中执行发布到bintray的maven仓库命令1./gradlew clean build bintrayUpload -PbintrayUser=liusong -PbintrayKey=*************** -PdryRun=false 项目发布后会在bintray中看到相关信息，找到如下图的配置信息： 这个信息会在使用这个项目的时候需要。 注意：在maven仓库项目信息右下角有Add to Jcenter按钮，点击即可发布到Jcenter仓库上，可能需要点时间才能看到发布成功. 发布后的项目的使用 在开发的项目gradle添加依赖来中使用jcenter开源的项目： 12345dependencies &#123; // 格式 GROUP_ID:ARTIFACT_ID:VERSION //(具体值要参考上面提到的maven build settings项目配置信息) compile &apos;com.ls.library:library:1.0.1&apos;&#125; 如果项目没有添加到jcenter，则需要指明maven地址才能使用 12345678910repositories &#123; jcenter() //使用jcenter mavenCentral(); //使用maven //maven远程仓库地址 maven &#123; url &apos;https://dl.bintray.com/liusong/android&apos; &#125;&#125; dependencies &#123; compile &apos;com.liusong.android:banner:1.0.0&apos;&#125;]]></content>
      <categories>
        <category>Maven</category>
        <category>Bintray</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Bintray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Ultra-Pull-To-Refresh刷新框架与viewpager滑动冲突解决方案]]></title>
    <url>%2F2016%2F12%2F12%2FAndroid%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F%E5%86%85%E5%AE%B9%E5%88%B7%E6%96%B0%E6%A1%86%E6%9E%B6%2FAndroid-Ultra-Pull-To-Refresh%E5%88%B7%E6%96%B0%E6%A1%86%E6%9E%B6%E4%B8%8Eviewpager%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[文章概述： 本篇文章记录，解决github上开源框架android-Ultra-Pull-To-Refresh内嵌套viewpager的滑动冲突问题。 问题描述：liaohuqiu 开源的 android-Ultra-Pull-To-Refresh 下拉刷新框架，在使用时,会经常遇到嵌套banner的使用场景，即：子ViewGroup嵌套ViewPager使用，例如： 123456789101112131415161718192021222324&lt;com.vic.bmar.widgets.PtrClassicRefreshLayout android:id="@+id/pcfl_hot" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/grey_color" android:scrollbars="none"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;!-- 这里的FrameLayout用作放ViewPager的容器 --&gt; &lt;FrameLayout android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="160dp"/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/com.vic.bmar.widgets.PtrClassicRefreshLayout&gt; PtrClassicRefreshLayout是PtrFrameLayout的子类，默认实现了头部刷 新时的样式，可以直接拿来使用。 这时候会与ViewPager发生滑动冲突，ViewPager左右很难滑动，作者已经给出了一种解决方法: 12//左右滑动时刷新控件禁止掉pcflFrameLayout.disableWhenHorizontalMove(true); 这样做ViewPager可以左右滑动了，但是左右滑动有时还是不好滑动，并且，ViewPager滑动时经常会触发PtrFrameLayout的刷新样式，用户体验很差。 解决方案1. 重写ViewPager12345678910111213141516171819202122232425262728293031323334353637public class BannerViewPager extends ViewPager &#123; private ViewGroup parent; public BannerViewPager(Context context) &#123; super(context); parent= (ViewGroup) getParent(); &#125; public BannerViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); parent= (ViewGroup) getParent(); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: if (parent != null) &#123; //禁止上一层的View不处理该事件,屏蔽父组件的事件 parent.requestDisallowInterceptTouchEvent(true); &#125; break; case MotionEvent.ACTION_CANCEL: if (parent != null) &#123; //拦截 parent.requestDisallowInterceptTouchEvent(false); &#125; break; default: break; &#125; return super.dispatchTouchEvent(ev); &#125;&#125; 2. 重写PtrClassicRefreshLayout 这里为了方便，就不自定义刷新样式，直接使用PtrClassicRefreshLayout刷新样式，如果想重写刷新样式，可以继承PtrFrameLayout。 1234567891011121314151617181920212223242526272829303132333435363738public class PtrClassicRefreshLayout extends PtrClassicFrameLayout &#123; private boolean disallowInterceptTouchEvent = false; public PtrClassicRefreshLayout(Context context) &#123; super(context); &#125; public PtrClassicRefreshLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public PtrClassicRefreshLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; disallowInterceptTouchEvent = disallowIntercept; super.requestDisallowInterceptTouchEvent(disallowIntercept); &#125; @Override public boolean dispatchTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_UP: //解除刷新的屏蔽 this.requestDisallowInterceptTouchEvent(false); break; &#125; if (disallowInterceptTouchEvent) &#123; //事件向下分发给子控件，子控件会屏蔽掉父控件的刷新 return dispatchTouchEventSupper(e); &#125; return super.dispatchTouchEvent(e); &#125;&#125; 直接copy这两个自定义组件的代码使用，再加上作者推荐的设置： pcflFrameLayout.disableWhenHorizontalMove(true); 即可解决android-Ultra-Pull-To-Refresh下拉刷新框架与viewpager使用冲突问题.]]></content>
      <categories>
        <category>Android</category>
        <category>开源项目</category>
        <category>内容刷新框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源项目</tag>
        <tag>内容刷新框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2016%2F10%2F01%2FGit%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章为Git常用命令笔记。 配置用户用于提交的用户信息：用户名和邮箱； 命令： 12$ git config --global user.name &quot;cnlius&quot;$ git config --global user.email &quot;cnmrliu@163.com&quot; 重置登录校验有的时候电脑同时存在github和oschina两种或以上git仓库时，仅有一个支持免密码操作，其他的需要密码验证，如果输错密码或者用户名，之后就不会提示了，可以使用一下命令重置密码提示： 12//cmd管理员身份打开$ git config --system --unset credential.helper 本地分支管理123456查看分支：$ git branch创建分支：$ git branch &lt;name&gt;切换分支：$ git checkout &lt;name&gt;创建+切换分支：$ git checkout -b &lt;name&gt;合并某分支到当前分支：$ git merge &lt;name&gt;删除分支：$ git branch -d &lt;name&gt; 远程分支管理123456查看所有远程分支：$ git branch -a切换远程分支：$ git checkout -b branch_alias origin/branch_name查看关联的远程仓库：$ git remote -v 取消远程仓库关联：$ git remote remove origin添加远程仓库关联：$ git remote add origin http://xxx.git 标签管理123456789101112新建标签(会在当前分支时间点创建)：$ git tag &lt;name&gt;指定标签信息：$ git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;用PGP签名标签：$ git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;查看所有标签：$ git tag切换到某标签：$ git checkout tag_name 根据某标签创建分支：$ git checkout -b branch_name tag_name推送一个本地标签：$ git push origin &lt;tagname&gt;推送全部未推送过的本地标签：$ git push origin --tags删除一个本地标签：$ git tag -d &lt;tagname&gt;删除一个远程标签：$ git push origin :refs/tags/&lt;tagname&gt; 提交123456789101112131415推送当前到远程仓库：$ git push推送所有到远程仓库：$ git push --all更新远程仓库内容到本地：$ git pull首次推送分支到远程：$ git push -u origin master首次推送本地仓库所有分支到远程仓库：$ git push -u origin --all$ git push -u origin --tags查看提交历史：$ git log //会显示：提交id 提交人 提交时间$ git log --pretty=oneline //一行内显示: 提交id 提交注释 按提交历史回退：$ git reset --hard HEAD //将当前的版本回退到最新；$ git reset --hard HEAD[^|~]n //将当前的版本回退到倒数第n次提交；$ git reset --hard commitID //将当前的版本回退到某次提交commitID,将会彻底删除commitID之后所做的改动。$ git reset --soft commitID //将当前的版本回退到某次提交commitID,只删除commitID之后的提交记录log，代码的改动还在。 忽略文件12//有时.gitignore考虑不全，后期如果有不该提交的文件已经提交后，仅仅在.gitignore中加入忽略是不行的，还需要执行如下命令删除仓库中需要忽略的文件:$ git rm -r --cached filename 问题带空格目录git命令，进入带有空格的目录名？ 1、将Program Files目录用引号引起来。 1$ cd &quot;Program Files&quot; 2、将空格处使用空格引号 1$ cd Program&quot; &quot;Files]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5开发屏幕尺寸适配之rem]]></title>
    <url>%2F2016%2F04%2F02%2Fweb%2FCSS%2FH5%E5%BC%80%E5%8F%91%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E9%80%82%E9%85%8D%E4%B9%8Brem%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍H5开发屏幕尺寸适配之rem。 remrem用作字体、尺寸单位，1rem=浏览器默认font-size字体大小,即html根元素的font-size属性大小，大多数浏览器默认字体大小是16px。 em也是字体单位，但是1em相对大小是根据直接父元素的字体大小决定； px转rem可以是用sass，定义函数用来将px转rem: 1234567891011/** 以iphone6尺寸标准：px转rem */@function px2rem($px) &#123; //iphone6的宽度375px $rem: 37.5px; @return ($px / $rem) + rem;&#125;//使用时：p &#123; height: px2rem(40px);&#125; rem基准值的设置 一般rem根据大多数浏览器html元素的默认font-size计算：1rem=16px作为基准值。 rem基准值的设置有两种方案： 使用媒体查询: 枚举的方式，根据不同尺寸设置html的font-size； 使用js脚本: 根据viewport的width动态计算html的font-size; js脚本方式[推荐]使用js脚本的方式动态设置html的font-size如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;head&gt; &lt;!--定义viewport--&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; &lt;script type="text/javascript"&gt; /** 屏幕适配入口 */ let screenAdaptationFn = () =&gt; &#123; handleScreenAdaptation(); //监听可不要，因为适配只在第一次进入时设置即可 /** 根据视口宽高的变化动态设置rem基准值*/ window.addEventListener('resize', () =&gt; &#123; handleScreenAdaptation(); &#125;); &#125;; /** 处理屏幕适配 */ function handleScreenAdaptation()&#123; /** 设置视口viewport的缩放比 */ let scale = 1 / devicePixelRatio; let viewportDom = document.querySelector('meta[name="viewport"]'); viewportDom.setAttribute( 'content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no' ); /** 设置rem初始基准值*/ //获取视窗viewport的宽度； let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; //获取html元素 let htmlDom = document.getElementsByTagName('html')[0]; //根据宽度的小计算rem基准值： htmlDom.style.fontSize = htmlWidth / 10 + 'px'; &#125; &lt;/script&gt;&lt;/head&gt; 媒体查询方式根据需要，枚举不同的屏幕尺寸设置对应的基准值： !important提升此设置的优先级 12345678html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px !important;&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px !important;&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px !important;&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px !important;&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px !important;&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px !important;&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式布局知识点]]></title>
    <url>%2F2016%2F03%2F27%2Fweb%2FCSS%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍响应式布局知识点。 视口 用户能看到的页面可见区域就叫视口,用viewport表示。 响应式网站视口的设置标准： 普通屏幕的设置： 1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0,user-scalable=no""&gt; retina高清屏【推荐】 initial-scale设置0.5能更加精细识别1px; 1&lt;meta name="viewport" content="width=device-width,initial-scale=0.5,minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"&gt; 【视口属性注释】 width=device-width：样式中定义的宽度等于设备中定义的宽度； initial-scale=1.0：初始-比例，缩放比例1； minimum-scale=1.0：最大缩小比例1； maximum-scale=1.0：最大放大比例1； user-scalable=0(或no)：禁止使用者放大缩小; 动态设置视口在head中加入自动执行的函数，综合retina高分辨率屏和普通屏的dpr（devicePixelRatio）来动态设置视口viewport： 123456789101112131415&lt;head&gt;&lt;!--需要先设置viewport元素--&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt;&lt;!--定义自动执行函数--&gt;!function () &#123; //devicePixelRatio=物理设备实际像素/css可使用像素； let scale = 1 / devicePixelRatio; let viewportElement = document.querySelector('meta[name="viewport"]'); viewportElement.setAttribute( 'content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no' );&#125;();&lt;/head&gt; media query 媒体查询 CSS2允许用户对特定media类型制定样式。 CSS3提供了更加强大的功能：可以针对不同media类型设置样式，还根据设定的宽度或者高度指定样式。 语法格式123@media 媒体类型 and (媒体特性) &#123; //... css样式&#125; 媒体类型 screen: 适用于屏幕； print：适用于打印机； all：适用于所有的设备； tv：适用于电视类设备； projection(投射)：适用于投影图像,如幻灯片； screenscreen适用于显示的屏幕，在@media screen{}里设定的样式； print针对打印机，在@media print{}里设定的样式。 媒体特性 max-width: 最大宽度; min-width: 最小宽度； max-height：最大高度; min-height: 最小高度； 兼容性可以使用only关键字，当不支持media query的设备时会忽略media的配置： 123@media only screen and (color)&#123; //... css样式&#125; 使用媒体查询引入媒体查询有以下方式： 写在link标签里； 写在css样式里； 写在link标签里直接写在html头部的link标签里： 123&lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="" media="screen and (max-width: 320px)"&gt;&lt;/head&gt; 写在css样式里可以直接写在css样式里： 12345678html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px !important;&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px !important;&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px !important;&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px !important;&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px !important;&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px !important;&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass编译工具compass]]></title>
    <url>%2F2016%2F03%2F20%2Fweb%2FCSS%2Fsass%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7compass%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章介绍sass编译工具compass的使用。 compasscompass是一个开源的CSS创作框架。 安装compass也是基于ruby的，所以直接用gem安装命令如下： 1$ gem install compass 创建项目compass命令可以直接创建项目： 1$ compass create [project_name] compass项目基础 以下划线开头的命名的sass文件是局部文件，主要用来被其他的样式文件引用，在编译的时候不会被单独编译成css文件； config.rb文件用来配置项目； sass必须编译成css才会生效，编译方式如下： 1234//按需编译：$ compass complile [sass file path]//监听sass文件变化，自动编译：$ compass watch [sass file path] 可以将编译好的样式文件，引入html文件。 1234567&lt;head&gt; &lt;link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" /&gt; &lt;link href="/stylesheets/print.css" media="print" rel="stylesheet" type="text/css" /&gt; &lt;!--[if IE]&gt; &lt;link href="/stylesheets/ie.css" media="screen, projection" rel="stylesheet" type="text/css" /&gt; &lt;![endif]--&gt;&lt;/head&gt;]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass学习笔记]]></title>
    <url>%2F2016%2F03%2F13%2Fweb%2FCSS%2Fsass%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录sass的学习笔记。 sasssass基于Ruby语言开发而成，因此安装sass前需要安装Ruby。 中文网 安装sassruby环境自带包管理工具gem下载sass： 1$ gem install sass 注释 //：这种注释方式，不会被编译到css文件中，只能保留在源文件; /**/： 这种注释可以被编译到css文件中; 数据类型SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) 运算数学运算支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。 关系运算关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。 布尔运算支持布尔型的 and or 以及 not 运算。 颜色值运算 颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值: 123p &#123; color: #010203 + #040506;&#125; 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 123p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125; 字符串运算 +可用于连接字符串; 变量声明和使用 Scss语法支持使用变量，变量都以$符号开头； 变量的赋值与css一致； 变量使用时，可直接将变量名赋值给css属性； 变量命名推荐中划线分割单词； 通过#{}插值语句可以在选择器、属性名、字符串中使用变量； 123456789//定义$font-color: #ff637c;$sm-padding: 6px;//使用.main &#123; color: $font-color; padding-top: $sm-padding;&#125; 变量的操作 直接操作变量，即变量表达式； 121. 变量表达式支持：加减乘除、&gt;=、&lt;=、&gt;、&lt;、==、!=、();2. sass的数值计算可以带单位，但是单位不能混用； 通过函数操作： 12341. 跟代码块无关的函数，多是内置的函数，称functions;2. 可重用的代码块：mixin(混合器) 1&gt; mixin使用@include来调用； 2&gt; 通过@extend来调用； 变量管理可以定义变量代表默认的一些样式，这些变量集中存储到单独的scss局部文件,文件名以下划线开头(为局部文件,编译时不会打包到单独的css文件),在使用时用@import引用此文件(引用文件时，文件名不用加下划线)。 css嵌套规则 scss支持选择器嵌套使用,但是嵌套越深，css效率越低; 父选择器的标识符使用&amp;; 123456789101112131415161718192021222324//包含关系#content &#123; #contentChild &#123; background-color: #EEE &#125;&#125;//引用父类a &#123; //嵌套伪类时，需要用&amp;链接父类选择器； &amp;:hover &#123; color: red; &#125;&#125;//属性嵌套.content &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125; font: &#123; weight: bold; &#125;&#125; at-root指令防止多层选择器嵌套影响效率，可使用@at-root指令，将被修饰的选择器直接输出到当前样式表的顶层，提高了css效率。 导入外部样式文件sass样式支持导入外部sass文件，可以使用其中的变量、样式，导入方式有： 导入sass文件； 导入局部sass文件： 12- 不需要独立生成css文件的sass文件称&lt;span style=&quot;color:red&quot;&gt;局部sass文件&lt;/span&gt; color，只有在使用的时候才会引入，通常使用下划线作为前缀，样式表中引用时，只用引用下划线后面的文件名即可；- 局部sass文件：通常用来管理一些默认的样式、变量，可维护性高； 支持嵌套导入：即允许@import命令写在css规则内； 支持原生CSS文件导入：被导入文件的名字以.css结尾； 123456789//导入sass文件: _x.scss@import './path/x.scss';//导入原生css样式文件：@import './path/test.css';//嵌套导入.blue-theme &#123; @import "blue-theme"&#125; 优化建议 使用变量管理一些默认配置样式，用单独的局部sass文件进行管理； 自定义函数Sass支持自定义函数，并能在任何属性值或Sass script中使用，sass使用关键字@function来定义函数，使用@return关键字来返回函数的结果，如下是定义和调用的方式： 12345678910111213$grid-width: 40px;$gutter-width: 10px;//定义函数@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;//调用//简单调用：#sidebar &#123; width: grid-width(5); &#125;//关键词调用：#sidebar &#123; width: grid-width($n: 5); &#125; mixin混合器混合器用来封装公共的东西，提高代码质量； 概念定义：sass使用@mixin关键字来定义混合器，关键字@include来使用混合器，@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。 混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性; 12345678@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125; 语法定义 mixin混合器带参数时需要加括号，不带参数时不需要加； mixin混合器带参数时，可以设置默认值； 123@mixin test(arguments)&#123; //语句块&#125; mixin不带参数123456789101112//定义混合器@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125;//使用混合器：notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125; mixin带参数1234567891011//定义带参数混合器：@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;//使用a &#123; @include link-colors(blue, red, green);&#125; mixin参数默认值12345@mixin link-colors($normal,$hover: $normal,$visited: $normal)&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; mixin管理mixin常抽离到单独的文件，如_mixin.scss，来集中管理混合器； 选择器继承精简CSS选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现,示例代码如下: 123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 仅被继承选择器使用%修饰的样式选择器，不会被编译成单独的样式，这种选择器只能被继承， 12345678%success &#123; border: 1px solid red; background-color: #fdd;&#125;.perfectSuccess &#123; @extend %success; border-width: 3px;&#125; 条件控制指令SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用。 @if条件判断当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码，支持@else if和@else指令来辅助@if； 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; @for遍历@for指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。 语法格式@for指令包含两种格式： 1234//格式一：当使用through时，条件范围包含&lt;start&gt;与&lt;end&gt;的值；@for $var from &lt;start&gt; through &lt;end&gt;//格式二：使用to时条件范围只包含&lt;start&gt;的值不包含&lt;end&gt;的值；@for $var from &lt;start&gt; to &lt;end&gt; 123【注意】&gt; $var 可以是任何变量，比如 $i；&gt; &lt;start&gt; 和 &lt;end&gt; 必须是整数值。 @each遍历@each 指令的格式是 $var in , $var 可以是任何变量名，比如 $length 或者 $name，而 是一连串的值，也就是值列表。 123456//@each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如：@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; @while条件循环@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如： 12345$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 常用内置函数数据类型判断用于对数据类型判断： 12//判断变量类型是number;@if type-of($test) == number&#123;&#125; 单位操作 unitless($number)：判断一个值是否不带带位； unit($number)：返回一个值的单位 comparablecomparable($number-1, $number-2)用来判断两个值是否可以做加、减和合并。 sass使用media querysass中media query可以直接嵌套在css规则中，在生成css的时候，media query才会被提到样式的最高级，这样避免了重复书写选择器或者打乱样式表的流程。 参考日志输出指令sass提供@debug、@error、@warn来向控制台输出一段日志文字，用来表示错误信息，语法格式如下: 1@warn "this is warn";]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说ajax跨域]]></title>
    <url>%2F2016%2F03%2F06%2Fweb%2FJavaScript%2F%E7%BB%86%E8%AF%B4ajax%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章细说ajax跨域。 跨域跨域指的是web网站访问与自己域名不同的其它地址的请求； 实质跨域实质是浏览器安全验证限制了跨域请求； 1当浏览器发出跨域请求时，浏览器会在请求头中添加相关的跨域信息，经过服务器处理后，响应头里如果没有对应的跨域信息，将会发生跨域失败； 浏览器处理请求两种情况：简单请求和非简单请求； 浏览器在发送跨域请求时，对简单请求会直接执行，对非简单请求会先发出一个OPTION预检命令，校验通过后再执行请求； 简单请求 请求方法为：get/head/post 请求头里：无自定义头，Content-Type为：text/plain、multipart/form-data、application/x-www-form-urlencoded 非简单请求 put/delete方法的ajax请求； 发送json格式的ajax请求； 带自定义请求头的ajax请求； http请求处理流程请求从浏览器发出，请求到达http服务器（主要apache或nginx来处理），静态请求（如图片等）会被http服务器处理后直接返回，动态请求则会被转发到后台的应用服务（tomcat）来处理，处理完结果会发给http服务器，http服务器再转给浏览器。 产生跨域的条件以下三个条件同时发生时，才会发生跨域问题: 1&gt; 浏览器限制: 浏览器出于安全考虑，当发现你的请求跨域的时候，会主动做安全校验，如果校验不通过就会报跨域安全问题，如果后台没有任何限制，此时后台是接收到了请求并正确返回的，只是浏览器自身报错； 2&gt; 跨域； 服务器后台不允许前台调用； 3&gt; XHR(XMLHttpRequest)请求 浏览器发出的请求如果不是XHR请求，则不会进行安全验证，ajax默认发出的请求就是XHR请求； 前端跨域示例定义不同域的基本地址base,有以下几种跨域请求示例； 普通跨域请求123 $.getJSON(base + "/get").then(function (jsonObj) &#123; result = jsonObj;&#125;); jsonp123456789$.ajax(&#123; url: base + "/get", dataType: "jsonp", jsonp: "callback", cache: false, success: function (json) &#123; result = json; &#125;&#125;); 非简单请求跨域json格式请求，预检命令与缓存预检命令 12345678910$.ajax(&#123; type: "post", url: base + "/postJson", // 发送json类型的请求 contentType: "application/json;charset=utf-8", data: JSON.stringify(&#123;name: "jason"&#125;), success: function (json) &#123; result = json; &#125;&#125;); 带cookie跨域1234567891011$.ajax(&#123; type: "get", url: base + "/getCookie", //发送ajax请求会带cookie xhrFields: &#123; withCredentials:true &#125;, success: function (json) &#123; result = json; &#125;&#125;); 自定义请求头跨域123456789101112131415$.ajax(&#123; type: "get", url: base + "/getHeader", //添加请求头方式1: headers: &#123; "x-header1": "AAA" &#125;, //添加请求头方式2: beforeSend: function (xhr) &#123; xhr.setRequestHeader("x-header2", "BBB") &#125;, success: function (json) &#123; result = json; &#125;&#125;); 解决跨域的思路 客户端改动：让浏览器不做安全验证； 控制发出去的请求非XHR类型，JSONP方式通过动态创建script，在script中发出跨域请求，弊端是只能发Get请求； 实现跨域： 121&gt; 被调方（一般是服务端）做修改，支持跨域，被调用方通知调用方的浏览器跨域允许调用方跨域访问；2&gt; 调用方（一般是客户端）做修改，隐藏跨域，通过代理让浏览器发出去请求，都是网站本域域名，再在代理里面把发出的指定的url请求转到服务端域名里，浏览认为是在同一个域名里； 禁用浏览器限制解决跨域windows环境，cmd命令行进入打开chrome.exe文件路径，输入以下命令启动一个没有安全验证的chrome浏览器，即可跨域请求。 12$ chrome --disable-web-security --user-data-dir=f:\temp// 注：f:\temp为临时路径，存放chrome临时文件； Jsonp跨域发送非xhr类型的请求，浏览器不会做安全校验； 概述 Jsonp（json with padding） ,是json的补充使用方式，利用script标签请求资源可以跨域来解决跨域问题的。jsonp通过动态创建script，在script里面把请求发出的； 普通的ajax请求请求和返回的类型Content-Type是json，jsonp请求方式，是javascript; 改动范围：前后台都需要改动； 注意：Jsonp请求返回的数据结构是：callback的参数值作为函数名，返回的数据作为参数； 请求步骤 前端：jsonp的请求方式，默认自动给请求加了callback参数，后台发现有callback就认为是jsonp请求。 后台：ajax发送jsonp请求可以指定参数名，对应后台也需要修改，来识别对应的参数名； 前端发Jsonp请求123456789101112131415161718// 定义请求$.ajax(&#123; url: base + "/getCrossDomain", dataType: "jsonp", // 返回的参数类型 jsonp: "callback", // jsonp参数名 cache: false, //请求是否缓存 success: function (json) &#123; result = json; &#125;&#125;);//----------------------------------------------【浏览器发请求细节】// 请求参数 // _: 1527406132040 表示请求不允许被缓存，如果允许则没有此值；callback: jQuery33102942401312227503_1527406132039_: 1527406132040// 请求返回结果jQuery33102942401312227503_1527406132039(&#123;"data":"getCrossDomain"&#125;); 后端改动spring-boot java后台，spring-boot框架； 添加Jsonp支持类在项目中添加Jsonp支持类：JsonpAdvice123456@ControllerAdvicepublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123; public JsonpAdvice() &#123; super("callback"); &#125;&#125; 缺点 需要服务端修改代码； 只支持get请求； 发送的不是XHR请求； 支持跨域支持跨域的两种方式： 被调用方支持跨域(前端访问后端的地址是绝对地址)； 调用方隐藏跨域(前端访问后端的地址是相对地址)； 被调用方服务支持跨域前端访问后端的地址是绝对地址 请求处理流程调用方请求从浏览器发出，直接请求被调用方http服务器，被调用方的http服务器根据动态请求则会交给应用服务器（tomcat）来处理，处理完成后，结果传给http服务器，最后发给浏览器。 跨域思路被调用方服务器根据http请求协议，在响应头中返回一些标志字段，来告诉浏览器允许调用方跨域请求。 JavaEE架构里配置跨域响应头： 12341. 应用服务器过滤请求，添加跨域响应头；2. http Apache服务配置；3. http Nginx服务配置；4. Tomcat应用服务器配置； Filter跨域概述 Filter方案其实是调用放的浏览器直接发送请求到被调用方的应用服务器，应用服务器通过filter增加响应头的方式处理请求直接返回给调用方浏览器； Filter方案过滤请求头信息，响应给浏览器允许跨域的信息； 后端过滤方案springboot 通过过滤所有请求，来添加响应头，来实现全局接口跨域； 1&gt; 在application程序入口中添加url请求拦截入口方法： 12345678910111213@SpringBootApplicationpublic class AjaxServerApplication &#123; //... @Bean public FilterRegistrationBean&lt;CrossFilter&gt; registerBean()&#123; FilterRegistrationBean&lt;CrossFilter&gt; bean=new FilterRegistrationBean&lt;CrossFilter&gt;(); // 设置需要过滤的url地址：所有url bean.addUrlPatterns(&quot;/*&quot;); // 设置Filter过滤对象 bean.setFilter(new CrossFilter()); return bean; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.springframework.util.StringUtils;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 跨域url过滤器 */public class CrossFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 处理过滤到的url请求的逻辑 HttpServletResponse response = (HttpServletResponse) servletResponse; // 设置允许跨域调用的地址域// response.addHeader("Access-Control-Allow-Origin","http://localhost:8081");// response.addHeader("Access-Control-Allow-Methods","GET"); //--Access-Control-Allow-Origin----------------------------------- // 设置允许所有地址和方法跨域，注意请求带cookie时，origin必须全匹配，不能使用通配符来匹配所有请求域，应该动态获取origin；// response.addHeader("Access-Control-Allow-Origin","*"); HttpServletRequest request = (HttpServletRequest) servletRequest; String origin = request.getHeader("Origin"); if (!StringUtils.isEmpty(origin)) &#123; response.addHeader("Access-Control-Allow-Origin", origin); &#125; // 非简单请求： // 发送json格式的请求，会发出预检命令，检查响应头是否有Content-Type；// response.addHeader("Access-Control-Allow-Headers","Content-Type"); // 支持多个自定义请求头（不建议写死，应该动态添加请求头）// response.addHeader("Access-Control-Allow-Headers","Content-Type,x-header1,x-header2"); // 动态支持所有跨域请求头 // 动态获取所有跨域请求头 String headers = request.getHeader("Access-Control-Request-Headers"); if (!StringUtils.isEmpty(headers)) &#123; response.addHeader("Access-Control-Allow-Headers", headers); &#125; // 允许所有方法 response.addHeader("Access-Control-Allow-Methods", "*"); // 浏览器在一次预检命令校验成功后，会缓存预检命令的结果，3600s内不会重新发出预检命令； response.addHeader("Access-Control-Max-Age", "3600"); // 支持cookie response.addHeader("Access-Control-Allow-Credentials", "true"); // 重新设置调用链 filterChain.doFilter(servletRequest, response); &#125; @Override public void destroy() &#123; &#125;&#125; nginx跨域此处指后端对应的nginx http服务器。 虚拟主机虚拟主机是：多个域名指向同一个服务器，服务器根据不同的域名吧请求转到不同的应用服务器，看上去有很多个主机，实际上只有一个主机。 配置跨域虚拟主机 按以下步骤配置支持跨域的虚拟主机，即可完成简单的nginx服务支持跨域； 1&gt; 在host文件中添加本地域名映射（c:\Windows\System32\Drivers\etc\host），主要目的是通过xem.com域名在本地模拟访问后端服务器；； 123# 即访问xem.com域名时，映射到本机地址；# 127.0.0.1(本机地址)127.0.0.1 xem.com 2&gt; nginx\conf目录下创建vhost文件，用于存放每个虚拟主机域名的conf文件，并修改nginx配置文件nginx/conf/nginx.conf,添加以下代码，表示加载vhost文件夹里的虚拟主机配置： 1234http&#123; //... include /vhost/*.conf;&#125; 3&gt; 配置虚拟主机：vhost文件夹中，新建一个xem.com.conf的域名虚拟主机配置文件，用于监听该域名的请求，将请求转到相应的应用服务器； 1234567891011121314151617181920212223242526server&#123; # 监听80端口 listen 80; # 当用户访问xem.com时,此虚机主机进行处理 server_name xem.com; # /匹配所有请求 location /&#123; # 80端口的xem.com域名的所有请求都转到localhost:8080 proxy_pass http://localhost:8080/; # 支持跨域的固定响应头 add_header Access-Control-Allow-Methods *; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Credentials true; # 支持跨域的动态响应头(nginx属性值都要小写) add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Allow-Headers $http_access_control_request_headers; # 处理跨域的预检命令，直接返回200（注意：if后面有空格） if ($request_method = OPTIONS)&#123; return 200; &#125; &#125;&#125; 4&gt; 启动nginx校验跨域； nginx根目录下，执行如下相关nginx命令： 校验配置文件书写是否正确 1$ nginx.exe -t 启动nginx 1$ start nginx.exe 重新加载nginx改动 1$ nginx.exe -s reload 停止nginx服务 1$ nginx.exe -s stop apache跨域apache跨域和nginx原理一样，也是配置虚拟主机来设置响应头，最终支持跨域的； 配置步骤 本地host文件，添加xem.com域名映射，访问此域名时模拟访问后端服务器； 配置apache配置文件：打开Apache24\conf\httpd.conf配置文件,开启相关配置功能； 打开以下注释： 123456789101112# 虚拟主机模块LoadModule vhost_alias_module modules/mod_vhost_alias.so# 虚拟主机配置文件Include conf/extra/httpd-vhosts.conf# proxy代理：LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.so# headersLoadModule headers_module modules/mod_headers.soLoadModule rewrite_module modules/mod_rewrite.so 配置虚拟主机：打开虚拟主机配置文件Apache24\conf\extra\httpd-vhosts.conf； 添加一个虚拟主机： 12345678910111213141516171819202122&lt;VirtualHost *:80&gt; ServerName xem.com ErrorLog &quot;logs/xem.com-error.log&quot; CustomLog &quot;logs/xem.com-access.log&quot; common ProxyPass / http://localhost:8080/ # 动态请求头Origin的值返回到Access-Control-Allow-Origin字段 Header always set Access-Control-Allow-Origin &quot;expr=%&#123;req:origin&#125;&quot; # 动态请求头Access-Control-Request-Headers值返回到Access-Control-Allow-Headers字段 Header always set Access-Control-Allow-Headers &quot;expr=%&#123;req:Access-Control-Request-Headers&#125;&quot; # 固定值的请求头 Header always set Access-Control-Allow-Methods &quot;*&quot; Header always set Access-Control-Allow-Credentials &quot;true&quot; Header always set Access-Control-Max-Age &quot;3600&quot; # 处理预检命令，直接返回204 RewriteEngine On RewriteCond %&#123;REQUEST_METHOD&#125; OPTIONS RewriteRule ^(.*)$ &quot;/&quot; [R=204,L]&lt;/VirtualHost&gt; 启动apache服务，验证跨域； 方式一： 命令方式启动;1234// 启动服务$ httpd.exe -k start// 停止服务$ httpd.exe -k stop 方式二：直接打开Apache24\bin\httpd.exe执行文件； JavaEE后端跨域spring-boot框架过滤请求跨域 通过过滤所有url请求的方式，实现全局接口支持跨域； 详见Filter跨域； 全局接口跨域注解 spring-boot 1.0的实现方式： 123456789101112// 新建配置类，配置跨域信息；@Configurationpublic class CrossDomainSb1Config extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedOrigins("*") .allowCredentials(true) .allowedMethods("*") .maxAge(3600); &#125;&#125; spring-boot 2.0的实现方式： 123456789101112131415161718// 新建配置类，配置跨域信息；@Configuration@EnableWebMvcpublic class CrossDomainSb2Config implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; //设置允许跨域的路径 registry.addMapping("/**") //设置允许跨域请求的域名 .allowedOrigins("*") //是否允许证书 不再默认开启 .allowCredentials(true) //设置允许的方法 .allowedMethods("*") //跨域允许时间 .maxAge(3600); &#125;&#125; 局部接口跨域注解 通过@CrossOrigin注解让部分接口Controller类或接口方法支持跨域； 只需要在接口controller上或某个接口方法上加@CrossOrigin注解即可； 配置@CrossOrigin并不支持cookie的请求，如需支持cookie,需要配置额外信息：@CrossOrigin(allowCredentials=”true”)； 123456@RestController@RequestMapping("/crossDomain")@CrossOrigin(allowCredentials = "true")public class AjaxApiController &#123; //...&#125; 调用方服务隐藏跨域 隐藏跨域是在调用方的http服务器进行配置，前端访问后端的地址是相对地址； 隐藏跨域指调用方的请求从调用方的http服务器直接发送到被调用了方的http服务器； 跨域请求是通过调用方http服务器的反向代理，将请求转发到被调用方的http服务器的，所以在浏览器上面看不到任何跨域请求的信息； 反向代理：访问同一个域名的两个不同的url，最后会去到两个不同的服务器； nginx前端http服务器是nginx服务器，配置nginx隐藏跨域； 1&gt; host文件中，添加xem.com作为本地域名映射； 2&gt; nginx/conf/vhost文件中添加域名虚拟主机配置： 12345678910111213141516server&#123; # 监听80端口 listen 80; # 当用户访问xem.com时,此虚机主机进行处理 server_name xem.com; # /xem.com访问的都是localhost:8081网页的地址 location /&#123; proxy_pass http://localhost:8081/; &#125; # 网页内相对路径代理后端地址 location /ajaxserver&#123; proxy_pass http://localhost:8080/; &#125;&#125; 3&gt; ajax请求使用相对地址“/ajaxserver”拼接具体请求； 4&gt; 启动nginx服务，访问xem.com网页，请求会自动转发到后台的地址； apache1&gt; 设置host文件中的域名映射； 2&gt; 同被调用方支持跨域里的apache的配置类似，不同的是虚拟主机的配置，如下： 12345678910&lt;VirtualHost *:80&gt; ServerName xem.com ErrorLog &quot;logs/xem.com-error.log&quot; CustomLog &quot;logs/xem.com-access.log&quot; common # ajaxserver相对路径代理后台服务端地址 ProxyPass /ajaxserver http://localhost:8080/ # xem.com域名代理访问的网站真是地址 ProxyPass / http://localhost:8081/&lt;/VirtualHost&gt; 3&gt; 网页使用相对地址请求服务端接口； 4&gt; 启动apache服务测试跨域； 第三方js库解决跨域在编写angular/reactjs/vue项目时，有他们自己的跨域解决方案；]]></content>
      <categories>
        <category>大前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现元素居中的方法收集]]></title>
    <url>%2F2016%2F02%2F28%2Fweb%2FCSS%2FCSS%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录CSS实现元素水平处置居中的方法收集的笔记。 概述本文收录css常用到的标签元素水平垂直居中显示样式的设置方法，主要考虑以下两种情况： 居中元素固定宽高； 居中元素不固定宽高； 固定宽高元素居中 absolute + 负margin absolute + margin auto absolute + calc absolute+负margin父元素使用相对定位，固定宽高居中元素使用绝对定位，设置margin偏移自身宽高的尺寸即可； 1234567891011121314151617181920212223242526&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; position: relative; &#125; .centerElement &#123; background: green; width: 100px; height: 100px; line-height: 100px; text-align: center; position: absolute;; top: 50%; left: 50%; /*向左偏移50%的宽度*/ margin-left: -50px; /*向上偏移50%的高度*/ margin-top: -50px; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; absolute+calc函数父元素使用相对定位，固定宽高居中元素使用绝对定位，设置left、top偏移自身宽高的尺寸即可； 12345678910111213141516171819202122&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; position: relative; &#125; .centerElement &#123; background: green; width: 100px; height: 100px; line-height: 100px; text-align: center; position: absolute;; top: calc(50% - 50px); left: calc(50% - 50px); &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; absolute+margin auto父元素使用相对定位，固定宽高居中元素使用绝对定位，设置上下左右偏移为0，同时设置margin:auto即可； 12345678910111213141516171819202122232425&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; position: relative; &#125; .centerElement &#123; background: green; width: 100px; height: 100px; line-height: 100px; text-align: center; position: absolute;; top: 0; left: 0; right: 0; bottom: 0; margin: auto; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; 拓展水平居中可以不使用定位，设置居中元素的margin: 0 auto的方式，使元素水平居中； 12345678910111213141516171819&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; &#125; .centerElement &#123; background: green; width: 100px; height: 100px; line-height: 100px; text-align: center; margin: 0 auto; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; 不固定宽高元素居中 居中的元素宽高不固定的情况 absolute + transform lineheight writing-mode table css-table flex grid absolute+transform父元素使用相对定位，不固定宽高居中元素使用绝对定位，设置css平移属性translate，使元素负方向平移自身宽高的50%； 123456789101112131415161718192021&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; position: relative; &#125; .centerElement &#123; background: green; text-align: center; position: absolute;; top: 50%; left: 50%; /*设置元素水平的和垂直的偏移自身宽高的50%*/ transform: translate(-50%, -50%); &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; writing-mode利用writing-mode定义元素的书写排列方式，间接的让子元素水平和垂直居中； 特别注意：居中元素需要设置为行内块元素，确保不独占一行. 1234567891011121314151617181920212223242526272829303132&lt;!--完整代码--&gt;&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; /*垂直方向书写,从左到右排列*/ writing-mode: vertical-lr; text-align: center; &#125; .container-inner&#123; display: inline-block; /*水平方向书写,从上到下排列*/ writing-mode: horizontal-tb; text-align: center; width: 100%; &#125; .centerElement &#123; background: green; display: inline-block; text-align: left; margin: auto; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="container-inner"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; line-height设置居中元素的父元素行高line-height固定，并设置居中元素displayt为inline-block来实现垂直方向居中，再设置text-align为水平居中对齐； 特别注意：居中元素需要设置为行内块元素，确保不独占一行. 123456789101112131415161718192021&lt;style&gt; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; line-height: 500px; text-align: center; &#125; .centerElement &#123; background: green; display: inline-block; /*initial设置行高为最初的高度*/ line-height: initial; /*相对于父元素的对齐方式*/ vertical-align: middle; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; tabletabel单元格中的内容天然支持垂直居中，再设单元格内容水平居中即可； 特别注意：居中元素需要设置为行内块元素，确保不独占一行. 1234567891011121314151617181920212223242526&lt;style&gt; table&#123; width: 100%; &#125; .container &#123; border: 1px solid blue; width: 100%; height: 500px; margin-top: 50px; text-align: center; &#125; .centerElement &#123; background: green; display: inline-block; &#125;&lt;/style&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="container"&gt; &lt;div class="centerElement"&gt;123123&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; table-cell可以设置居中元素的父元素的display为table-cell单元格样式元素，并设置子元素水平垂直居中，最后设置居中元素为行内块元素即可； 特别注意：居中元素需要设置为行内块元素，确保不独占一行. 123456789101112131415161718&lt;style&gt; .container &#123; border: 1px solid blue; width: 500px; height: 500px; margin-top: 50px; display: table-cell; text-align: center; vertical-align: middle; &#125; .centerElement &#123; background: green; display: inline-block; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; flexboxflex弹性盒子布局方式，很容易让元素居中： 1234567891011121314151617&lt;style&gt; .container &#123; border: 1px solid blue; width: 500px; height: 500px; margin-top: 50px; display: flex; justify-content: center; align-items: center; &#125; .centerElement &#123; background: green; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; grid css新增的grid布局方式，flex的升级版; 1234567891011121314151617&lt;style&gt; .container &#123; border: 1px solid blue; width: 500px; height: 500px; margin-top: 50px; display: grid; &#125; .centerElement &#123; background: green; align-self: center; justify-self: center; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="centerElement"&gt;居中元素&lt;/div&gt;&lt;/div&gt; 总结元素居中方法使用场景： PC端有兼容性要求，宽高固定，推荐absolute+负margin； PC端有兼容要求，宽高不固定，推荐css-table； PC端无兼容性要求，推荐flex； 移动端推荐使用flex； 方法 居中元素定宽高固定 PC兼容性 移动端兼容性 absolute+负margin 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute+margin auto 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute+calc 是 ie9+, chrome19+, firefox4+ 安卓4.4+, iOS6+ absolute+transform 否 ie9+, chrome4+, firefox3.5+ 安卓3+, iOS6+ writing-mode 否 ie6+, chrome4+, firefox3.5+ 安卓2.3+, iOS5.1+ lineheight 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ table 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ css-table 否 ie8+, chrome4+, firefox2+ 安卓2.3+, iOS6+ flex 否 ie10+, chrome4+, firefox2+ 安卓2.3+, iOS6+ grid 否 ie16, chrome57+, firefox52+ 安卓6+, iOS10.3+]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flexbox布局]]></title>
    <url>%2F2016%2F02%2F21%2Fweb%2FCSS%2Fflexbox%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录flexbox布局的笔记。 Flex布局简介 Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 flex概念flex容器采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 轴线主轴交叉轴示意图： 容器默认存在两根轴： 水平方向的是主轴（main axis） 垂直方向的是交叉轴（cross axis）。 轴线内的位置属性： 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 引入flex块元素1234.box&#123; display: flex; display: -webkit-flex;&#125; 行内元素行内元素也可以使用 Flex 布局 1234.box&#123; display: inline-flex; display: -webkit-inline-flex;&#125; 浏览器支持 chrome 21+ opera 12.1+ safari 6.1+ firefox 22+ IE 10+ 注意1- Webkit 内核的浏览器，必须加上-webkit-前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; flex容器属性属性概览以下6个属性设置在容器上： flex-direction 子项目的排列方向 flex-wrap 子项目如何换行 flex-flow flex-direction属性和flex-wrap的组合简写 justify-content 子项目在主轴上的对齐方式 align-items 子项目在交叉轴上如何对齐 align-content 多根轴线（多行或多列时）的对齐方式 flex-directionflex-direction属性决定主轴的方向（即项目的排列方向）。 语法格式12345678.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125;【属性值】- row（默认值）：主轴为水平方向，起点在左端。- row-reverse：主轴为水平方向，起点在右端。- column：主轴为垂直方向，起点在上沿。- column-reverse：主轴为垂直方向，起点在下沿。 属性值效果图 flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 语法格式1234567.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;【属性值】- nowrap（默认）：不换行，如果容器宽度固定，会出现安宽度等比挤压变窄，以保证一行显示。- wrap：换行，第一行在上方。- wrap-reverse：换行，第一行在下方。 属性值效果图 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 语法格式123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 示例12345.container &#123; display: -webkit-flex; display: flex; flex-flow: row wrap-reverse;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 语法格式12345678910.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125;【属性值】它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右：- flex-start（默认值）：左对齐- flex-end：右对齐- center： 居中- space-between：两端对齐，项目之间的间隔都相等。- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 属性值效果图 align-itemsalign-items属性定义项目在交叉轴上如何对齐。 语法格式12345678910.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125;【属性值】它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：- flex-start：交叉轴的起点对齐。- flex-end：交叉轴的终点对齐。- center：交叉轴的中点对齐。- baseline: 项目的第一行文字的基线对齐。- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 属性值效果图 align-contentalign-content属性定义了多根轴线（多行或多列时）的对齐方式。如果项目只有一根轴线，该属性不起作用。 语法格式12345678910.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;【属性值】- flex-start：与交叉轴的起点对齐。- flex-end：与交叉轴的终点对齐。- center：与交叉轴的中点对齐。- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。- stretch（默认值）：高度不固定或者为auto时，轴线占满整个交叉轴。 属性值效果图 flex项目属性如果在子项目中使用flex布局，子项目的父容器必须设置display为flex支持flex布局。 属性概览以下6个属性设置在项目上： order 项目在父容器中的排列顺序 flex-grow 项目的放大比例 flex-shrink 项目的缩小比例 flex-basis 项目占据的主轴空间 flex flex-grow、flex-shrink和flex-basis的简写 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 语法格式12345.item &#123; order: &lt;integer&gt;;&#125;【属性值】integer 数字（可以是负数） 属性值效果图 flex-grow flex-grow属性定义项目按排列的方向，对宽或者高按比例放大，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 语法格式12345.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125;【属性值】number 正数数字 属性值效果图 flex-shrink flex-shrink属性定义了项目按排列的方向，对宽或者高按比例缩小，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 语法格式12345.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125;【属性值】number 正数数字或0，负值对该属性无效。 属性值效果图 flex-basis flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 语法格式123456.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125;【属性值】length 长度尺寸（可以是百分号）auto(默认) 项目的本来大小。 属性值效果图flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。语法格式 1234567.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125;【属性值】auto (1 1 auto) none (0 0 auto)。flex-grow、flex-shrink、flex-basis组合 align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 语法格式1234.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;auto 默认值，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 属性值效果图]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3笔记]]></title>
    <url>%2F2016%2F02%2F14%2Fweb%2FCSS%2FCSS3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录CSS3的笔记。 浏览器样式兼容css样式兼容老版本浏览器，需要在css样式属性加前缀： firefox: -moz- safari: -webkit- chrome: -webkit- opera: -o- IE9: -ms- 边框CSS3边框属性： border-radius 圆角边框 box-shadow 边框阴影 border-image 边框图片 圆角边框12border-radius- border-radius 属性是一个简写属性，用于设置四个角 border-*-radius 属性。 border-radius对应以下四个角： border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 12【注意】旧版本Firefox需要前缀-moz-：-moz-border-radius 属性值单位 length 尺寸单位定义圆角的形状。 % 以百分比定义圆角的形状。 语法格式123456789101112border-radius: 1-4 length|%【属性值说明】- 相当于按以下顺序设置半径：1&gt; 上左 | 上左水平方向半径/上左垂直方向半径2&gt; 上右 | 上右水平方向半径/上右垂直方向半径3&gt; 下右 | 下右水平方向半径/下右垂直方向半径4&gt; 下左 | 下左水平方向半径/下左垂直方向半径- 设置值得数量：四个方向如果对角线一方缺少，则和对角有值得相等；1&gt; 一个值：四个方向半径相等；2&gt; 两个值：第一个值表示左上和右下，第二个值表示右上和左下;3&gt; 三个值：第一个值表示左上，第二个值表示右上和左下，第三个值表示右下；4&gt; 四个值：左上、右上、右下、左下； 单个值 123456border-radius:2em;// 等价border-top-left-radius:2em;border-top-right-radius:2em;border-bottom-right-radius:2em;border-bottom-left-radius:2em; 多个值 123456border-radius: 2em 1em 4em / 0.5em 3em;// 等价border-top-left-radius: 2em 0.5em;border-top-right-radius: 1em 3em;border-bottom-right-radius: 4em 0.5em;border-bottom-left-radius: 1em 3em; 示例设置div的圆角？ 12345div&#123; border:2px solid; border-radius:25px; -moz-border-radius:25px; /* Old Firefox */&#125; 边框阴影box-shadow 用于向方框添加阴影; 语法格式12345678box-shadow: h-shadow v-shadow blur spread color inset;【属性值说明】h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。color 可选。阴影的颜色。请参阅 CSS 颜色值。inset 可选。值就是inset,将外部阴影 (outset) 改为内部阴影。 1234div &#123; box-shadow: 10px 10px 5px #888888; -moz-box-shadow: 10px 10px 5px #888888; /* 老的 Firefox */&#125; 边框图片IE11支持 定义语法通过CSS3的border-image属性，您可以使用图片来创建边框. border-image是border-image-* 属性的简写属性，用于设置以下属性： border-image-source 用在边框的图片的路径。 border-image-slice 图片边框向内偏移。 border-image-width 图片边框的宽度。 border-image-outset 边框图像区域超出边框的量。 border-image-repeat 图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)。 示例123456div&#123; border-image:url(border.png) 30 30 round; -moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */ -webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */ -o-border-image:url(border.png) 30 30 round; /* Opera */&#125; 背景CSS3背景属性： background-clip 规定背景的绘制区域。 background-origin 规定背景图片的定位区域。 background-size 规定背景图片的尺寸。 支持新的背景属性的浏览器： Internet Explorer 9+、 Firefox、 Chrome、 Safari Opera 。 背景尺寸 background-size 属性规定背景图片的尺寸。 以像素或百分比规定尺寸。 语法格式1234567891011background-size: length|%|cover|contain;【属性值说明】length 设置背景图像的高度和宽度。 第一个值设置宽度，第二个值设置高度。 如果只设置一个值，则第二个值会被设置为 &quot;auto&quot;。% 以父元素的百分比来设置背景图像的宽度和高度。 第一个值设置宽度，第二个值设置高度。 如果只设置一个值，则第二个值会被设置为 &quot;auto&quot;。cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 背景图像的某些部分也许无法显示在背景定位区域中。contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 示例12345div&#123; background:url(img_flwr.gif); background-size:80px 60px; background-repeat:no-repeat;&#125; 背景图片定位区域 background-origin 属性规定背景图片的定位区域。 background-origin 属性规定background-position属性相对于什么位置来定位。 背景图片可以放置于content-box(内容区)、padding-box(padding以内)或border-box（边框线以内）区域。 语法格式12345background-origin: padding-box|border-box|content-box;【属性值说明】padding-box 背景图像相对于内边距框来定位。border-box 背景图像相对于边框盒来定位。content-box 背景图像相对于内容框来定位。 示例1234567div&#123; background:url(bg_flower.gif); background-repeat:no-repeat; background-size:100% 100%; -webkit-background-origin:content-box; /* Safari */ background-origin:content-box;&#125; 背景绘制区域background-clip 属性规定背景的绘制区域。 语法格式12345background-clip: border-box|padding-box|content-box;【属性值说明】border-box 背景被裁剪到边框盒。 padding-box 背景被裁剪到内边距框。 content-box 背景被裁剪到内容框。 示例1234div&#123; background-color:yellow; background-clip:content-box;&#125; 多重背景图CSS3允许background-image为元素使用多个背景图像，按顺序会重叠。 123body&#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif);&#125; 文本效果概览新的文本属性： text-shadow 向文本添加阴影。 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 文本阴影 在 CSS3 中，text-shadow可向文本应用阴影。 能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色： Internet Explorer 9以及更早的版本，不支持text-shadow属性。 语法格式123456text-shadow: h-shadow v-shadow blur color;【属性值说明】h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊的距离。color 可选。阴影的颜色。参阅 CSS 颜色值。 注释： text-shadow 属性向文本添加一个或多个阴影。 该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。 省略的长度是 0。 示例123h1&#123; text-shadow: 5px 5px 5px #FF0000;&#125; 自动换行允许对长的不可分割的单词进行分割并换行到下一行。 语法格式1234word-wrap: normal|break-word;【属性值说明】normal 只在允许的断字点换行（浏览器保持默认处理）。break-word 在长单词或 URL 地址内部进行换行。 示例1p.test &#123;word-wrap:break-word;&#125; 颜色css3支持hsl，即色调、饱和度、亮度来表示颜色值： H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% 1.test&#123;background-color:hsl(360,50%,50%);&#125; 字体 在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。 通过 CSS3，web 设计师可以使用他们喜欢的任意字体。 当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，css中指定@font-face规则，它会在需要时被自动下载到用户的计算机上。 浏览器支持 Firefox、Chrome、Safari 以及 Opera 支持 .ttf (True Type Fonts) 和 .otf (OpenType Fonts) 类型的字体。 Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。 注释：Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。 语法定义定义@font-face规则 在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。 如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFirstFont)； 还可以定义支持其他样式，只需要再写一个@font-face规则，配置指定属性即可； @font-face规则属性123456- font-family name 必需。规定字体的名称。- src URL 必需。定义字体文件的 URL。- font-stretch 可选。定义如何拉伸字体。默认是 &quot;normal&quot;。- font-style 可选。定义字体的样式。默认是 &quot;normal&quot;。- font-weight 可选。定义字体的粗细。默认是 &quot;normal&quot;。- unicode-range unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 &quot;U+0-10FFFF&quot;。 示例 自定义外部字体？ 12345678910111213&lt;style&gt; @font-face&#123; font-family: myFirstFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9+ */&#125;div&#123; font-family:myFirstFont;&#125;&lt;/style&gt;&lt;div&gt;hello world&lt;/div&gt; 给自定义字体加粗？ 123456789101112131415161718192021222324&lt;style&gt; /*外部字体*/@font-face&#123; font-family: myFirstFont; src: url('/example/css3/Sansation_Light.ttf') ,url('/example/css3/Sansation_Light.eot'); /* IE9+ */&#125;/*加粗的规则*/@font-face&#123; font-family: myFirstFont; /*外部加粗的字体*/ src: url('/example/css3/Sansation_Bold.ttf') ,url('/example/css3/Sansation_Bold.eot'); /* IE9+ */ /*重写加粗属性*/ font-weight:bold;&#125;div&#123; font-family:myFirstFont;&#125;&lt;/style&gt;&lt;div&gt;hello &lt;strong&gt;world&lt;/strong&gt;&lt;/div&gt; 2D3D转换基点 transform-origin 属性允许您改变被转换元素基点位置。 2D 转换元素能够改变元素 x 和 y 轴。3D 转换元素还能改变其 Z 轴。 浏览器支持 Internet Explorer 10、Firefox、Opera 支持 transform-origin 属性。 Internet Explorer 9 支持替代的 -ms-transform-origin 属性（仅适用于 2D 转换）。 Safari 和 Chrome 支持替代的 -webkit-transform-origin 属性（3D 和 2D 转换）。 Opera 只支持 2D 转换。 语法定义12345678910111213141516transform-origin: x-axis y-axis z-axis;x-axis 定义视图被置于 X 轴的何处。可能的值： left center right length %y-axis 定义视图被置于 Y 轴的何处。可能的值： top center bottom length %z-axis 定义视图被置于 Z 轴的何处。可能的值： length 示例设置旋转元素的基点位置：12345678910111213141516div&#123; position: absolute; background-color: yellow; transform: rotate(45deg); -ms-transform: rotate(45deg); /* IE 9 */ -webkit-transform: rotate(45deg); /* Safari and Chrome */ -moz-transform: rotate(45deg); /* Firefox */ -o-transform: rotate(45deg); /* Opera */ transform-origin:20% 40%; -ms-transform-origin:20% 40%; /* IE 9 */ -webkit-transform-origin:20% 40%; /* Safari and Chrome */ -moz-transform-origin:20% 40%; /* Firefox */ -o-transform-origin:20% 40%; /* Opera */&#125; 2D转换通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。 浏览器支持 Internet Explorer 10、Firefox 以及 Opera 支持 transform 属性。 Chrome 和 Safari 需要前缀 -webkit-。 Internet Explorer 9 需要前缀 -ms-。 转换transform 属性向元素应用2D或3D转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 【语法定义】 123456789101112131415transform: none|transform-functions;【属性值】none 定义不进行转换transform-functions:matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。translateX(n) 定义 2D 转换，沿着 X 轴移动元素。translateY(n) 定义 2D 转换，沿着 Y 轴移动元素。scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。scaleX(n) 定义 2D 缩放转换，改变元素的宽度。scaleY(n) 定义 2D 缩放转换，改变元素的高度。rotate(angle) 定义 2D 旋转，在参数中规定角度。skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。 平移通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 12345678/* 值translate(50px,100px)把元素从左侧移动50像素，从顶端移动100像素。*/ div&#123; transform: translate(50px,100px); -ms-transform: translate(50px,100px); /* IE 9 */ -webkit-transform: translate(50px,100px); /* Safari and Chrome */ -o-transform: translate(50px,100px); /* Opera */ -moz-transform: translate(50px,100px); /* Firefox */&#125; 旋转通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。12345678/* 值 rotate(30deg) 把元素顺时针旋转 30 度。*/ div&#123; transform: rotate(30deg); -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ -o-transform: rotate(30deg); /* Opera */ -moz-transform: rotate(30deg); /* Firefox */&#125; 缩放通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：12345678/* 值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。*/ div&#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari 和 Chrome */ -o-transform: scale(2,4); /* Opera */ -moz-transform: scale(2,4); /* Firefox */&#125; 斜拉通过 skew() 方法，元素倾斜给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：12345678/* 值 skew(30deg,20deg) 围绕 X 轴把元素斜拉 30 度，围绕 Y 轴斜拉 20 度。*/ div&#123; transform: skew(30deg,20deg); -ms-transform: skew(30deg,20deg); /* IE 9 */ -webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ -o-transform: skew(30deg,20deg); /* Opera */ -moz-transform: skew(30deg,20deg); /* Firefox */&#125; 矩阵变换 matrix() 方法把所有 2D 转换方法组合在一起。 matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 matrix(a,b,c,d,e,f)有六个参数，对应到矩阵如下： 1234平移：translate(x,y) === matrix(1,0,0,1,x,y)缩放：scale(x,y) === matrix(x,0,0,y,0,0)旋转：rotate(x) === matrix(cos(x),-sin(x),sin(x),cos(x),0,0)斜拉：skew(x,y) === matrix(1,tan(y),tan(x) ,1,0,0) 示例 用matrix方法将div元素旋转30度？ 1234567div&#123; transform:matrix(0.866,0.5,-0.5,0.866,0,0); -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */ -moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */ -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */ -o-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Opera */&#125; 3D转换 CSS3 允许您使用 3D 转换来对元素进行格式化； 转换是使元素改变形状、尺寸和位置的一种效果。 浏览器支持 Internet Explorer 10 和 Firefox 支持 3D 转换。 Chrome 和 Safari 需要前缀 -webkit-。 Opera 仍然不支持 3D 转换（它只支持 2D 转换）。 转换transform 属性向元素应用2D或3D转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜，与2D转换用法类似。 【语法定义】123456789101112131415161718192021222324transform: none|transform-functions;【属性值】none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。perspective(n) 为 3D 转换元素定义透视视图。 旋转rotateX12345div&#123; transform: rotateX(120deg); -webkit-transform: rotateX(120deg); /* Safari 和 Chrome */ -moz-transform: rotateX(120deg); /* Firefox */&#125; rotateY12345div&#123; transform: rotateY(130deg); -webkit-transform: rotateY(130deg); /* Safari 和 Chrome */ -moz-transform: rotateY(130deg); /* Firefox */&#125; 矩阵转换matrix3d(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)有16个参数，对应到矩阵如下： 12平移：translate(x,y,z) === matrix(1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1)缩放：scale(x,y,z) === matrix(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1) 嵌套元素如何显示transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。 浏览器支持 Firefox 支持 transform-style 属性。 Chrome、Safari 和 Opera 支持替代的 -webkit-transform-style 属性。 语法定义1234transform-style: flat|preserve-3d;【属性值】flat 子元素将不保留其 3D 位置。preserve-3d 子元素将保留其 3D 位置。 js支持1domObj.style.transformStyle="preserve-3d" 示例 使被转换的子元素保留其 3D 转换：123456div &#123; transform: rotateY(60deg); transform-style: preserve-3d; -webkit-transform: rotateY(60deg); /* Safari 和 Chrome */ -webkit-transform-style: preserve-3d; /* Safari 和 Chrome */&#125; 透视效果 perspective规定 3D 元素的透视效果。 perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 perspective 属性只影响 3D 转换元素。 常与 perspective-origin 属性一同使用该属性，这样您就能够改变 3D 元素的底部位置。 浏览器支持 目前浏览器都不支持 perspective 属性。 Chrome 和 Safari 支持替代的 -webkit-perspective 属性。 语法格式1234perspective: number|none;【属性值】number 元素距离视图的距离，以像素计。none 默认值。与 0 相同。不设置透视。 js支持1object.style.perspective=500 示例1234div&#123; perspective: 500; -webkit-perspective: 500; /* Safari 和 Chrome */&#125; 底部位置 perspective-origin 属性定义3D元素所基于的X轴和Y轴。该属性允许您改变 3D 元素的底部位置。 当为元素定义 perspective-origin 属性时，其子元素会获得透视效果，而不是元素本身。 浏览器支持 目前浏览器都不支持 perspective-origin 属性。 Chrome 和 Safari 支持替代的 -webkit-perspecitve-origin 属性。 语法定义1234567891011121314perspective-origin: x-axis y-axis;【属性值】x-axis 定义该视图在 x 轴上的位置。默认值：50%。可能的值： left center right length %y-axis 定义该视图在 y 轴上的位置。默认值：50%。可能的值： top center bottom length % 示例设置 3D 元素的基点位置： 123456div&#123; perspective:150; perspective-origin: 10% 10%; -webkit-perspective:150; /* Safari 和 Chrome */ -webkit-perspective-origin: 10% 10%; /* Safari 和 Chrome */&#125; 背向用户显隐backface-visibility 属性定义当元素背向用户时是否可见。 浏览器支持 只有 Internet Explorer 10+ 和 Firefox 支持 backface-visibility 属性。 Opera 15+、Safari 和 Chrome 支持替代的 -webkit-backface-visibility 属性。 语法支持1234backface-visibility: visible|hidden;【属性值】visible 背面是可见的。hidden 背面是不可见的。 js支持1object.style.backfaceVisibility="hidden" 示例123456div &#123; backface-visibility:hidden; -webkit-backface-visibility:hidden; /* Chrome 和 Safari */ -moz-backface-visibility:hidden; /* Firefox */ -ms-backface-visibility:hidden; /* Internet Explorer */&#125; 过渡动画通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 过渡属性【transition】 12语法格式：transition: property duration timing-function delay; transition 过渡的简写属性，用于在一个属性中依次设置四个过渡属性： transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 示例：123456789div &#123; transition: width 1s linear 2s; /* Firefox 4 */ -moz-transition:width 1s linear 2s; /* Safari and Chrome */ -webkit-transition:width 1s linear 2s; /* Opera */ -o-transition:width 1s linear 2s;&#125; transition-propertytransition-property 属性规定应用过渡效果的 CSS 属性的名称。（当指定的 CSS 属性改变时，过渡效果将开始）。 浏览器支持 Internet Explorer 10、Firefox、Opera 和 Chrome 支持 transition-property 属性。 Safari 支持替代的 -webkit-transition-property 属性。 注释：Internet Explorer 9 以及更早版本的浏览器不支持 transition-property 属性。 语法格式12345transition-property: none|all|property;【属性值】none 没有属性会获得过渡效果。all 所有属性都将获得过渡效果。property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。 transition-durationtransition-duration 属性规定完成过渡效果需要花费的时间（以秒或毫秒计）。 浏览器支持 Internet Explorer 10、Firefox、Opera 和 Chrome 支持 transition-duration 属性。 Safari 支持替代的 -webkit-transition-duration 属性。 注释：Internet Explorer 9 以及更早版本的浏览器不支持 transition-duration 属性。 语法格式1234transition-duration: time;【属性值】time 规定完成过渡效果需要花费的时间（以秒或毫秒计）。 默认值是 0，意味着不会有效果。 transition-timing-function transition-timing-function 属性规定过渡效果的速度曲线。 该属性允许过渡效果随着时间来改变其速度。 浏览器支持 Internet Explorer 10、Firefox、Opera 和 Chrome 支持 transition-timing-function 属性。 Safari 支持替代的 -webkit-transition-timing-function 属性。 注释：Internet Explorer 9 以及更早版本的浏览器不支持 transition-timing-function 属性。 语法格式123456789transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);【属性值】linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。cubic-bezier(n,n,n,n) cubic-bezier (x1,y1,x2,y2) 在 cubic-bezier（三次贝塞尔曲线） 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 示例 基本用法： 1234567891011121314151617181920212223#div1 &#123;transition-timing-function: linear;&#125;#div2 &#123;transition-timing-function: ease;&#125;#div3 &#123;transition-timing-function: ease-in;&#125;#div4 &#123;transition-timing-function: ease-out;&#125;#div5 &#123;transition-timing-function: ease-in-out;&#125;/* Firefox 4: */#div1 &#123;-moz-transition-timing-function: linear;&#125;#div2 &#123;-moz-transition-timing-function: ease;&#125;#div3 &#123;-moz-transition-timing-function: ease-in;&#125;#div4 &#123;-moz-transition-timing-function: ease-out;&#125;#div5 &#123;-moz-transition-timing-function: ease-in-out;&#125;/* Safari and Chrome: */#div1 &#123;-webkit-transition-timing-function: linear;&#125;#div2 &#123;-webkit-transition-timing-function: ease;&#125;#div3 &#123;-webkit-transition-timing-function: ease-in;&#125;#div4 &#123;-webkit-transition-timing-function: ease-out;&#125;#div5 &#123;-webkit-transition-timing-function: ease-in-out;&#125;/* Opera: */#div1 &#123;-o-transition-timing-function: linear;&#125;#div2 &#123;-o-transition-timing-function: ease;&#125;#div3 &#123;-o-transition-timing-function: ease-in;&#125;#div4 &#123;-o-transition-timing-function: ease-out;&#125;#div5 &#123;-o-transition-timing-function: ease-in-out;&#125; cubic-bezier三次贝塞尔曲线函数来规定速度曲线： 1234567891011121314151617181920212223#div1 &#123;transition-timing-function: cubic-bezier(0,0,1,1;&#125;#div2 &#123;transition-timing-function: cubic-bezier(0.25,0.1,0.25,1);&#125;#div3 &#123;transition-timing-function: cubic-bezier(0.42,0,1,1);&#125;#div4 &#123;transition-timing-function: cubic-bezier(0,0,0.58,1);&#125;#div5 &#123;transition-timing-function: cubic-bezier(0.42,0,0.58,1);&#125;/* Firefox 4: */#div1 &#123;-moz-transition-timing-function: cubic-bezier(0,0,0.25,1);&#125;#div2 &#123;-moz-transition-timing-function: cubic-bezier(0.25,0.1,0.25,1);&#125;#div3 &#123;-moz-transition-timing-function: cubic-bezier(0.42,0,1,1);&#125;#div4 &#123;-moz-transition-timing-function: cubic-bezier(0,0,0.58,1);&#125;#div5 &#123;-moz-transition-timing-function: cubic-bezier(0.42,0,0.58,1);&#125;/* Safari and Chrome: */#div1 &#123;-webkit-transition-timing-function: cubic-bezier(0,0,1,1;&#125;#div2 &#123;-webkit-transition-timing-function: cubic-bezier(0.25,0.1,0.25,1);&#125;#div3 &#123;-webkit-transition-timing-function: cubic-bezier(0.42,0,1,1);&#125;#div4 &#123;-webkit-transition-timing-function: cubic-bezier(0,0,0.58,1);&#125;#div5 &#123;-webkit-transition-timing-function: cubic-bezier(0.42,0,0.58,1);&#125;/* Opera: */#div1 &#123;-o-transition-timing-function: cubic-bezier(0,0,1,1;&#125;#div2 &#123;-o-transition-timing-function: cubic-bezier(0.25,0.1,0.25,1);&#125;#div3 &#123;-o-transition-timing-function: cubic-bezier(0.42,0,1,1);&#125;#div4 &#123;-o-transition-timing-function: cubic-bezier(0,0,0.58,1);&#125;#div5 &#123;-o-transition-timing-function: cubic-bezier(0.42,0,0.58,1);&#125; transition-delaytransition-delay 属性规定过渡效果延迟执行时间。 浏览器支持 Internet Explorer 10、Firefox、Opera 和 Chrome 支持 transition-delay 属性。 Safari 支持替代的 -webkit-transition-delay 属性。 注释：Internet Explorer 9 以及更早版本的浏览器不支持 transition-delay 属性。 语法格式123transition-delay: time;【属性值】time 规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。 示例123456div &#123; transition-delay: 2s; -moz-transition-delay: 2s; /* Firefox 4 */ -webkit-transition-delay: 2s; /* Safari 和 Chrome */ -o-transition-delay: 2s; /* Opera */&#125; 浏览器支持 Internet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。 Safari 需要前缀 -webkit-。 Internet Explorer 9 以及更早的版本，不支持 transition 属性。 Chrome 25 以及更早的版本，需要前缀 -webkit-。 过渡规则 CSS3过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容： 121&gt; 规定把过渡效果作用在哪个CSS属性上；2&gt; 规定渡效效果的时长（没有设置时长，则没有过渡效果）； 过渡效果：开始于指定的CSS属性改变值时。 示例场景：CSS属性改变的典型时间是鼠标指针位于元素上时,当指针移出元素时，它会逐渐变回原来的样式； 1234567891011121314151617&lt;style&gt;div &#123; width:100px; height:100px; background:yellow; transition:width 2s; -moz-transition:width 2s; /* Firefox 4 */ -webkit-transition:width 2s; /* Safari and Chrome */ -o-transition:width 2s; /* Opera */&#125;div:hover&#123; width:300px;&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 多属性过渡如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开： 向宽度、高度和转换添加过渡效果：123456div &#123; transition: width 2s, height 2s, transform 2s; -moz-transition: width 2s, height 2s, -moz-transform 2s; -webkit-transition: width 2s, height 2s, -webkit-transform 2s; -o-transition: width 2s, height 2s,-o-transform 2s;&#125; 动画通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。 动画属性概览123456属性 描述 CSS@keyframes 规定动画。 3animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3animation-play-state 规定动画是否正在运行或暂停。默认是 &quot;running&quot;。 3animation-fill-mode 规定对象动画时间之外的状态。 3 动画规则【@keyframes规则】 @keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 通过 @keyframes 创建的规则，作用于：animation属性。 浏览器支持 Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。 Chrome 和 Safari 需要前缀 -webkit-。 注释：Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。 语法123456789@keyframes animationname &#123;keyframes-selector &#123;css-styles;&#125;&#125;【属性值】animationname 必需。定义动画的名称。keyframes-selector 必需。动画时长的百分比。 合法的值： 0-100% from（与 0% 相同） to（与 100% 相同）css-styles 必需。一个或多个合法的 CSS 样式属性。 示例根据keyframes规则定义mylove动画? 1234567891011121314&lt;style&gt; div&#123; width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -moz-animation:mymove 5s infinite; /* Firefox */ -webkit-animation:mymove 5s infinite; /* Safari and Chrome */ -o-animation:mymove 5s infinite; /* Opera */&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 定义动画规则方式1： from、to； 12345678910111213141516171819@keyframes mymove&#123; from &#123;top:0px;&#125; to &#123;top:200px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; from &#123;top:0px;&#125; to &#123;top:200px;&#125;&#125;@-webkit-keyframes mymove /* Safari and Chrome */&#123; from &#123;top:0px;&#125; to &#123;top:200px;&#125;&#125;@-o-keyframes mymove /* Opera */&#123; from &#123;top:0px;&#125; to &#123;top:200px;&#125;&#125; 定义动画规则方式2： %； 12345678910111213141516171819202122232425262728293031@keyframes mymove&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-webkit-keyframes mymove /* Safari 和 Chrome */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125;@-o-keyframes mymove /* Opera */&#123; 0% &#123;top:0px;&#125; 25% &#123;top:200px;&#125; 50% &#123;top:100px;&#125; 75% &#123;top:200px;&#125; 100% &#123;top:0px;&#125;&#125; 动画animation 动画是使元素从一种样式逐渐变化为另一种样式的效果。 可以改变任意多的样式任意多的次数。 浏览器支持 Internet Explorer 10、Firefox 以及 Opera 支持 animation 属性。 Safari 和 Chrome 支持替代的 -webkit-animation 属性。 注释：Internet Explorer 9 以及更早的版本不支持 animation 属性。 语法12345678animation: name duration timing-function delay iteration-count direction;【属性值】animation-name 规定需要绑定到选择器的 keyframe 名称。。animation-duration 规定完成动画所花费的时间，以秒或毫秒计。animation-timing-function 规定动画的速度曲线（同过渡动画速度曲线属性）。animation-delay 规定在动画开始之前的延迟，以秒或毫秒计。animation-iteration-count 规定动画应该播放的次数（infinite：无限次播放；n: 数字次数）。animation-direction 规定是否应该轮流反向播放动画（alternate：反向播放；normal默认: 正常播放）。 示例1234div &#123; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */&#125; 动画状态animation-play-state 属性规定动画正在运行还是暂停。 浏览器支持 Internet Explorer 10、Firefox 以及 Opera 支持 animation-play-state 属性。 Safari 和 Chrome 支持替代的 -webkit-animation-play-state 属性。 Internet Explorer 9 以及更早的版本不支持 animation-play-state 属性。 语法1234animation-play-state: paused|running;【属性值】paused 规定动画已暂停。 running 规定动画正在播放。 js支持1object.style.animationPlayState="paused" 示例1234div &#123; animation-play-state:paused; -webkit-animation-play-state:paused; /* Safari 和 Chrome */&#125; 动画效果是否可见animation-fill-mode 属性规定动画在播放之前或之后，其动画效果是否可见。 浏览器支持 Internet Explorer 10、Firefox 以及 Opera 支持 animation-fill-mode 属性。 Safari 和 Chrome 支持替代的 -webkit-animation-fill-mode 属性。 注释：Internet Explorer 9 以及更早的版本不支持 animation-fill-mode 属性。 语法123456animation-fill-mode : none | forwards | backwards | both;【属性】none 不改变默认行为。forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。both 向前和向后填充模式都被应用。 示例123h1&#123; animation-fill-mode: forwards;&#125; 子内容多列通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！ 创建多列column-count 属性规定元素应该被划分的列数。 浏览器支持 Internet Explorer 10 和 Opera 支持 column-count 属性。 Firefox 支持替代的 -moz-column-count 属性。 Safari 和 Chrome 支持替代的 -webkit-column-count 属性。 Internet Explorer 9 以及更早版本的浏览器不支持 column-count 属性。 语法1234column-count: number|auto;【属性值】number 元素内容将被划分的列数。auto 由其他属性决定列数，比如 &quot;column-width&quot;。 示例将 div 元素中的文本分为三列：12345div&#123; -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari 和 Chrome */ column-count:3;&#125; 列间隔column-gap 属性规定列之间的间隔： 浏览器支持 Internet Explorer 10 和 Opera 支持 column-gap 属性。 Firefox 支持替代的 -moz-column-gap 属性。 Safari 和 Chrome 支持替代的 -webkit-column-gap 属性。 Internet Explorer 9 以及更早版本的浏览器不支持 column-gap 属性。 语法1234column-gap: length|normal;【属性值】length 把列间的间隔设置为指定的长度。 normal 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。 示例规定列之间 40 像素的间隔：12345div &#123; -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari 和 Chrome */ column-gap:40px;&#125; 列规则column-rule 属性是一个简写属性，用于设置所有 column-rule-* 属性。 浏览器支持 Internet Explorer 10 和 Opera 支持 column-rule 属性。 Firefox 支持替代的 -moz-column-rule 属性。 Safari 和 Chrome 支持替代的 -webkit-column-rule 属性。 Internet Explorer 9 以及更早版本的浏览器不支持 column-rule 属性。 语法12345column-rule: column-rule-width column-rule-style column-rule-color;【属性值】- column-rule-width 设置列之间的样式宽度规则。- column-rule-style 设置列之间的样式规则。- column-rule-color 设置列之间的颜色规则。 示例规定列之间的宽度、样式和颜色规则：12345div &#123; -moz-column-rule:3px outset #ff00ff; /* Firefox */ -webkit-column-rule:3px outset #ff00ff; /* Safari 和 Chrome */ column-rule:3px outset #ff00ff;&#125; column-rule-stylecolumn-rule-style 属性规定列之间的样式规则。 语法123456789101112column-rule-style: none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset;【属性值】none 定义没有规则。 hidden 定义隐藏规则。 dotted 定义点状规则。 dashed 定义虚线规则。 solid 定义实线规则。 double 定义双线规则。 groove 定义 3D grooved 规则。该效果取决于宽度和颜色值。ridge 定义 3D ridged 规则。该效果取决于宽度和颜色值。 inset 定义 3D inset 规则。该效果取决于宽度和颜色值。 outset 定义 3D outset 规则。该效果取决于宽度和颜色值。 示例12345div&#123; -moz-column-rule-style:dotted; /* Firefox */ -webkit-column-rule-style:dotted; /* Safari 和 Chrome */ column-rule-style:dotted;&#125; column-rule-widthcolumn-rule-width 属性规定列之间样式的宽度规则。 语法123456column-rule-width: thin|medium|thick|length;【属性值】thin 定义纤细规则。 medium 定义中等规则。 thick 定义宽厚规则。 length 规定规则的宽度。 示例12345div &#123; -moz-column-rule-width:1px; /* Firefox */ -webkit-column-rule-width:1px; /* Safari 和 Chrome */ column-rule-width:1px;&#125; column-rule-colorcolumn-rule-color 属性规定列之间样式的颜色规则。 语法123column-rule-color: color;【属性值】color 规定颜色规则。请参阅 CSS 颜色值。 示例12345div &#123; -moz-column-rule-color:#ff0000; /* Firefox */ -webkit-column-rule-color:#ff0000; /* Safari 和 Chrome */ column-rule-color:#ff0000;&#125; 容器界面在CSS3中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。 用户控制容器大小resize 属性规定是否可由用户调整元素尺寸。 浏览器支持Firefox、Chrome 以及 Safari 支持 resize 属性。 语法123456resize: none|both|horizontal|vertical;【属性值】none 用户无法调整元素的尺寸。both 用户可调整元素的高度和宽度。horizontal 用户可调整元素的宽度。vertical 用户可调整元素的高度。 示例规定可以由用户调整 div 元素的大小：1234div &#123; resize:both; overflow:auto;&#125; 容器内容与修饰box-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素。 浏览器支持Internet Explorer、Opera 以及 Chrome 支持 box-sizing 属性。Firefox 支持替代的 -moz-box-sizing 属性。 语法1234567box-sizing: content-box|border-box|inherit;【属性值】content-box 在宽度和高度之外绘制元素的内边距和边框。border-box 通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。inherit 规定应从父元素继承 box-sizing 属性的值。 示例1234567div &#123; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ -webkit-box-sizing:border-box; /* Safari */ width:50%; float:left;&#125; 容器轮廓偏移outline-offset 属性对轮廓进行偏移，并在边框边缘进行绘制。 浏览器支持所有主流浏览器都支持 outline-offset 属性，除了 Internet Explorer。 轮廓与边框不同点 轮廓不占用空间 轮廓可能是非矩形 语法1234outline-offset: length|inherit;【属性】length 轮廓与边框边缘的距离。inherit 规定应从父元素继承 outline-offset 属性的值。 示例规定边框边缘之外 15 像素处的轮廓：12345div&#123; border:2px solid black; outline:2px solid red; outline-offset:15px;&#125; 函数CSS 有以下几个函数： 1234567函数 描述 CSS 版本attr() 返回选择元素的属性值。 2calc() 允许计算 CSS 的属性值，比如动态计算长度值。 3linear-gradient() 创建一个线性渐变的图像 3radial-gradient() 用径向渐变创建图像。 3repeating-linear-gradient() 用重复的线性渐变创建图像。 3repeating-radial-gradient() 类似 radial-gradient()，用重复的径向渐变创建图像。 3 属性值attr() 函数返回选择元素的属性值。 语法123attr(attribute-name)【属性值】attribute-name 必须。HTML 元素的属性名。 示例123a:after &#123; content: " (" attr(href) ")";&#125; 动态计算长度calc() 函数用于动态计算长度值。 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； 任何长度值(包括百分号)都可以使用calc()函数进行计算； calc()函数支持 “+”, “-“, “*”, “/“ 运算； calc()函数使用标准的数学运算优先级规则； 语法123calc(expression)【属性值】expression 必须，一个数学表达式，结果将采用运算后的返回值。 示例123456789#div1 &#123; position: absolute; left: 50px; width: calc(100% - 100px); border: 1px solid black; background-color: yellow; padding: 5px; text-align: center;&#125; 线性渐变linear-gradient() 函数用于创建一个线性渐变的 “图像”。 线性渐变，需要设置起始点和终止色。至少两种颜色，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 语法1234background: linear-gradient(direction, color-stop1, color-stop2, ...);【属性值】direction 用角度值指定渐变的方向（或角度）。color-stop1, color-stop2,... 用于指定渐变的起止颜色。 示例线性渐变，从红色开始，转为黄色，再到蓝色? 123456#grad &#123; background: -webkit-linear-gradient(red,yellow,blue); /* Safari5.1-6.0*/ background: -o-linear-gradient(red,yellow,blue); /* Opera 11.1-12.0 */ background: -moz-linear-gradient(red,yellow,blue); /* Firefox 3.6-15*/ background: linear-gradient(red,yellow,blue); /* 标准语法 */&#125; 径向渐变radial-gradient() 函数用径向渐变创建 “图像”。 径向渐变由中心点定义。为了创建径向渐变你必须设置两个终止色。 语法123456789101112131415background: radial-gradient(shape size at position, start-color, ..., last-color);【属性值】shape 确定圆的类型: ellipse (默认): 指定椭圆形的径向渐变。 circle ：指定圆形的径向渐变 size 定义渐变的大小，可能值： farthest-corner (默认) : 指定径向渐变的半径长度为从圆心到离圆心最远的角 closest-side ：指定径向渐变的半径长度为从圆心到离圆心最近的边 closest-corner ： 指定径向渐变的半径长度为从圆心到离圆心最近的角 farthest-side ：指定径向渐变的半径长度为从圆心到离圆心最远的边position 定义渐变的位置。可能值： center（默认）：设置中间为径向渐变圆心的纵坐标值。 top：设置顶部为径向渐变圆心的纵坐标值。 bottom：设置底部为径向渐变圆心的纵坐标值。start-color, ..., last-color 用于指定渐变的起止颜色。 示例 椭圆形的径向渐变 123456#grad &#123; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1- 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6-12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6-15 */ background: radial-gradient(red, green, blue); /* 标准语法 */&#125; 圆形径向渐变: 123456#grad &#123; background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari */ background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 to 12.0 */ background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 to 15 */ background: radial-gradient(circle, red, yellow, green); /* 标准语法 */&#125; 不同尺寸大小关键字的使用: 12345678910#grad1 &#123; /* Safari 5.1 to 6.0 */ background: -webkit-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* For Opera 11.6 to 12.0 */ background: -o-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* For Firefox 3.6 to 15 */ background: -moz-radial-gradient(60% 55%, closest-side,blue,green,yellow,black); /* 标准语法 */ background: radial-gradient(closest-side at 60% 55%,blue,green,yellow,black);&#125; 重复线性渐变repeating-linear-gradient() 函数用于创建重复的线性渐变 “图像”。 语法12345background: repeating-linear-gradient(angle | to side-or-corner, color-stop1, color-stop2, ...);【属性值】angle 定义渐变的角度方向。从 0deg 到 360deg，默认为 180deg。side-or-corner 指定线性渐变的起始位置。由两个关键字组成：第一个为指定水平位置(left 或 right)，第二个为指定垂直位置（top 或bottom）。 顺序是随意的，每个关键字都是可选的。color-stop1, color-stop2,... 指定渐变的起止颜色，由颜色值、停止位置（可选，使用百分比指定）组成。 示例1234567#grad1 &#123; height: 200px; background: -webkit-repeating-linear-gradient(45deg,red,blue 7%,green 10%); /* For Safari 5.1 to 6.0 */ background: -o-repeating-linear-gradient(45deg,red,blue 7%,green 10%); /* For Opera 11.1 to 12.0 */ background: -moz-repeating-linear-gradient(45deg,red,blue 7%,green 10%); /* For Firefox 3.6 to 15 */ background: repeating-linear-gradient(45deg,red,blue 7%,green 10%); /* 标准语法 (必须在最后) */&#125; 重复径向渐变repeating-radial-gradient()用重复的径向渐变创建图像。用法类似radial-gradient()。]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5笔记]]></title>
    <url>%2F2016%2F01%2F30%2Fweb%2FHTML%2FHTML5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录HTML5笔记。 视频video 语法格式 controls 属性供添加播放、暂停和音量控件。 video标签中间可插入文本作为浏览器不支持时的错误提示； video元素允许多个 source 元素。source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式： 12345&lt;video width="320" height="240" controls="controls"&gt; &lt;source src="movie.ogg" type="video/ogg"&gt; &lt;source src="movie.mp4" type="video/mp4"&gt; Your browser does not support the video tag.&lt;/video&gt; 视频格式当前，video 元素支持三种视频格式： 123Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件 标签属性 autoplay=”autoplay”：如果出现该属性，则视频在就绪后马上播放。 controls=”controls”：如果出现该属性，则向用户显示控件，比如播放按钮。 loop=”loop” 如果出现该属性，则当媒介文件完成播放后再次开始播放。 preload=”auto” 1234567如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 &quot;autoplay&quot;，则忽略该属性。可能的值：auto - 当页面加载后载入整个视频meta - 当页面加载后只载入元数据none - 当页面加载后不载入视频 src=”url”：要播放的视频的 URL。 height：设置视频播放器的高度。 width：设置视频播放器的宽度。 poster=”url”：规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。 muted=”muted”：规定视频的音频输出应该被静音。 DOM控制 HTML5 video元素同样拥有方法、属性和事件。 方法用于播放、暂停以及加载等。 属性（比如时长、音量等）可以被读取或设置。 DOM 事件能够通知您，比方说，video 元素开始播放、已暂停，已停止，等等。 音频audio 语法格式 controls 属性供添加播放、暂停和音量控件。 audio标签中间可插入文本作为浏览器不支持时的错误提示； audio 元素允许多个 source 元素。source 元素可以链接不同的音频文件。浏览器将使用第一个可识别的格式； 12345&lt;audio controls="controls"&gt; &lt;source src="song.ogg" type="audio/ogg"&gt; &lt;source src="song.mp3" type="audio/mpeg"&gt;Your browser does not support the audio tag.&lt;/audio&gt; 音频格式audio 元素支持三种音频格式： Ogg Vorbis MP3 Wav 标签属性 autoplay=”autoplay”：如果出现该属性，则视频在就绪后马上播放。 controls=”controls”：如果出现该属性，则向用户显示控件，比如播放按钮。 loop=”loop” 如果出现该属性，则当媒介文件完成播放后再次开始播放。 preload=”auto” 1234567如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 &quot;autoplay&quot;，则忽略该属性。可能的值：auto - 当页面加载后载入整个视频meta - 当页面加载后只载入元数据none - 当页面加载后不载入视频 src=”url”：要播放的视频的 URL。 muted=”muted”：规定视频的音频输出应该被静音。 拖放概述 即抓取对象以后拖到另一个位置。 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 拖放步骤配置被拖动元素121. 设置元素为可拖放：draggable=&quot;true&quot;2. 元素被拖动时，指定事件：ondragstart=&quot;drag(event)&quot;,设置被拖动的数据类型和值：ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id)。 配置目标容器 容器设置放置被拖动的数据: ondragover=”allowDrop(event)” 12ondragover默认无法将数据/元素放置到其他元素中。如果需要设置允许放置，必须通过event.preventDefault()阻止对元素的默认处理方式。 放置被拖数据时发生ondrop事件，指定处理方法：ondrop=”drop(event)” 1231&gt; drop需要调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）；2&gt; 通过 dataTransfer.getData(&quot;Text&quot;) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。3&gt; 把被拖元素追加到放置元素（目标元素）中 示例代码123456789101112131415161718192021222324252627&lt;script&gt; function drag(ev)&#123; // setData方法设置被拖数据的数据类型和值： ev.dataTransfer.setData("Text",ev.target.id); &#125; function allowDrop(ev)&#123; // 元素默认无法防止，阻止默认处理方式； ev.preventDefault(); &#125; function drop(ev)&#123; // 避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开） ev.preventDefault(); // 获得被拖的数据 var data=ev.dataTransfer.getData("Text"); // 被拖元素追加到放置元素（目标元素）中 ev.target.appendChild(document.getElementById(data)); &#125;&lt;/script&gt;&lt;div id="divX" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt;&lt;img id="dragX" draggable="true" ondragstart="drag(event)" /&gt; 参考DataTransferDataTransfer(MDN注释) 对象用来保存，通过拖放动作，拖动到浏览器的数据；这个对象在所有的拖动事件属性dataTransfer 都是可用的，但是不能单独创建。 方法 obj.setData(type,data)：设置被拖数据的数据类型和值；1234为一个给定的类型设置数据。如果该数据类型不存在，它将添加到的末尾，这样类型列表中的最后一个项目将是新的格式。如果已经存在的数据类型，替换相同的位置的现有数据。就是，当更换相同类型的数据时，不会更改类型列表的顺序。 Canvas概述 HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。 Canvas可以用JavaScript在上面绘制各种图表、动画等。 画布是一个矩形区域，您可以控制其每一像素。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 JavaScript 使用 id 来寻找 canvas 元素; js通过getContext(“2d|3d”)创建用于绘制的对象； 12345&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;&lt;script&gt; var c=document.getElementById("myCanvas"); var cxt=c.getContext("2d"); &lt;/script&gt; 与svg比较 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 Canvas支持 由于浏览器对HTML5标准支持不一致，通常在内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略内部的HTML，如果浏览器不支持Canvas，它将显示内部的HTML； 123&lt;canvas id="test-stock" width="300" height="200"&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; js判断浏览器是否支持Canvas，用canvas.getContext； 12345678910111213&lt;!-- HTML代码 --&gt;&lt;canvas id="test-canvas" width="200" heigth="100"&gt; &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById('test-canvas'); if (canvas.getContext) &#123; console.log('你的浏览器支持Canvas!'); &#125; else &#123; console.log('你的浏览器不支持Canvas!'); &#125;&lt;/script&gt; 2D图2D Canvas对象getContext(‘2d’)方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。 1var ctx = canvas.getContext('2d'); 坐标系统Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。 绘制线条1234567891011121314&lt;script type="text/javascript"&gt; var c=document.getElementById("myCanvas"); var cxt=c.getContext("2d"); // 把路径移动到画布中的指定点，不创建线条 cxt.moveTo(10,10); // 添加一个新点，然后在画布中创建从该点到最后指定点的线条 cxt.lineTo(150,50); cxt.lineTo(10,50); // 实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。 cxt.stroke();&lt;/script&gt;&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #c3c3c3;"&gt;Your browser does not support the canvas element.&lt;/canvas&gt; 路径图形1234567891011121314151617181920var canvas = document.getElementById('test-shape-canvas');var ctx = canvas.getContext('2d');ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明ctx.fillStyle = '#dddddd'; // 设置颜色ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色// 利用Path绘制复杂路径:var path=new Path2D();// 创建弧/曲线（用于创建圆形或部分圆）path.arc(75, 75, 50, 0, Math.PI*2, true);path.moveTo(110,75);path.arc(75, 75, 35, 0, Math.PI, false);path.moveTo(65, 65);path.arc(60, 65, 5, 0, Math.PI*2, true);path.moveTo(95, 65);path.arc(90, 65, 5, 0, Math.PI*2, true);// 线条颜色ctx.strokeStyle = '#0000ff';// 绘制ctx.stroke(path); 绘制文本绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致； 带阴影的文字1234567891011var canvas = document.getElementById('test-shape-canvas');var ctx = canvas.getContext('2d');ctx.clearRect(0, 0, canvas.width, canvas.height);ctx.shadowOffsetX = 2;ctx.shadowOffsetY = 2;ctx.shadowBlur = 2;ctx.shadowColor = '#666666';ctx.font = '24px Arial';ctx.fillStyle = '#333333';ctx.fillText('带阴影的文字', 20, 40); 渐变123456789101112&lt;script type="text/javascript"&gt; var c=document.getElementById("myCanvas"); var cxt=c.getContext("2d"); var grd=cxt.createLinearGradient(0,0,175,50); grd.addColorStop(0,"#FF0000"); grd.addColorStop(1,"#00FF00"); cxt.fillStyle=grd; cxt.fillRect(0,0,175,50);&lt;/script&gt;&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #c3c3c3;"&gt;Your browser does not support the canvas element.&lt;/canvas&gt; 图像12345678910&lt;script type="text/javascript"&gt; var c=document.getElementById("myCanvas"); var cxt=c.getContext("2d"); var img=new Image() img.src="flower.png" cxt.drawImage(img,0,0);&lt;/script&gt;&lt;canvas id="myCanvas" width="200" height="100" style="border:1px solid #c3c3c3;"&gt;Your browser does not support the canvas element.&lt;/canvas&gt; 绘制其他Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。 如果要实现非常复杂的操作，考虑以下优化方案： 1234- 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；- 尽量使用整数坐标而不是浮点数；- 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；- 背景图片如果不变可以直接用&lt;img&gt;标签并放到最底层。 3D图HTML5有一个WebGL规范，允许在Canvas中绘制3D图形； 1var gl = canvas.getContext("webgl"); 内联SVG参考网站 SVG教程 概念 SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用于定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG 是万维网联盟的标准 特点 SVG 图像可通过文本编辑器来创建和修改 SVG 图像可被搜索、索引、脚本化或压缩 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 与canvas比较 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 浏览器支持Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持内联 SVG。 写入HTML多边形svg图像polygon：1234&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="190"&gt; &lt;polygon points="100,10 40,180 190,60 10,60 160,180" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" /&gt;&lt;/svg&gt; 地理定位 HTML5 Geolocation API 用于获得用户的地理位置。 鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。 Navigator获取 Navigator对象包含有关浏览器的信息。 使用 getCurrentPosition() 方法来获得用户的位置。 123456789101112131415161718192021222324252627282930313233&lt;script type="text/javascript"&gt; function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition, showError); &#125; else &#123; alert("该浏览器不支持定位功能！"); &#125; &#125; function showPosition(position) &#123; alert("纬度：" + position.coords.latitude + "\n经度：" + position.coords.longitude) &#125; function showError(error) &#123; switch (error.code) &#123; case error.PERMISSION_DENIED: alert("用户拒绝对获取地理位置的请求"); break; case error.POSITION_UNAVAILABLE: alert("位置信息是不可用的"); break; case error.TIMEOUT: alert("请求用户地理位置超时"); break; case error.UNKNOWN_ERROR: alert("未知错误"); break; &#125; &#125;&lt;/script&gt;&lt;button onclick="getLocation()"&gt;点击&lt;/button&gt; Web存储HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储 localStorage localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 存储数据以key-value形式，value只能是基础数据类型，不能是对象； 操作123456//查看window.localStorage;//设置localStorage.setItem("lastname", "Gates");//获取localStorage.getItem("lastname") 浏览器支持123456789function testM() &#123; // 校验浏览器是否支持 if (typeof(Storage) !== undefined) &#123; localStorage.setItem("lastname", "Gates"); alert(localStorage.getItem("lastname")); &#125; else &#123; alert("抱歉！您的浏览器不支持 Web Storage ...") &#125;&#125; sessionStorage sessionStorage方法存储的数据在会话结束就会删除。 存储数据以key-value形式，value只能是基础数据类型，不能是对象； 操作方法同localStorage类似； 12345678910function testM() &#123; // 校验浏览器是否支持 if (typeof(Storage) !== undefined) &#123; sessionStorage.setItem("lastname", "Gates"); sessionStorage.setItem("x","xxx") alert(sessionStorage.getItem("lastname")); &#125; else &#123; alert("抱歉！您的浏览器不支持 Web Storage ...") &#125;&#125; 应用程序缓存HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 优势 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 浏览器支持 所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。 浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 缓存 每个指定了manifest的页面在用户对其访问时都会被缓存。 1234&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;...&lt;/html&gt; manifest文件 manifest 文件的建议的文件扩展名是：”.appcache”。 manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。 manifest 文件可分为三个部分： 123CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 123456789101112131415CACHE MANIFEST/theme.css/logo.gif/main.jsNETWORK:login.aspNETWORK:# 使用星号来指示所有其他资源/文件都需要因特网连接：*FALLBACK:# 第一个 URI 是资源，第二个是替补。/html5/ /404.html 更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改（参阅下面的提示） 由程序来更新应用缓存 更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 Web Workerweb worker是运行在后台的JavaScript，不会影响页面的性能。 浏览器支持所有主流浏览器均支持 web worker，除了Internet Explorer。 检测是否支持123456if(typeof(Worker)!=="undefined")&#123; // Yes! Web worker support! // Some code.....&#125;else&#123; // Sorry! No Web Worker support..&#125; 语法 创建外部工作脚本test_worker.js，通过postMessage发送消息； 12345678var i=0;function timedCount()&#123; i=i+1; // 向HTML页面传回一段消息 postMessage(i); setTimeout(timedCount,1000);&#125;timedCount(); 创建worker对象，调用外部脚本发消息，并接收消息； 12345678910111213141516171819202122232425&lt;p&gt;计数: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick="startWorker()"&gt;开始 Worker&lt;/button&gt;&lt;button onclick="stopWorker()"&gt;停止 Worker&lt;/button&gt;&lt;script&gt; var w; function startWorker() &#123; if (typeof(Worker) !== "undefined") &#123; if (typeof(w) === "undefined") &#123; w = new Worker("test_worker.js"); &#125; // 接收postMessage发送的消息 w.onmessage = function (event) &#123; document.getElementById("result").innerHTML = event.data; &#125;; &#125; else &#123; document.getElementById("result").innerHTML = "Sorry, your browserdoes not support Web Workers..."; &#125; &#125; function stopWorker() &#123; w.terminate(); &#125;&lt;/script&gt; 服务器发送事件HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。 Server-Sent事件Server-Sent事件指的是网页自动获取来自服务器的更新。 EventSource对象用于接收服务器事件； 方法：1234事件 描述onopen 当通往服务器的连接被打开onmessage 当接收到消息onerror 当错误发生 浏览器支持所有主流浏览器均支持服务器发送事件，除了Internet Explorer。 js验证支持1234567if (typeof(EventSource) !== "undefined") &#123; // Yes! Server-sent events support! // Some code.....&#125;else &#123; // Sorry! No server-sent events support..&#125; 使用步骤 服务器端事件流的语法是非常简单的。把 “Content-Type” 报头设置为 “text/event-stream”。可以开始发送事件流了。 创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”），通过onmessage接收通知； 1234var source=new EventSource("demo_sse.php");source.onmessage=function(event)&#123; document.getElementById("result").innerHTML+=event.data + "&lt;br /&gt;";&#125;; 表单HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。 输入类型 email url number range Date pickers (date, month, week, time, datetime, datetime-local) search color email email 类型用于应该包含 e-mail 地址的输入域。 在提交表单时，会自动验证 email 域的值； 注意：未填写时会验证通过。 1&lt;input type="email" name="user_email" /&gt; url url 类型用于应该包含 URL 地址的输入域。 在提交表单时，会自动验证 url 域的值。 注意：未填写时会验证通过。 1&lt;input type="url" name="user_url" /&gt; number number 类型用于应该包含数值的输入域。 您还能够设定对所接受的数字的限定； 12345属性 值 描述max number 规定允许的最大值min number 规定允许的最小值step number 规定合法的数字间隔（如果 step=&quot;3&quot;，则合法的数是 -3,0,3,6 等）value number 规定默认值 注意：未填写时会验证通过。 1&lt;input type="number" name="points" min="1" max="10" /&gt; range range 类型用于应该包含一定范围内数字值的输入域。 range 类型显示为滑动条。 您还能够设定对所接受的数字的限定： 1234max number 规定允许的最大值min number 规定允许的最小值step number 规定合法的数字间隔（如果 step=&quot;3&quot;，则合法的数是 -3,0,3,6 等）value number 规定默认值 注意：未填写时会验证通过。 1&lt;input type="range" name="points" min="1" max="10" /&gt; Date PickersHTML5 拥有多个可供选取日期和时间的新输入类型： date - 选取日、月、年 month - 选取月、年 week - 选取周和年 time - 选取时间（小时和分钟） datetime - 选取时间、日、月、年（UTC 时间） datetime-local - 选取时间、日、月、年（本地时间） 1&lt;input type="date" name="user_date" /&gt; search提供可输入的搜索框，可以清空；1&lt;input type="search" name="user_date" /&gt; color弹出颜色框，用于选择颜色；1&lt;input type="color" name="user_date" /&gt; 新增表单元素新的表单元素： datalist keygen output datalist datalist 元素规定输入域的选项列表。 列表是通过 datalist 内的 option 元素创建的。 如需把datalist绑定到输入域，请用输入域的list属性引用datalist的id; 123456&lt;input type="url" list="url_list" name="link" /&gt;&lt;datalist id="url_list"&gt; &lt;option label="W3School" value="http://www.W3School.com.cn" /&gt; &lt;option label="Google" value="http://www.google.com" /&gt; &lt;option label="Microsoft" value="http://www.microsoft.com" /&gt;&lt;/datalist&gt; keygen keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。 12345&lt;form action="demo_form.asp" method="get"&gt;Username: &lt;input type="text" name="usr_name" /&gt;Encryption: &lt;keygen name="security" /&gt;&lt;input type="submit" /&gt;&lt;/form&gt; outputoutput 元素用于不同类型的输出，比如计算或脚本输出,默认没有占位样式； 1&lt;output id="result"&gt;&lt;/output&gt; 新增表单属性 form标签属性： autocomplete novalidate input标签属性： autocomplete autofocus form form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget) height 和 width list min, max 和 step multiple pattern (regexp) placeholder required autocomplete 用户输入后，再次重载页面，输入时，会显示输入过的选项； autocomplete 适用于 标签，对以下类型的input标签有效：text, search, url, telephone, email, password, datepickers, range 以及 color。 123456&lt;form action="demo_form.asp" method="get" autocomplete="on"&gt;First name: &lt;input type="text" name="fname" /&gt;&lt;br /&gt;Last name: &lt;input type="text" name="lname" /&gt;&lt;br /&gt;E-mail: &lt;input type="email" name="email" autocomplete="off" /&gt;&lt;br /&gt;&lt;input type="submit" /&gt;&lt;/form&gt; autofocus autofocus 属性规定在页面加载时，域自动地获得焦点。 autofocus 属性适用于所有 标签的类型。 1&lt;input type="text" name="user_name" autofocus="autofocus" /&gt; form form 属性规定输入域所属的一个或多个表单。 form 属性适用于所有input标签的类型。 form 属性必须引用所属表单的 id： 12345&lt;form action="demo_form.asp" method="get" id="user_form"&gt;First name:&lt;input type="text" name="fname" /&gt;&lt;input type="submit" /&gt;&lt;/form&gt;Last name: &lt;input type="text" name="lname" form="user_form" /&gt; 表单重写属性 表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。 表单重写属性适用于以下类型的input标签：submit 和 image。 对于创建不同的提交按钮很有帮助。 1234567表单重写属性有：- formaction - 重写表单的 action 属性- formenctype - 重写表单的 enctype 属性- formmethod - 重写表单的 method 属性- formnovalidate - 重写表单的 novalidate 属性- formtarget - 重写表单的 target 属性 list list 属性规定输入域的 datalist。datalist 是输入域的选项列表。 list 属性适用于以下类型的input标签：text, search, url, telephone, email, date pickers, number, range 以及 color。 123456&lt;input type="url" list="url_list" name="link" /&gt;&lt;datalist id="url_list"&gt;&lt;option label="W3Schools" value="http://www.w3school.com.cn" /&gt;&lt;option label="Google" value="http://www.google.com" /&gt;&lt;option label="Microsoft" value="http://www.microsoft.com" /&gt;&lt;/datalist&gt; min、max和stepmin、max 和 step 属性用于为包含数字或日期的input 类型规定限定（约束）。 min、max 和 step 属性适用于以下类型的input标签：date pickers、number 以及 range。 下面的例子显示一个数字域，该域接受介于 0 到 10 之间的值，且步进为 3（即合法的值为 0、3、6 和 9）： 123- max 属性规定输入域所允许的最大值。- min 属性规定输入域所允许的最小值。- step 属性为输入域规定合法的数字间隔（如果 step=&quot;3&quot;，则合法的数是 -3,0,3,6 等）。 multiple multiple 属性规定输入域中可选择多个值。 multiple 属性适用于以下类型的input标签：email 和 file。 1&lt;input type="file" name="img" multiple="multiple" /&gt; novalidate novalidate 属性规定在提交表单时不应该验证 form 或 input 域。 novalidate 属性适用于form,对以类型的input标签验证：text, search, url, telephone, email, password, date pickers, range 以及 color. 1234&lt;form action="demo_form.asp" method="get" novalidate="true"&gt;E-mail: &lt;input type="email" name="user_email" /&gt;&lt;input type="submit" /&gt;&lt;/form&gt; pattern pattern 属性规定用于验证 input 域的模式（pattern）。 模式（pattern） 是正则表达式。 pattern 属性适用于以下类型的input标签：text, search, url, telephone, email 以及 password。 12&lt;input type="text" name="country_code"pattern="[A-z]&#123;3&#125;" title="Three letter country code" /&gt; placeholder placeholder 属性提供一种提示（hint），描述输入域所期待的值。 placeholder 属性适用于以下类型的input标签：text, search, url, telephone, email 以及 password。 提示（hint）会在输入域为空时显示出现，会在输入域获得焦点时消失; 1&lt;input type="search" name="user_search" placeholder="Search W3School" /&gt; required required 属性规定必须在提交之前填写输入域（不能为空）。 required 属性适用于以下类型的input标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。 1&lt;input type="text" name="usr_name" required="required" /&gt; 参考参考网站 w3school中文网 Canvas2D12HTML5 &lt;canvas&gt; 标签用于绘制图像（通过脚本，通常是 JavaScript）。getContext() 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。 此处：提供完整的 getContext(“2d”) 对象属性和方法，可用于在画布上绘制文本、线条、矩形、圆形等等。 颜色.样式和阴影1234567属性 描述fillStyle 设置或返回用于填充绘画的颜色、渐变或模式strokeStyle 设置或返回用于笔触的颜色、渐变或模式shadowColor 设置或返回用于阴影的颜色shadowBlur 设置或返回用于阴影的模糊级别shadowOffsetX 设置或返回阴影距形状的水平距离shadowOffsetY 设置或返回阴影距形状的垂直距离 12345方法 描述createLinearGradient() 创建线性渐变（用在画布内容上）createPattern() 在指定的方向上重复指定的元素createRadialGradient() 创建放射状/环形的渐变（用在画布内容上）addColorStop() 规定渐变对象中的颜色和停止位置 线条样式12345属性 描述lineCap 设置或返回线条的结束端点样式lineJoin 设置或返回两条线相交时，所创建的拐角类型lineWidth 设置或返回当前的线条宽度miterLimit 设置或返回最大斜接长度 矩形12345方法 描述rect() 创建矩形fillRect() 绘制“被填充”的矩形strokeRect() 绘制矩形（无填充）clearRect() 在给定的矩形内清除指定的像素 路径12345678910111213方法 描述fill() 填充当前绘图（路径）stroke() 绘制已定义的路径beginPath() 起始一条路径，或重置当前路径moveTo() 把路径移动到画布中的指定点，不创建线条closePath() 创建从当前点回到起始点的路径lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条clip() 从原始画布剪切任意形状和尺寸的区域quadraticCurveTo() 创建二次贝塞尔曲线bezierCurveTo() 创建三次方贝塞尔曲线arc() 创建弧/曲线（用于创建圆形或部分圆）arcTo() 创建两切线之间的弧/曲线isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换123456方法 描述scale() 缩放当前绘图至更大或更小rotate() 旋转当前绘图translate() 重新映射画布上的 (0,0) 位置transform() 替换绘图的当前转换矩阵setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本1234属性 描述font 设置或返回文本内容的当前字体属性textAlign 设置或返回文本内容的当前对齐方式textBaseline 设置或返回在绘制文本时使用的当前文本基线 1234方法 描述fillText() 在画布上绘制“被填充的”文本strokeText() 在画布上绘制文本（无填充）measureText() 返回包含指定文本宽度的对象 图像绘制12方法 描述drawImage() 向画布上绘制图像、画布或视频 像素操作1234属性 描述width 返回 ImageData 对象的宽度height 返回 ImageData 对象的高度data 返回一个对象，其包含指定的 ImageData 对象的图像数据 1234方法 描述createImageData() 创建新的、空白的 ImageData 对象getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 合成123属性 描述globalAlpha 设置或返回绘图的当前 alpha 或透明值globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 其他123456方法 描述save() 保存当前环境的状态restore() 返回之前保存过的路径状态和属性createEvent() getContext() toDataURL() 视频/音频121. HTML5 DOM 为 &lt;audio&gt; 和 &lt;video&gt; 元素提供了方法、属性和事件。2. 方法、属性和事件允许您使用 JavaScript 来操作 &lt;audio&gt; 和 &lt;video&gt; 元素。 方法 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 属性 audioTracks 返回表示可用音轨的 AudioTrackList 对象 autoplay 设置或返回是否在加载完成后随即播放音频/视频 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 loop 设置或返回音频/视频是否应在结束时重新播放 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 preload 设置或返回音频/视频是否应该在页面加载后进行加载 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 src 设置或返回音频/视频元素的当前来源 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 事件 abort 当音频/视频的加载已放弃时 canplay 当浏览器可以播放音频/视频时 canplaythrough 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange 当音频/视频的时长已更改时 emptied 当目前的播放列表为空时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 loadeddata 当浏览器已加载音频/视频的当前帧时 loadedmetadata 当浏览器已加载音频/视频的元数据时 loadstart 当浏览器开始查找音频/视频时 pause 当音频/视频已暂停时 play 当音频/视频已开始或不再暂停时 playing 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress 当浏览器正在下载音频/视频时 ratechange 当音频/视频的播放速度已更改时 seeked 当用户已移动/跳跃到音频/视频中的新位置时 seeking 当用户开始移动/跳跃到音频/视频中的新位置时 stalled 当浏览器尝试获取媒体数据，但数据不可用时 suspend 当浏览器刻意不获取媒体数据时 timeupdate 当目前的播放位置已更改时 volumechange 当音量已更改时 waiting 当视频由于需要缓冲下一帧而停止 全局属性下面的全局属性可用于任何 HTML 元素。 accesskey 规定激活元素的快捷键。 class 规定元素的一个或多个类名（引用样式表中的类）。 contenteditable 规定元素内容是否可编辑。 1&lt;p contenteditable="true"&gt;这是一个可编辑的段落。&lt;/p&gt; contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。 data-* 用于存储页面或应用程序的私有定制数据。 1&lt;li data-animal-type="鸟类"&gt;喜鹊&lt;/li&gt; dir 规定元素中内容的文本方向。 draggable 规定元素是否可拖动。 dropzone 规定在拖动被拖动数据时是否进行复制、移动或链接。 hidden 规定元素仍未或不再相关。 id 规定元素的唯一 id。 lang 规定元素内容的语言。 spellcheck 规定是否对元素进行拼写和语法检查。 style 规定元素的行内 CSS 样式。 tabindex 规定元素的 tab 键次序。 title 规定有关元素的额外信息。 translate 规定是否应该翻译元素内容。 全局事件属性列出了添加到 HTML 元素以定义事件动作的全局事件属性，通过js方法作为值来驱动. Window事件属性1针对window 对象触发的事件（应用到 &lt;body&gt; 标签）： 123456789101112131415161718属性 值 描述onafterprint script 文档打印之后运行的脚本。onbeforeprint script 文档打印之前运行的脚本。onbeforeunload script 文档卸载之前运行的脚本。onerror script 在错误发生时运行的脚本。onhaschange script 当文档已改变时运行的脚本。onload script 页面结束加载之后触发。onmessage script 在消息被触发时运行的脚本。onoffline script 当文档离线时运行的脚本。ononline script 当文档上线时运行的脚本。onpagehide script 当窗口隐藏时运行的脚本。onpageshow script 当窗口成为可见时运行的脚本。onpopstate script 当窗口历史记录改变时运行的脚本。onredo script 当文档执行撤销（redo）时运行的脚本。onresize script 当浏览器窗口被调整大小时触发。onstorage script 在 Web Storage 区域更新后运行的脚本。onundo script 在文档执行 undo 时运行的脚本。onunload script 一旦页面已下载时触发（或者浏览器窗口已被关闭）。 Form事件由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中）。 123456789101112属性 值 描述onblur script 元素失去焦点时运行的脚本。onchange script 在元素值被改变时运行的脚本。oncontextmenu script 当上下文菜单被触发时运行的脚本。onfocus script 当元素获得焦点时运行的脚本。onformchange script 在表单改变时运行的脚本（失效）。onforminput script 当表单获得用户输入时运行的脚本。oninput script 当元素获得用户输入时运行的脚本。oninvalid script 当元素无效时运行的脚本。onreset script 当表单中的重置按钮被点击时触发。HTML5 中不支持。onselect script 在元素中文本被选中后触发。onsubmit script 在提交表单时触发。 Keyboard事件1234属性 值 描述onkeydown script 在用户按下按键时触发。onkeypress script 在用户敲击按钮时触发。onkeyup script 当用户释放按键时触发。 Mouse事件由鼠标或类似用户动作触发的事件： 1234567891011121314151617属性 值 描述onclick script 元素上发生鼠标点击时触发。ondblclick script 元素上发生鼠标双击时触发。ondrag script 元素被拖动时运行的脚本。ondragend script 在拖动操作末端运行的脚本。ondragenter script 当元素元素已被拖动到有效拖放区域时运行的脚本。ondragleave script 当元素离开有效拖放目标时运行的脚本。ondragover script 当元素在有效拖放目标上正在被拖动时运行的脚本。ondragstart script 在拖动操作开端运行的脚本。ondrop script 当被拖元素正在被拖放时运行的脚本。onmousedown script 当元素上按下鼠标按钮时触发。onmousemove script 当鼠标指针移动到元素上时触发。onmouseout script 当鼠标指针移出元素时触发。onmouseover script 当鼠标指针移动到元素上时触发。onmouseup script 当在元素上释放鼠标按钮时触发。onmousewheel script 当鼠标滚轮正在被滚动时运行的脚本。onscroll script 当元素滚动条被滚动时运行的脚本。 Media事件123由媒介（比如视频、图像和音频）触发的事件。适用于所有 HTML 元素，但常见于媒介元素中。比如 &lt;audio&gt;、&lt;embed&gt;、&lt;img&gt;、&lt;object&gt; 以及 &lt;video&gt;）: 123456789101112131415161718192021222324属性 值 描述onabort script 在退出时运行的脚本。oncanplay script 当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。oncanplaythrough script 当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。ondurationchange script 当媒介长度改变时运行的脚本。onemptied script 当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。onended script 当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。onerror script 当在文件加载期间发生错误时运行的脚本。onloadeddata script 当媒介数据已加载时运行的脚本。onloadedmetadata script 当元数据（比如分辨率和时长）被加载时运行的脚本。onloadstart script 在文件开始加载且未实际加载任何数据前运行的脚本。onpause script 当媒介被用户或程序暂停时运行的脚本。onplay script 当媒介已就绪可以开始播放时运行的脚本。onplaying script 当媒介已开始播放时运行的脚本。onprogress script 当浏览器正在获取媒介数据时运行的脚本。onratechange script 每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。onreadystatechange script 每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。onseeked script 当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。onseeking script 当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。onstalled script 在浏览器不论何种原因未能取回媒介数据时运行的脚本。onsuspend script 在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。ontimeupdate script 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。onvolumechange script 每当音量改变时（包括将音量设置为静音）时运行的脚本。onwaiting script 当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本 HTTP状态消息当浏览器从 web 服务器请求服务时，可能会发生错误。返回一系列状态码。 1xx信息123消息: 描述:100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 2xx成功12345678消息: 描述:200 OK 请求成功（其后是对GET和POST请求的应答文档。）201 Created 请求被创建完成，同时新的资源被创建。202 Accepted 供处理的请求已被接受，但是处理未完成。203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。 3xx重定向12345678300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。301 Moved Permanently 所请求的页面已经转移至新的url。302 Found 所请求的页面已经临时转移至新的url。303 See Other 所请求的页面可在别的url下被找到。304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。307 Temporary Redirect 被请求的页面已经临时移至新的url。 4xx客户端错误12345678910111213141516171819消息: 描述:400 Bad Request 服务器未能理解请求。401 Unauthorized 被请求的页面需要用户名和密码。402 Payment Required 此代码尚无法使用。403 Forbidden 对被请求页面的访问被禁止。404 Not Found 服务器无法找到被请求的页面。405 Method Not Allowed 请求中指定的方法不被允许。406 Not Acceptable 服务器生成的响应无法被客户端所接受。407 Proxy Authentication Required 用户必须首先使用代理服务器进行验证，这样请求才会被处理。408 Request Timeout 请求超出了服务器的等待时间。409 Conflict 由于冲突，请求无法被完成。410 Gone 被请求的页面不可用。411 Length Required &quot;Content-Length&quot; 未被定义。如果无此内容，服务器不会接受请求。412 Precondition Failed 请求中的前提条件被服务器评估为失败。413 Request Entity Too Large 由于所请求的实体的太大，服务器不会接受请求。414 Request-url Too Long 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。415 Unsupported Media Type 由于媒介类型不被支持，服务器不会接受请求。416 服务器不能满足客户在请求中指定的Range头。417 Expectation Failed 5xx服务器错误1234567消息: 描述:500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。501 Not Implemented 请求未完成。服务器不支持所请求的功能。502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。503 Service Unavailable 请求未完成。服务器临时过载或当机。504 Gateway Timeout 网关超时。505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本。]]></content>
      <categories>
        <category>大前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记]]></title>
    <url>%2F2016%2F01%2F23%2Fweb%2FjQuery%2FjQuery%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录jQuery的笔记。 参考资料API中文在线文档 http://www.css88.com/jqapi-1.9/ http://jquery.cuishifeng.cn/index.html jQuery概述 $是著名的jQuery符号； jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名。 jQuery(selector, context)===$; jquery的定义相当于1234window.jQuery; // jQuery(selector, context)window.$; // jQuery(selector, context)$ === jQuery; // truetypeof($); // 'function' $函数名占用如果$这个变量不幸地被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量： 1234$; // jQuery(selector, context)jQuery.noConflict();$; // undefinedjQuery; // jQuery(selector, context) 选择器概述使用格式类似： 1$('dom_selector') 返回的对象是jQuery对象是数组[]； jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。 基础选择器ID按ID查找 123// 查找&lt;div id="abc"&gt;:var div = $('#abc');// 返回：[&lt;div id="abc"&gt;...&lt;/div&gt;] tag按tag查找 按tag查找只需要写上tag名称就可以了： 12var ps = $('p'); // 返回所有&lt;p&gt;节点ps.length; // 数一数页面有多少个&lt;p&gt;节点 class按class查找注意在class名称前加一个.： 1234var a = $('.red'); // 所有节点包含`class="red"`都将返回// 例如:// &lt;div class="red"&gt;...&lt;/div&gt;// &lt;p class="green red"&gt;...&lt;/p&gt; 多class节点1234var a = $('.red.green'); // 注意没有空格！// 符合条件的节点：// &lt;div class="red green"&gt;...&lt;/div&gt;// &lt;div class="blue green red"&gt;...&lt;/div&gt; 属性按属性查找 一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找： 123var email = $('[name=email]'); // 找出&lt;??? name="email"&gt;var passwordInput = $('[type=password]'); // 找出&lt;??? type="password"&gt;var a = $('[items="A B"]'); // 找出&lt;??? items="A B"&gt; 前后缀查找1234var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM// 例如: name="icon-1", name="icon-2"var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM// 例如: name="startswith", name="endswith"js class属性查找12var icons = $('[class^="icon-"]'); // 找出所有class包含至少一个以`icon-`开头的DOM// 例如: class="icon-clock", class="abc icon-home" 组合查找概述可以将id、class、tag、属性等基础选择器组合起来进行查找； 实例查找input中name是email的属性：1var emailInput = $('input[name=email]'); // 不会找出&lt;div name="email"&gt; 根据tag和class来组合查找 1var tr = $('tr.red'); // 找出&lt;tr class="red ..."&gt;...&lt;/tr&gt; 多项选择器 选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素; 多项选择器就是把多个选择器用,组合起来一块选; 12$('p,div'); // 把&lt;p&gt;和&lt;div&gt;都选出来$('p.red,p.green'); // 把&lt;p class="red"&gt;和&lt;p class="green"&gt;都选出来 层级选择器概述如果DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开. 父子层级选择12345678&lt;!-- HTML结构 --&gt;&lt;div class="testing"&gt; &lt;ul class="lang"&gt; &lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt; &lt;li class="lang-python"&gt;Python&lt;/li&gt; &lt;li class="lang-lua"&gt;Lua&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234$('ul.lang li.lang-javascript'); // [&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]$('div.testing li.lang-javascript'); // [&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]$('ul.lang li');$('form[name=upload] input'); 多层选择1$('form.test p input'); // 在form表单选择被&lt;p&gt;包含的&lt;input&gt; 直属子选择器child节点必须是parent节点的直属子节点1$('parent&gt;child') 实例：12$('ul.lang&gt;li.lang-javascript'); // 可以选出[&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]$('div.testing&gt;li.lang-javascript'); // [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系 伪类过滤器过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果： 一般过滤12345678$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点$('ul.lang li:first-child'); // 仅选出JavaScript$('ul.lang li:last-child'); // 仅选出Lua$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素$('div:visible'); // 所有可见的div$('div:hidden'); // 所有隐藏的div 表单相关针对表单元素，jQuery还有一组特殊的选择器： 123456789:input：可以选择&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt;；:file：可以选择&lt;input type=&quot;file&quot;&gt;，和input[type=file]一样；:checkbox：可以选择复选框，和input[type=checkbox]一样；:radio：可以选择单选框，和input[type=radio]一样；:focus：可以选择当前输入焦点的元素，例如把光标放到一个&lt;input&gt;上，用$(&apos;input:focus&apos;)就可以选出；:checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(&apos;input[type=radio]:checked&apos;)；:enabled：可以选择可以正常输入的&lt;input&gt;、&lt;select&gt;等，也就是没有灰掉的输入；:disabled：和:enabled正好相反，选择那些不能输入的。 查找和过滤当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。 样本： 12345678&lt;!-- HTML结构 --&gt;&lt;ul class="lang"&gt; &lt;li class="js dy"&gt;JavaScript&lt;/li&gt; &lt;li class="dy"&gt;Python&lt;/li&gt; &lt;li id="swift"&gt;Swift&lt;/li&gt; &lt;li class="dy"&gt;Scheme&lt;/li&gt; &lt;li name="haskell"&gt;Haskell&lt;/li&gt;&lt;/ul&gt; 查找向下查找jquery对象的find(selector)方法； 1234var ul = $('ul.lang'); // 获得&lt;ul&gt;var dy = ul.find('.dy'); // 获得JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得Swiftvar hsk = ul.find('[name=haskell]'); // 获得Haskell 向上查找从当前节点开始向上查找，使用parent()方法： 123var swf = $('#swift'); // 获得Swiftvar parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt;var a = swf.parent('.red'); // 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象 同级查找对于位于同一层级的节点，可以通过next()查找后一个，prev()查找前一个； 1234567var swift = $('#swift');swift.next(); // Schemeswift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]swift.prev(); // Pythonswift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy 高阶过滤和函数式编程的map、filter类似，jQuery对象也有类似的方法。 filter 过滤掉不符合选择器条件的节点 12var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme 传入函数，要特别注意函数内部的this被绑定为DOM对象，不是jQuery对象： 1234var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskelllangs.filter(function () &#123; return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点&#125;); // 拿到Swift, Scheme map map()方法把一个jQuery对象包含的若干DOM节点进行处理： 1234var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar arr = langs.map(function () &#123; return this.innerHTML;&#125;).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell'] 其他jQuery对象包含不止一个DOM节点时，first()、last()和slice()方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉： 1234var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child')var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child')var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致 操作DOMDom对象相互转换jQuery对象和DOM对象之间可以互相转化,通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。 123var div = $('#abc'); // jQuery对象var divDom = div.get(0); // 假设存在div，获取第1个DOM元素var another = $(divDom); // 重新把DOM包装为jQuery对象 文本 jQuery对象的jQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本; 无参数调用text()是获取文本，传入参数就变成设置文本,html()类似； 获取文本123456789&lt;!-- HTML结构 --&gt;&lt;ul id="test-ul"&gt; &lt;li class="js"&gt;JavaScript&lt;/li&gt; &lt;li name="book"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript' $('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript'&lt;/script&gt; 修改文本1234var j1 = $('#test-ul li.js');var j2 = $('#test-ul li[name=book]');j1.html('&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;');j2.text('JavaScript &amp; ECMAScript'); css样式概述 修改css样式：调用jQuery对象的css(‘name’, ‘value’)方法； 为了和JavaScript保持一致，CSS属性可以用’background-color’和’backgroundColor’两种格式; Query对象的css()方法可以链式调用； 操作css修改css： 添加样式： 直接使用css(key,value)方法，可以接受一个css样式json对象，如：css({key:value,…})； 修改class属性：addClass()、hasClass()、removeClass(); 1234567891011121314151617181920&lt;!-- HTML结构 --&gt;&lt;ul id="test-css"&gt; &lt;li class="lang dy"&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li class="lang"&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/li&gt; &lt;li class="lang dy"&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li class="lang"&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;li class="lang dy"&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 添加css样式 $('#test-css li.dy&gt;span') .css('background-color', '#ffd351') .css('color', 'red'); // 修改css的class属性 var div = $('#test-div'); div.hasClass('highlight'); // false， class是否包含highlight div.addClass('highlight'); // 添加highlight这个class div.removeClass('highlight'); // 删除highlight这个class&lt;/script&gt; 显隐DOM 要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的; jQuery隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 123var a = $('a[target=_blank]');a.hide(); // 隐藏a.show(); // 显示 DOM大小利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码： 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 DOM属性attr和removeAttrattr()和removeAttr()方法用于操作DOM节点的属性： 1234567// &lt;div id="test-div" name="Test" start="1"&gt;...&lt;/div&gt;var div = $('#test-div');div.attr('data'); // undefined, 属性不存在div.attr('name'); // 'Test'div.attr('name', 'Hello'); // div的name属性变为'Hello'div.removeAttr('name'); // 删除name属性div.attr('name'); // undefined propprop()方法和attr()类似,但是对于选择控件返回boolean的属性(selected、checked)处理有所不同; 123456789&lt;input id="test-radio" type="radio" name="test" checked value="1"&gt;&lt;input id="test-radio" type="radio" name="test" checked="checked" value="1"&gt;&lt;script&gt; // 返回boolean的处理 var radio = $('#test-radio'); radio.attr('checked'); // 'checked' radio.prop('checked'); // true&lt;/script&gt; isis()判断boolean返回值(推荐)；(selected、checked) 12345var radio = $('#test-radio');radio.is(':checked'); // truevar checkbox =$(#test-select)checkbox.is(':selected'); 操作表单对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性： 12345678910111213141516171819202122&lt;input id="test-input" name="email" value=""&gt;&lt;select id="test-select" name="city"&gt; &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt; &lt;option value="SH"&gt;Shanghai&lt;/option&gt; &lt;option value="SZ"&gt;Shenzhen&lt;/option&gt;&lt;/select&gt;&lt;textarea id="test-textarea"&gt;Hello&lt;/textarea&gt;&lt;script&gt; var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea'); input.val(); // 'test' input.val('abc@example.com'); // 文本框的内容已变为abc@example.com select.val(); // 'BJ' select.val('SH'); // 选择框已变为Shanghai textarea.val(); // 'Hello' textarea.val('Hi'); // 文本区域已更新为'Hi'&lt;/script&gt; 修改DOM结构要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法; 添加节点append方法append方法：append()把DOM添加到最后。123【注意】如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加；也就是说，用append()，你可以移动一个DOM节点。 可以传入HTML片段; 可以传入原始的DOM对象； 可以传入函数，但是要求返回一个字符串、DOM对象或者jQuery对象； 12345678910111213141516171819202122232425&lt;div id="test-div"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var ul = $('#test-div&gt;ul'); ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); // 创建DOM对象: var ps = document.createElement('li'); ps.innerHTML = '&lt;span&gt;Pascal&lt;/span&gt;'; // 添加DOM对象: ul.append(ps); // 添加jQuery对象: ul.append($('#scheme')); // 添加函数对象: ul.append(function (index, html) &#123; return '&lt;li&gt;&lt;span&gt;Language - ' + index + '&lt;/span&gt;&lt;/li&gt;'; &#125;);&lt;/script&gt; prepend方法prepend()则把DOM添加到最前，用法与append类似 添加到指定位置同级节点可以用after()或者before()方法，添加节点到指定节点元素之后或之前； 12var js = $('#test-div&gt;ul&gt;li:first-child');js.after('&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'); 删除节点要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点： 12var li = $('#test-div&gt;ul&gt;li');li.remove(); // 所有&lt;li&gt;全被删除 遍历DOMeacheach() 方法规定为每个匹配元素规定运行的函数。 1提示：返回 false 可用于及早停止循环。 语法1$(selector).each(function(index,element)) 参数：function(index,element) (必需。为每个匹配元素规定运行的函数。) index - 选择器的 index 位置 element - 当前的元素（也可使用 “this” 选择器） 事件绑定事件 绑定事件需要在dom加载完成后进行绑定，所以需要在ready事件中进行事件绑定； 详见：其他事件-&gt;ready事件。 绑定事件时，绑定非匿名函数，只需要填写相应的函数名称即可，加括号则相当于直接调用了； on方法绑定jQuery对象的on方法绑定事件，需要传入事件名称和对应的处理函数。 1234567891011&lt;a id="test-link" href="#0"&gt;点我试试&lt;/a&gt;&lt;script&gt; $(function () &#123; // 获取超链接的jQuery对象: var a = $('#test-link'); // 通过on方法 a.on('click',function () &#123; alert('Hello!'); &#125;); &#125;);&lt;/script&gt; 如果是调用外部非匿名函数，需要写入函数名称；12345678910function hello() &#123; alert("world")&#125;$(function () &#123; // 获取超链接的jQuery对象: var a = $('#test-link'); // 通过on方法 a.click(hello);&#125;); 直接绑定jQuery对象可以直接绑定事件； 1234567891011&lt;a id="test-link" href="#0"&gt;点我试试&lt;/a&gt;&lt;script&gt; $(function () &#123; // 获取超链接的jQuery对象: var a = $('#test-link'); // 直接调用click()方法 a.click(function () &#123; alert('Hello!'); &#125;); &#125;);&lt;/script&gt; proxy事件函数绑定this$.proxy 方法接受一个已有的函数，并返回一个带特定上下文的新的函数。 123//【语法】$(selector).proxy(function,context)$(selector).proxy(context,fn_name) 事件分类jQuery对象能够绑定的事件分类。 鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件键盘事件仅作用在当前焦点的DOM上，通常是input和textarea。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件12345- focus：当DOM获得焦点时触发；- blur：当DOM失去焦点时触发；- change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发；- submit：当&lt;form&gt;提交时触发；- ready：当页面被载入并且DOM树完成初始化后触发，仅作用于document对象。 ready事件ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。 用法示例 简单用法； 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;script&gt; $(document).on('ready', function () &#123; $('#testForm).on('submit', function () &#123; alert('submit!'); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="testForm"&gt; ... &lt;/form&gt;&lt;/body&gt; 简化写法； 123456$(document).ready(function () &#123; // on('submit', function)也可以简化: $('#testForm).submit(function () &#123; alert('submit!'); &#125;);&#125;); 最简化写法（推荐）； 1234// document对象的ready事件处理函数$(function () &#123; // init...&#125;); 事件参数Event对象作为参数; 有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息： 12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;); 取消绑定off方法用于取消绑定； 一个已被绑定的事件可以解除绑定，通过off(‘click’, function)实现； 无参数调用off()一次性移除已绑定的所有类型的事件处理函数。 12345678910function hello() &#123; alert('hello!');&#125;a.click(hello); // 绑定事件// 10秒钟后解除绑定:setTimeout(function () &#123; a.off('click', hello);&#125;, 10000); 手动触发事件123456一个需要注意的问题是，事件的触发总是由用户操作引发的。例如：绑定文本框一个改变事件，当用户在文本框中输入时，就会触发change事件。但是，如果用JavaScript代码去改动文本框的值，将不会触发change事件。如果需要手动触发，则直接调用input.change()方法即可。 手动触发方式 调用input.trigger(‘change’); 直接调用jquery对象的无参事件方法（相当trigger()方法的简写）即可（推荐）； 浏览器安全限制在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，window.open()函数： 1234// 无法打开新窗口，将被浏览器屏蔽:$(function () &#123; window.open('/');&#125;); 内置动画概览123456789101112131415animate() 对被选元素应用“自定义”的动画clearQueue() 对被选元素移除所有排队的函数（仍未运行的）delay() 对被选元素的所有排队函数（仍未运行）设置延迟dequeue() 运行被选元素的下一个排队函数fadeIn() 逐渐改变被选元素的不透明度，从隐藏到可见fadeOut() 逐渐改变被选元素的不透明度，从可见到隐藏fadeTo() 把被选元素逐渐改变至给定的不透明度hide() 隐藏被选的元素queue() 显示被选元素的排队函数show() 显示被选的元素slideDown() 通过调整高度来滑动显示被选元素slideToggle() 对被选元素进行滑动隐藏和滑动显示的切换slideUp() 通过调整高度来滑动隐藏被选元素stop() 停止在被选元素上运行动画toggle() 对被选元素进行隐藏和显示的切换 显隐动画左上角显隐方法：show、hide和toggle,从左上角逐渐展开或收缩的; 直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。 调用toggle()方法则根据当前状态决定是show()还是hide()。 只要传递一个时间参数进去，就变成了动画. 时间以毫秒为单位，但也可以是’slow’，’fast’这些字符串; 12345var div = $('#test-show-hide');div.hide(3000); // 在3秒钟内逐渐消失var div = $('#test-show-hide');div.show('slow'); // 在0.6秒钟内逐渐显示 垂直方向显隐slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的，而slideToggle()则根据元素是否可见来决定下一步动作； 用法与show、hide类似；12var div = $('#test-slide');div.slideUp(3000); // 在3秒钟内逐渐向上消失 淡入淡出fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作,用法与show、hide类似。 12var div = $('#test-fade');div.fadeOut('slow'); // 在0.6秒内淡出 滑动滑动方法可使元素上下滑动,用法类似show动画。 slideDown()： 向下； slideUp()：向上； slideToggle()：根据当前状态向上或向下； 123$("#flip").click(function()&#123; $("#panel").slideDown();&#125;); 自定义动画animate()，它可以实现任意动画效果。需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值。 123456var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000); // 在3秒钟内CSS过渡到设定值 动画结束回调animate()还可以再传入一个函数，当动画结束时，该函数将被调用,实际上这个回调函数参数对于基本动画也是适用的。 12345678910var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 动画控制串行动画jQuery的动画效果还可以串行执行，通过链式调用依次执行， 1234$("#p1") .css("color","red") .slideUp(2000) .slideDown(2000); 延迟动画通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单： 123456789101112131415var div = $('#test-animates');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125;&lt;/script&gt; 停止动画 stop()方法用于在动画或效果完成前对它们进行停止。 stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 语法格式1$(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 示例123$("#stop").click(function()&#123; $("#panel").stop();&#125;); 结束回调应用于基本的函数和自定义动画。 语法格式1$(selector).hide(speed,callback) 示例123$("p").hide(1000,function()&#123; alert("The paragraph is now hidden");&#125;); 存在问题jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。 Ajax基本用法jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。 ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： 123456- async：是否异步执行AJAX请求，默认为true，千万不要指定为false；- method：发送的Method，缺省为&apos;GET&apos;，可指定为&apos;POST&apos;、&apos;PUT&apos;等；- contentType：发送POST请求的格式，默认值为&apos;application/x-www-form-urlencoded; charset=UTF-8&apos;，也可以指定为text/plain、application/json；- data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；- headers：发送的额外的HTTP头，必须是一个object；- dataType：接收的数据格式，可以指定为&apos;html&apos;、&apos;xml&apos;、&apos;json&apos;、&apos;text&apos;等，缺省情况下根据响应的Content-Type猜测。 例子：发送一个GET请求，并返回一个JSON格式的数据： 1234var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;);// 请求已经发送了 例子：发送一个post请求： 12345678910111213function testMethod() &#123; let url = "http://localhost:8083/test-api/getBean"; let param = &#123; tag: 'this' &#125;; $.ajax(url, &#123; dataType: 'json', method: 'POST', contentType: 'application/json', data: JSON.stringify(param) &#125;);&#125; 回调处理jQuery的ajax请求对象类似一个Promise对象，我们可以用链式写法来处理各种回调。 1234567891011121314function ajaxLog(s) &#123; var txt = $('#test-response-text'); txt.val(txt.val() + '\n' + s);&#125;$('#test-response-text').val('');var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;).done(function (data) &#123; ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));&#125;).fail(function (xhr, status) &#123; ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);&#125;).always(function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用');&#125;); 内置请求方法对常用的AJAX操作，jQuery提供了一些辅助方法。可以直接使用辅助方法替换ajax关键字； get请求1234var jqxhr = $.get('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;); 第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是： 1/path/to/resource?name=Bob%20Lee&amp;check=1 post方法post()和get()类似，但是传入的第二个参数默认被序列化为application/x-www-form-urlencoded； 12345// 实际构造的数据name=Bob%20Lee&amp;check=1作为POST的body被发送;var jqxhr = $.post('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;); getJSONgetJSON()方法来快速通过GET请求，获取一个JSON对象. 123456var jqxhr = $.getJSON('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;).done(function (data) &#123; // data已经被解析为JSON对象了&#125;); 跨域可以在ajax()中设置jsonp: ‘callback’，让jQuery实现JSONP跨域加载数据。 扩展jquery插件可以扩展jQuery来实现自定义方法、封装通用方法； 实现思路12345实现思路：给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的,新函数方法内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法，jquery支持链式调用，所以新函数方法需要返回this，以支持链式调用； 编写插件原则编写一个jQuery插件的原则： 12341. 给$.fn绑定函数，实现插件的代码逻辑；2. 插件函数最后要return this;以支持链式调用；3. 插件函数要有默认值，绑定在$.fn.&lt;pluginName&gt;.defaults上；4. 用户在调用时可传入设定值以便覆盖默认值。 实例【实现高亮样式】 第一版. 扩展jquery实现一个背景高亮，文字高亮的方法? 1&gt; 新增方法封装:12345$.fn.highlight1 = function () &#123; // this已绑定为当前jQuery对象: this.css('backgroundColor', '#fffceb').css('color', '#d85030'); return this;&#125; 2&gt; 调用 123456789&lt;!-- HTML结构 --&gt;&lt;div id="test-highlight1"&gt; &lt;p&gt;什么是&lt;span&gt;jQuery&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;jQuery&lt;/span&gt;是目前最流行的&lt;span&gt;JavaScript&lt;/span&gt;库。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; $('#test-highlight1 span').highlight1().slideDown();&lt;/script&gt; 第二版. 实现文字高亮, 用户可自定义颜色？ 1&gt; 封装方法： 123456789$.fn.highlight2 = function (options) &#123; // 要考虑到各种情况: // options为undefined // options只有部分key var bgcolor = options &amp;&amp; options.backgroundColor || '#fffceb'; var color = options &amp;&amp; options.color || '#d85030'; this.css('backgroundColor', bgcolor).css('color', color); return this;&#125; 2&gt; 调用 1234567891011&lt;!-- HTML结构 --&gt;&lt;div id="test-highlight2"&gt; &lt;p&gt;什么是&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;&lt;/p&gt; &lt;p&gt;编写&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;可以用来扩展&lt;span&gt;jQuery&lt;/span&gt;的功能。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; $('#test-highlight2 span').highlight2(&#123; backgroundColor: '#00a8e6', color: '#ffffff' &#125;);&lt;/script&gt; 第三版. 实现文字高亮，设置默认缺省值，同时可接受用户定义(终极版)？ 12345【缺省值实现方式】1. 使用一个简单的&amp;&amp;和||短路操作符，总能得到一个有效的值。2. 使用jQuery提供的辅助方法$.extend(target, obj1, obj2, ...)，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高； 12345// 把默认值和用户传入的options合并到对象&#123;&#125;中并返回:var opts = $.extend(&#123;&#125;, &#123; backgroundColor: '#00a8e6', color: '#ffffff'&#125;, options); 1&gt; 封装方法： 123456789101112$.fn.highlight = function (options) &#123; // 合并默认值和用户设定值: var opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options); this.css('backgroundColor', opts.backgroundColor).css('color', opts.color); return this;&#125;// 设定默认值:$.fn.highlight.defaults = &#123; color: '#d85030', backgroundColor: '#fff8de'&#125; 2&gt; 调用 123456789101112131415161718192021&lt;!-- HTML结构 --&gt;&lt;div id="test-highlight"&gt; &lt;p&gt;如何编写&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;&lt;/p&gt; &lt;p&gt; 编写&lt;span&gt;jQuery&lt;/span&gt; &lt;span&gt;Plugin&lt;/span&gt;， 要设置&lt;span&gt;默认值&lt;/span&gt;， 并允许用户修改&lt;span&gt;默认值&lt;/span&gt;， 或者运行时传入&lt;span&gt;其他值&lt;/span&gt;。 &lt;/p&gt;&lt;/div&gt;&lt;script&gt; $.fn.highlight.defaults.color = '#659f13'; $.fn.highlight.defaults.backgroundColor = '#f2fae3'; $('#test-highlight p:first-child span').highlight(); $('#test-highlight p:last-child span').highlight(&#123; color: '#dd1144' &#125;);&lt;/script&gt; 针对特定元素的扩展实现思路jQuery对象有些方法只能作用在特定DOM元素上，比如submit()方法只能针对form。如果我们编写的扩展只能针对某些类型的DOM元素，可以利用filter方法的过滤，each()内部的回调函数的this绑定为DOM本身，支持链式调用，来针对特定元素进行扩展； 实例 给所有指向外链的超链接加上跳转提示？ 1&gt; 定义扩展方法：123456789101112131415161718$.fn.external = function () &#123; // return返回的each()返回结果，支持链式调用: return this.filter('a').each(function () &#123; // 注意: each()内部的回调函数的this绑定为DOM本身! var a = $(this); var url = a.attr('href'); if (url &amp;&amp; (url.indexOf('http://')===0 || url.indexOf('https://')===0)) &#123; a.attr('href', '#0') .removeAttr('target') .append(' &lt;i class="uk-icon-external-link"&gt;&lt;/i&gt;') .click(function () &#123; if(confirm('你确定要前往' + url + '？')) &#123; window.open(url); &#125; &#125;); &#125; &#125;);&#125; 2&gt; 使用： 12345678910111213&lt;!-- HTML结构 --&gt;&lt;div id="test-external"&gt; &lt;p&gt;如何学习&lt;a href="http://jquery.com"&gt;jQuery&lt;/a&gt;？&lt;/p&gt; &lt;p&gt; 首先，你要学习 &lt;a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000"&gt;JavaScript&lt;/a&gt;， 并了解基本的 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML"&gt;HTML&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; $('#test-external a').external();&lt;/script&gt;]]></content>
      <categories>
        <category>大前端</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记]]></title>
    <url>%2F2016%2F01%2F16%2Fweb%2FJavaScript%2FJavaScript%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本文主要介绍使用Javascript的笔记，涵盖ES6语法（ECMAScript标准委员会会在每年的6月份正式发布一次规范的修订）。 参考资料ES的官方链接 TC39提案：https://github.com/tc39/ecma262 ES6：http://www.ecma-international.org/ecma-262/6.0/index.html ES7：http://www.ecma-international.org/ecma-262/7.0/index.html ES8：http://www.ecma-international.org/ecma-262/8.0/index.html 文档资料 MDN Web技术文档 阮一峰ES6全面介绍，涵盖最新的js语法特性； 123【阮一峰ES6全面介绍GitHub地址】&gt; 源地址：https://github.com/ruanyf/es6tutorial&gt; fork地址：https://github.com/cnlius/es6tutorial 基础语法js代码内嵌js将js代码，在head中用...包裹； 12345&lt;head&gt; &lt;script&gt; alert('Hello, world'); &lt;/script&gt;&lt;/head&gt; 外联js将js写到单独的.js文件中，在head内用引入； 123&lt;head&gt; &lt;script src="/static/js/abc.js"&gt;&lt;/script&gt;&lt;/head&gt; js调试chrome开发者调试界面： 1在chrome浏览器中打开开发者工具、或者ctrl+shift+i； 控制台 执行js代码 1在开发者界面的console选项中，可以直接写js代码，按回车键执行； 在console界面打印变量值 121&gt; 在console中，通过console.log(x)，按回车，可以直接打印变量值；2&gt; 在js代码中执行console.log(&apos;hello&apos;),来打印一些需要的值； js基本语句语句结构1每个语句以;结束，语句块用&#123;...&#125; strict模式启用strict模式的方法是在JavaScript代码的第一行写上： 1'use strict'; 注释12// 单行注释/*多行注释*/ 语法规则 JavaScript 对大小写是敏感的。 忽略多余的空格。 文本字符串中使用反斜杠（\）对代码行进行换行; 允许语句尾部逗号(ES8)函数参数列表与调用中的尾部逗号，该特性允许我们在定义或者调用函数时添加尾部逗号而不报错。 123456789101112131415let foo = function ( a, b, c,) &#123; console.log('a:', a) console.log('b:', b) console.log('c:', c)&#125;foo(1, 3, 4, )//输出结果为：a: 1b: 3c: 4 条件判断 条件判断语句：if(){}else{} 1其中else语句是可选的。如果语句块只包含一条语句，那么可以省略&#123;&#125;; 多行条件判断: if(){}else if(){}…else{} switch条件判断： 12345678910switch(n)&#123; case 1: 执行代码块 1 break; case 2: 执行代码块 2 break; default: n 与 case 1 和 case 2 不同时执行的代码&#125; 循环语句for循环 for循环最常用的地方是利用索引来遍历数组： 123456var arr = ['Apple', 'Google', 'Microsoft'];var i, x;for (i=0; i&lt;arr.length; i++) &#123; x = arr[i]; console.log(x);&#125; for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环： 1234567var x = 0;for (;;) &#123; // 将无限循环下去 if (x &gt; 100) &#123; break; // 通过if判断来退出循环 &#125; x ++;&#125; for…in遍历对象 for循环的一个变体是for(…in…)循环，它可以把一个对象的所有属性依次循环出来; for(…in…)遍历的实际上是对象的属性名称,一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 1234567891011121314151617var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;// 遍历所有属性for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125;// 过滤继承来的属性for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // 'name', 'age', 'city' &#125;&#125; 遍历数组 Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引； for…in循环对Array的循环得到的是String而不是Number。 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; while循环while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。 1234567var x = 0;var n = 99;while (n &gt; 0) &#123; x = x + n; n = n - 2;&#125;x; // 2500 do…while do { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件： do { … } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。 12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100 数据类型undefined undefined表示值未定义,即变量不含有值； undefined常用在判断函数参数是否传递； 没有toString()方法； 12let x;typeof x; //undefined null null表示“空”，不是0，也不是‘’，null表示一个空的值。 判断是否为null，请使用：myVar === null； null没有toString()方法； 数字Number类型 概述 JavaScript不区分整数和浮点数，统一用Number表示; 常见的合法的Number类型： 1234567123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity0xff00 // 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便. 常用语法常见属性 constructor 返回对创建此对象的 Number 函数的引用。 MAX_VALUE 可表示的最大的数。 MIN_VALUE 可表示的最小的数。 NaN 非数字值。 NEGATIVE_INFINITY 负无穷大，溢出时返回该值。 POSITIVE_INFINITY 正无穷大，溢出时返回该值。 prototype 使您有能力向对象添加属性和方法。 类型转换 otherType-&gt;number: 用parseInt(x)或parseFloat(x)来转换任意类型到number； number-&gt;string: number值调用toString()，需要特殊处理： 12123..toString(); // '123', 注意是两个点！(123).toString(); // '123' 常用方法 toString 把数字转换为字符串，使用指定的基数。 toLocaleString 把数字转换为字符串，使用本地数字格式顺序。 toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字。 toExponential 把对象的值转换为指数计数法。 toPrecision 把数字格式化为指定的长度。 valueOf 返回一个 Number 对象的基本数字值。 数学运算number可以直接做四则运算，规则和数学一致： 1234561 + 2; // 3(1 + 2) * 5 / 2; // 7.52 / 0; // Infinity0 / 0; // NaN10 % 3; // 1 求余运算10.5 % 3; // 1.5 求余运算 求幂运算符(ES7)ES7使用更加简洁的**作为幂运算符:13**2; //求3的2次方,等同于Math.pow(3, 2); 布尔值概述：一个布尔值只有true、false两种值。 1JavaScript把null、undefined、0、NaN和空字符串&apos;&apos;视为false，其他值一概视为true。 布尔值运算1234- &amp;&amp;运算是与运算，只有所有都为true，&amp;&amp;运算结果才是true；- ||运算是或运算，只要其中有一个为true，||运算结果就是true；- !运算是非运算，它是一个单目运算符，把true变成false，false变成true；- 比较运算符：&gt;、&gt;=、==、===（推荐使用）、!==; 注意：12341&gt; 相等运算符==和===第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。2&gt; NaN与所有其他值都不相等，包括它自己.唯一能判断NaN的方法是通过isNaN(num)函数; 字符串概念：字符串是以单引号’或双引号”括起来的任意文本。 常见字符串转义字符转义字符\可以转义字符 \n 表示换行 \t 表示制表符 \x## 表示ASCII字符的十六进制形式 1'\x41'; // 完全等同于 'A' \u####表示一个Unicode字符 1'\u4e2d\u6587'; // 完全等同于 '中文' 多行字符串1最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` ... ` 表示： 例如：123`这是一个多行字符串`; 字符串模板ES6新增了一种模板字符串，在字符串中使用变量名，会自动替换成字符串中的变量所代表的的值； 例如： 123var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`; 常用操作访问字符串123456789var s = 'Hello, world!';// 字符串长度(双字节的汉字会占两位，可以通过for(..of..)方式计算)s.length; // 13// 根据索引访问字符串s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 大小写转换 toUpperCase：返回一个新字符串,等于原来字符串全部变为大写； 123var s = 'Hello';var upper = s.toUpperCase(); upper; // 返回'HELLO' toLowerCase：返回一个新字符串,等于原来字符串全部变为小写； 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' 索引indexOf()会搜索指定字符串出现的位置： 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 真实长度如果字符串中包含汉字，有些汉字长度是2，此时获取字符串长度用for..of: 1234let len=0;for(let v of c)&#123; len++;&#125; 截取substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 拷贝repeat() 参数是大于等于-1的负数或者Infinity，会报错。 repeat方法返回一个新字符串，表示将原字符串重复n次。 1234567'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // ""'na'.repeat(-0.9) // ""'na'.repeat(NaN) // ""'na'.repeat('na') // ""'na'.repeat('3') // "nanana" 字符串补全长度(ES8) padStart()用于头部补全，padEnd()用于尾部补全； 方法概述：padStart和padEnd一共接受两个参数： 第一个参数用来指定字符串的最小长度； 第二个参数是用来补全的字符串，如果省略，默认使用空格补全长度； 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' padStart用途： padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" raw转义和拼接模板斜杠转义-多字符串拼接 【转义】 对模板字符串中的斜杠进行再次转义； 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 "Hi\\n5!"String.raw`Hi\u000A!`;// 返回 "Hi\\u000A!" 【拼接】 作为正常的函数使用:String.raw({raw: ‘’},1,2)。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 特点 字符串是不可变的，如果对字符串的某个索引赋值，不会改变字符串；例如： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' 常用属性 constructor：对创建该对象的函数的引用； length：字符串的长度 prototype：允许您向对象添加属性和方法 常用方法1234567891011121314151617181920212223242526272829303132333435方法 描述anchor() 创建 HTML 锚。big() 用大号字体显示字符串。blink() 显示闪动字符串。bold() 使用粗体显示字符串。charAt() 返回在指定位置的字符。charCodeAt() 返回在指定的位置的字符的 Unicode 编码。concat() 连接字符串。fixed() 以打字机文本显示字符串。fontcolor() 使用指定的颜色来显示字符串。fontsize() 使用指定的尺寸来显示字符串。fromCharCode() 从字符编码创建一个字符串。indexOf() 检索字符串。italics() 使用斜体显示字符串。lastIndexOf() 从后向前搜索字符串。link() 将字符串显示为链接。localeCompare() 用本地特定的顺序来比较两个字符串。match() 找到一个或多个正则表达式的匹配。replace() 替换与正则表达式匹配的子串。search() 检索与正则表达式相匹配的值。slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。small() 使用小字号来显示字符串。split() 把字符串分割为字符串数组。strike() 使用删除线来显示字符串。sub() 把字符串显示为下标。substr() 从起始索引号提取字符串中指定数目的字符。substring() 提取字符串中两个指定的索引号之间的字符。sup() 把字符串显示为上标。toLocaleLowerCase() 把字符串转换为小写。toLocaleUpperCase() 把字符串转换为大写。toLowerCase() 把字符串转换为小写。toUpperCase() 把字符串转换为大写。toSource() 代表对象的源代码。toString() 返回字符串。valueOf() 返回某个字符串对象的原始值。 数组Array提供了一种顺序存储一组元素的功能，并可以按索引来读写。 概述 JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 数组是一组按顺序排列的集合，集合的每个值称为元素。 JavaScript的数组可以包括任意数据类型。 多维数组：如果数组的某个元素又是一个Array，则可以形成多维数组; 创建数组123456// 通过[]创建(推荐)[1, 2, 3.14, 'Hello', null, true];// 通过Array创建new Array(1, 2, 3); // 创建了数组[1, 2, 3]// 多维数组var arr = [[1, 2, 3], [400, 500, 600], '-']; 操作数组索引 通过索引来访问数组元素； 如果通过索引赋值时，索引超过了范围，会引起Array大小的变化； Array也可以通过indexOf()来搜索一个指定的元素的位置； 判断Array要使用Array.isArray(arr)； 12345678910111213// 通过索引来访问var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined// 索引赋值改变数组大小var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x']// 获取元素所在数组的索引arr.indexOf('hello'); 长度 直接通过arr.length获取数组的长度； 直接给Array的length赋一个新的值会导致Array大小的变化； 12345678var arr = [1, 2, 3];// 获取数组的长度arr.length; // 3// 改变数组arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 截取通过slice()截取Array的部分元素，然后返回一个新的Array； 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']arr.slice(); // 不给slice()传递任何参数，它就会从头到尾截取所有元素,相当于copy。 增删元素 push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉; 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉； splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素； 注意： 空数组继续pop或shift不会报错，而是返回undefined； 12345678910111213141516171819202122232425262728293031323334353637//【操作尾部】var arr = [1, 2];// 尾部增加元素arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']// 尾部删除元素arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // []//【操作头部】var arr = [1, 2];// 头部增加元素arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]// 头部删除元素arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // []// 【splice先按索引删除后再增加具体元素】var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 排序 sort()排序，直接调用时，按照默认升序排序; Array的sort()方法默认把所有元素先转换为String再排序; 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] 反转reverse()把整个Array的元素给掉个个，也就是反转； 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] 连接字符串 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array； 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里； 1234567var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C']var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] 连接子元素join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回新的连接后的字符串； 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 常用属性 constructor 返回对创建此对象的数组函数的引用。 length 设置或返回数组中元素的数目。 prototype 使您有能力向对象添加属性和方法。 常用方法concat()连接两个或更多的数组，并返回结果。 join()把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop()删除并返回数组的最后一个元素 push()向数组的末尾添加一个或更多元素，并返回新的长度。 reverse()颠倒数组中元素的顺序。 shift()删除并返回数组的第一个元素 slice()从某个已有的数组返回选定的元素 sort()对数组的元素进行排序 splice()删除元素，并向数组添加新元素。 toSource()返回该对象的源代码。 toString()把数组转换为字符串，并返回结果。 toLocaleString()把数组转换为本地数组，并返回结果。 unshift()向数组的开头添加一个或更多元素，并返回新的长度。 valueOf()返回数组对象的原始值 索引indexOf(element):返回的是某个元素在数组中的下标值,如果值大于-1，说明元素在数组里。 12【注意】&gt; indexOf(NaN)=-1,即使NaN存在于数组中; 包含(ES7)ES7新增原型方法：查找一个值在不在数组里，若在，则返回true，反之返回false。1Array.prototype.includes(); 特点： 12&gt; 在判断 +0 与 -0 时，被认为是相同的。&gt; includes()只能判断简单类型的数据，对于复杂类型的数据，比如对象类型的数组，二维数组，这些，是无法判断的。 语法: 1234Array.prototype.includes(searchElement,fromIndex):【参数说明】&gt; searchElement: 要搜索的值;&gt; fromIndex: 搜索的开始索引,默认索引值为0; 示例： 12345let array = ['a', 'b', 'c',+0];console.log(array.includes('b')); //trueconsole.log(array.includes('d')); //falseconsole.log(array.includes('c',2)); //falseconsole.log(array.includes(-0)); //true 对比indexOf()： 使用场景：由于它对NaN的处理方式与indexOf不同，假如你只想知道某个值是否在数组中而并不关心它的索引位置，建议使用includes()。如果你想获取一个值在数组中的位置，那么你只能使用indexOf方法。 对象JavaScript的对象是一组由键-值组成的无序集合. 概念与访问 JavaScript的对象是一组由键-值组成的无序集合. JavaScript用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加”,”。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。 获取对象的属性，用对象变量.属性名的方式; 如果属性名(键)包含特殊字符，就必须用’’括起来，并且，访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问; es6中： 1231. 变量名可以直接作为对象成员；2. 对象中的方法可以简写成函数的定义；3. 表达式可以作为属性名和方法名； 示例： es5写法： 123456789101112131415// 创建对象var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null, 'middle-school': 'No.1 Middle School'&#125;;// 获取对象属性person.name; // 'Bob'person.zipcode; // nullperson['name'];person['middle-school']; // No.1 Middle School es6写法： 12345678910let name='lily'var person = &#123; name, //外部变量 getName()&#123; //方法简写 return this.name; &#125;, ['get'+'Age']()&#123; //表达式 return this.age; &#125;&#125;; 对象的方法增删属性由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： 1234567891011121314var xiaoming = &#123; name: '小明'&#125;;// 增加属性xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18// 删除属性delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 包含 如果我们要检测对象是否拥有某一属性，可以用in操作符，此属性可能是继承来的； 判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法; 12345678910111213141516var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false// 继承（object）来的属性'toString' in xiaoming; // true// 判断是否是自身的属性xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false MapES6引入Map是一组键值对的结构，具有极快的查找速度。 使用方法初始化Map需要一个二维数组，或者直接初始化一个空Map。 12var m = new Map(); // 空Mapvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); 常用操作 一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖： 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 遍历 for…of forEach 解构赋值 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 简介 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set； 重复元素在Set中自动被过滤； 123456// 创建var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3// 自动去重var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, "3"&#125; 常用操作12345678910111213// 增加s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125;// 删除var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125;s.has(3); // false iterable概述 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。 为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for…of循环来遍历。 for…of循环是ES6引入的新的语法,只循环集合内的元素本身值； 遍历元素for…of12345678910111213141516171819var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125;// 仅遍历集合自身元素值var a = ['A', 'B', 'C'];a.name = 'Hello'; // a的对象属性for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; forEach更好的遍历集合的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数； forEach接收的函数不能break； 遍历Array: 1234567var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;); 遍历Set: 1Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); 遍历Map: 1Map的回调函数参数依次为value、key和map本身 1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 可以忽略无用参数 1如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： 1234var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; console.log(element);&#125;); 变量var变量变量的定义： 变量在JavaScript中就是用一个变量名表示； 申明一个变量用var语句。 变量名是大小写英文、数字、$和_的组合，且不能用数字开头。 变量名也不能是JavaScript的关键字，如if、while等。 变量不仅可以是数字，还可以是任意数据类型。 例如：12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 全局变量不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性： 123var course = 'Learn JavaScript';alert(course); // 'Learn JavaScript'alert(window.course); // 'Learn JavaScript' 变量注意事项 如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量； 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内，同名变量在不同的函数体内互不冲突。 在strict模式下运行的JavaScript代码，强制通过var申明变量； var存在变量提升问题：在函数中，JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，在使用到该变量，但是该变量没有定义时，返回的是undefined，不报错； 判断某个全局变量是否存在用typeof window.myVar === ‘undefined’； 函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。 1'use strict'; ES6变量letES6 推荐使用let命令来声明变量; let声明的变量，在let命令所在的块级作用域内有效,var在整个函数全局有效； let声明的变量，在同一块级作用域中，不可以在声明之前使用。 let声明的变量，在同一块级作用域中不能重复声明； let和var区别示例：1234567891011121314151617// a[i]中的i是函数全局的，所有数组a的成员里面的i，指向的都是同一个i；var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10// let 声明的变量仅在块级作用域内有效let b = [];for (let i = 0; i &lt; 10; i++) &#123; b[i] = function () &#123; console.log(i); &#125;;&#125;b[6](); // 10 常量由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： 1var PI = 3.14; constES6 新增了const命令，用来声明不变的常量； const声明一个只读的常量,一旦声明，就必须立即初始化，不能留到以后赋值。常量的值不能改变。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升到全局，同样存在暂时性死区，只能在声明的块级作用域内使用。 const声明的常量，也与let一样不可重复声明。 const声明的变量值不变，对于简单的数据类型(数值、字符串、布尔值)，变量指向的内存地址不变；对于复合类型的数据（数组和对象），变量指向的内存地址保存的指针不变，指针指向的是数据结构，数据结构的变化不受约束。 注意： const数组对象的数据结构可以改动； 123const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123; 解构赋值概念 解构赋值，可以同时对一组变量进行赋值。 左边模式=右边模式，以模式匹配的写法，即等号两边的模式相同，左边模式的变量会被赋值为右边模式对应的值。 解构要点：123456- 解构不成功，变量的值就等于undefined。- 如果等号左边的变量数量多于右边模式数组元素的数量，左边对应不到值的变量结构不成功值就是undefined。- 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。- 解构赋值允许指定默认值，只有数组成员严格等于undefined，默认值才会生效（注意：null不严格等于undefined）。- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 不完全解构即等号左边的模式只匹配一部分的等号右边的数组，可以结构成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2// -----------------------------let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 解构目标类型数组 简单数组 1let [a, b, c] = [1, 2, 3]; // 结果：a=1 b=2 c=3 间隔性赋值（忽略前两个元素，只对第三个元素赋值） 1let [ , , third] = ["foo", "bar", "baz"]; // 结果：third="baz" 嵌套数组 1234567891011let [foo, [[bar], baz]] = [1, [[2], 3]]; // 结果：foo=1 bar=2 baz=3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 数组解构赋值设置默认值 12345678910let [foo = true] = []; // foo=truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'let [x = 1] = [null]; // x=null// 表达式作为数组解构赋值默认值function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 数组按索引解构赋值给对象 12345let arr = [1, 2, 3];// 方括号这种写法，属于“属性名表达式let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" Set12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 对象 被解构的对象的属性可以没有次序，变量必须与属性同名，才能取到正确的值。 简单对象 1234let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"baz // undefined 对象属性别名赋值 12// 对象解构赋值的实质是下面这种形式的简写(&#123;属性名：属性别名&#125;=&#123;...&#125;)let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 别名解构赋值1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 嵌套结构的对象 123456789101112131415161718192021222324252627282930// 简单嵌套let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;// p是模式，不是变量let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"// 复杂嵌套对象的解构赋值const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125;/*上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。*/ 属性与变量冲突 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误,这是因为JavaScript引擎把{开头的语句当作了块处理，于是赋值不再合法。 解决方法是用小括号括起来： 12var x, y;(&#123;x, y&#125; = &#123; name: '小明', x: 100, y: 200&#125;); 指定默认值 同数组解构赋值指定默认值约束类似； 1234567891011var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 长度 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值数值和布尔值的解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 123456// 数值和布尔值的包装对象都有toString属性，因此变量s值等于对应类型的toString；let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 函数 对函数的参数解构赋值 1234567function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3// -------------------[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 参数默认值 12345678910111213141516171819// 为函数move的参数变量指定默认值function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]// ---------------------------------// 为函数move的参数指定默认值，而不是为变量x和y指定默认值function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] Iterator具有 Iterator 接口的数据类型都可以被结构赋值； Generator函数Generator函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 用途交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据解构赋值对提取 JSON 对象中的数据，尤其有用。 123456789let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 12345678const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 12345678// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 取出模板库成员加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 函数函数语法普通函数概述 function指出这是一个函数定义； abs是函数的名称； (x)括号内列出函数的参数，多个参数以,分隔； { … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 return时，函数就执行完毕，并将结果返回； 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。 abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 1234567891011121314function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;// 调用函数abs(10); // 返回10// 调用函数，多传参数不会报错；abs(10, 'blablabla'); // 返回10// 调用函数少传参数，返回NaNabs(); // abs(x)函数的参数x将收到undefined，计算结果为NaN。 匿名函数123456789101112// 在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。// 但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; // 函数体末尾加一个;// 调用abs(-19); // 19 自执行函数我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。 自执行函数，即定义和调用合为一体。 写法123456789101112(function () &#123; /* code */ &#125; ()); // 推荐使用这个(function () &#123; /* code */ &#125;)(); // 但是这个也是可以用的//如果你不在意返回值，或者不怕难以阅读,甚至可以在function前面加一元操作符号。!function () &#123; /* code */ &#125; ();~function () &#123; /* code */ &#125; ();-function () &#123; /* code */ &#125; ();+function () &#123; /* code */ &#125; ();//可以使用new关键字,但不确定它的效率new function () &#123; /* code */ &#125;new function () &#123; /* code */ &#125; () // 如果需要传递参数，只需要加上括弧() 示例123456789101112131415161718192021222324252627282930313233343536373839function(x)&#123; alert(x);&#125;(5);//报错，function name expected var aa = function(x)&#123; alert(x);&#125;(1);//1 true &amp;&amp; function(x)&#123; alert(x);&#125;(2);//2 0, function(x)&#123; alert(x);&#125;(3);//3 !function(x)&#123; alert(x);&#125;(4);//4 ~function(x)&#123; alert(x);&#125;(5);//5 -function(x)&#123; alert(x);&#125;(6);//6 +function(x)&#123; alert(x);&#125;(7);//7 new function ()&#123; alert(8);//8&#125; new function (x)&#123; alert(x);&#125;(9);//9 函数参数检查避免参数undefined，可以对参数进行检查： 12345678910function abs(x) &#123; if (typeof x !== 'number') &#123; throw 'Not a number'; &#125; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 全参关键字 JavaScript函数默认隐藏的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。 arguments类似Array但它不是一个Array； 12345678// 遍历参数function foo(x) &#123; console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30); 利用arguments，你可以获得调用者传入的参数个数和所有参数，包括传入的不需要的参数。 1234567891011function abs() &#123; if (arguments.length === 0) &#123; return 0; &#125; var x = arguments[0]; return x &gt;= 0 ? x : -x;&#125;abs(); // 0abs(10); // 10abs(-9); // 9 arguments[i]类似Array通过索引获取具体参数值； 多余参数ES6标准引入了rest参数(…rest),将多余的参数放到Array里； 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 函数返回多个值return多行12345function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125; 作用域全局作用域 JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误; 以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象; 123456function foo() &#123; alert('foo');&#125;foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用 名字空间不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中,即把自己的代码全部放入唯一的名字空间xxx中(许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等)。 示例：1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 局部作用域let替代var即可 方法概念 给对象的某个属性绑定函数，称为这个对象的方法； 对象属性绑定外部函数，无参数时，直接用函数名赋值； 12345678910var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 this关键字对象内部方法使用 在方法内部，this是一个特殊变量，它始终指向当前对象; this没有确切的对象时，指向最上层的window； 方法的内部函数中的this,默认指向window,可以在方法顶层用var that = this;来指向当前对象； 对象.方法()：对象调用方法时，this指向此对象； 12345678910111213var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 对象外部函数使用 在对象外部的函数使用this时，如果函数不依赖于对象，此时this指向window; 函数本身的apply方法绑定对象到函数：它接收两个参数: 第一个参数就是需要绑定的this变量，第二个参数是Array。即apply()把参数打包成Array再传入函数中； 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 函数本身的call()方法绑定对象到函数：它接收n个参数: 第一个参数就是需要绑定的this变量，之后的参数按顺序传入函数。 123// 对普通函数调用，我们通常把this绑定为null。Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 高阶函数定义一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 简单的高阶函数123function add(x, y, f) &#123; return f(x) + f(y);&#125; mapmap()方法定义在JavaScript的Array中，调用Array的map()方法，自己的函数，得到了一个新的Array作为结果; 12345678910// 把Array的所有数字平方：function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]// 把Array的所有数字转为字符串：var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduceArray的reduce()把一个函数作用在这个Array的[x1, x2, x3…]元素成员上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算； reduce效果公式1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 语法reduce有两个重载方法，第一个参数都是接受一个函数(数组成员操作逻辑)，第二个参数是一个初始值；12reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T): T;reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue: T): T; 示例1234567891011// 对一个Array求和var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25// 把[1, 3, 5, 7, 9]变换成整数13579var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 filter“筛选”函数。 概念 用于把Array的某些元素过滤掉，然后返回剩下的元素; 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 示例 Array中，删掉偶数，只保留奇数: 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] Array中的空字符串删掉 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // ['A', 'B', 'C'] 巧妙地去除Array的重复元素 12345// 去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了var arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];var r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); sort Array的sort()方法默认把所有元素先转换为String再排序,默认升序； 默认情况下，对字符串排序，是按照ASCII的大小比较的； sort()方法也作为高阶函数，可以接收一个比较函数来实现自定义的排序。 对于两个元素x和y的比较，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1； 注意：1sort()方法会直接对Array进行修改，它返回的结果仍是当前Array； 1234567891011121314151617181920212223242526272829303132333435363738// 升序排序var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20]// 倒序排序var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [20, 10, 2, 1]// 忽略大小写排序var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft'] 闭包概念 闭包指：一个函数返回了一个函数后，其内部的局部变量还被新函数引用，返回的函数f并没有立刻执行，而是直到调用了f()才执行; 闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 示例：创建一个闭包函数； 12345678910function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125;var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()f(); // 15 闭包每次每次调用都会返回一个新的函数，即使参数相同，结果函数也不等； 123var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // false 返回函数不要引用任何循环变量，或者后续会发生变化的变量。 示例：创建一个匿名函数并立刻执行:123(function (x) &#123; return x * x;&#125;)(3); 实例 利用闭包求次方数； 123456789101112function make_pow(n) &#123; return function (x) &#123; return Math.pow(x, n); &#125;&#125;// 创建两个新函数:var pow2 = make_pow(2);var pow3 = make_pow(3);console.log(pow2(5)); // 25console.log(pow3(7)); // 343 箭头函数概述ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 特点 箭头函数相当于匿名函数，并且简化了函数定义。 this指向：箭头函数没有独立作用域，所以箭头函数中的this指向的是当前箭头函数父对象的作用域； 箭头函数不能用作构造函数； 箭头函数没有prototype属性； 箭头函数的语法格式： 1231&gt; 只包含一个表达式，&#123;...&#125;和return都省略掉了。2&gt; 包含多条语句，不能省略&#123; ... &#125;和return;3&gt; 参数只有一个可以省略括号()，参数大于一个时不能省略括号； 示例123456789101112131415161718192021222324252627282930313233343536// 单语句箭头函数x =&gt; x * x// 相当于function (x) &#123; return x * x;&#125;// 两个参数(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 多语句箭头函数x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125;// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125;// 返回一个对象(注意：对象和函数体的&#123;...&#125;有语法冲突，需要用()括起来)x =&gt; (&#123; foo: x &#125;) this 箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj; 箭头函数完全替代了var that = this; 获取外部调用obj的形式； 123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略； 123456789var obj = &#123; birth: 1990, getAge: function (year) &#123; var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call(&#123;birth:2000&#125;, year); &#125;&#125;;obj.getAge(2015); // 25 内置对象在JavaScript的世界里，一切都是对象。 Object常用方法 获取属性名 作用：keys方法返回对象的所有属性名，返回一个数组； 语法： 1Object.keys(obj); //obj是目标对象； 获取属性值[Object.values()] 返回自己的键值对中属性的值,返回的数组顺序，也跟Object.entries()保持一致。 12Object.values(&#123; one: 1, two: 2 &#125;) //[1, 2]Object.values(&#123; 3: 'a', 4: 'b', 1: 'c' &#125;) //['c', 'a', 'b'] 对象转二维数组[Object.entries()] 该方法会将某个对象的可枚举属性与值按照二维数组的方式返回。若目标对象是数组时，则会将数组的下标作为键值返回。 12Object.entries(&#123; one: 1, two: 2 &#125;) //[['one', 1], ['two', 2]]Object.entries([1, 2]) //[['0', 1], ['1', 2]] 注意：键值对中，如果键的值是Symbol，编译时将会被忽略。 Object.entries()返回的数组的顺序与for-in循环保持一致，即如果对象的key值是数字，则返回值会对key值进行排序，返回的是排序后的结果。例如: 1Object.entries(&#123; 3: 'a', 4: 'b', 1: 'c' &#125;) //[['1', 'c'], ['3', 'a'], ['4', 'b']] 使用场景 对象属性的遍历： 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k,v] of Object.entries(obj)) &#123; console.log(`$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`);&#125;//输出结果如下：'one': 1'two': 2 浅拷贝 作用：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法： 1234Object.assign(target, ...sources)【参数】- target：目标对象（如果参数不是对象，则会先转成对象，然后返回）。- sources：源对象。 要点： 12341. 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。2. 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。3. Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。4. Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 示例： 12345var target = &#123; a: 1 &#125;; var source1 = &#123; b: 2 &#125;; var source2 = &#123; c: 3 &#125;; Object.assign(target, source1, source2); target // &#123;a:1, b:2, c:3&#125; 属性和属性描述[Object.getOwnPropertyDescriptors()] 该方法会返回目标对象中所有属性的属性描述符，该属性必须是对象自己定义的，不能是从原型链继承来的。 语法1234Object.getOwnPropertyDescriptors(obj,&apos;propName&apos;)【参数】&gt; obj: 对象本身；&gt; propName: 用引号包裹，obj的属性key; 使用实例 单个参数： 123456789101112131415161718192021222324252627282930313233343536373839let obj = &#123; id: 1, name: 'test', get gender() &#123; console.log('gender') &#125;, set grade(g) &#123; console.log(g) &#125;&#125;Object.getOwnPropertyDescriptors(obj)//输出结果为：&#123; gender: &#123; configurable: true, enumerable: true, get: f gender(), set: undefined &#125;, grade: &#123; configurable: true, enumerable: true, get: undefined, set: f grade(g) &#125;, id: &#123; configurable: true, enumerable: true, value: 1, writable: true &#125;, name: &#123; configurable: true, enumerable: true, value: 'test', writable: true &#125;&#125; 两个参数 123456789101112131415161718192021let obj = &#123; id: 1, name: 'test', get gender() &#123; console.log('gender') &#125;, set grade(g) &#123; console.log(g) &#125;&#125;Object.getOwnPropertyDescriptors(obj, 'id')//输出结果为：&#123; id: &#123; configurable: true, enumerable: true, value: 1, writable: true &#125;&#125; 使用场景-拷贝Object.getOwnPropertyDescriptors()主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 123456789101112131415let obj = &#123; id: 1, name: 'test', get gender() &#123; console.log('gender') &#125;&#125;Object.assign(obj)//输出结果为：&#123; gender: undefined id: 1, name: 'test'&#125; Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。 1234567891011121314151617181920212223242526272829303132let obj = &#123; id: 1, name: 'test', get gender() &#123; console.log('gender') &#125;&#125;let obj1 = &#123;&#125;Object.defineProperties(obj1, Object.getOwnPropertyDescriptors(obj))Object.getOwnPropertyDescriptors(obj1)//输出结果为：&#123; gender: &#123; configurable: true, enumerable: true, get: f gender(), set: undefined &#125;, id: &#123; configurable: true, enumerable: true, value: 1, writable: true &#125;, name: &#123; configurable: true, enumerable: true, value: 'test', writable: true &#125;&#125; 冻结对象 freeze 用来冻结对象属性，此模式下对象添加/更改属性会报错或不起作用； 1let foo=Object.freeze(&#123;&#125;); 彻底冻结：遍历对象成员，冻结对象本身和对象的属性： 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 对象类型基础对象类型 用typeof操作符获取对象的类型，它总是返回一个字符串; 用typeof将无法区分出null、Array和通常意义上的object{}。 123456789typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof &#123;&#125;; // 'object' 简单类型转换toString() ECMAScript 定义所有对象都有 toString() 方法，无论它是伪对象，还是真对象。因为 String 类型属于伪对象. null和 undefined不可以； 12345arrayObject.toString()booleanObject.toString()dateObject.toString()NumberObject.toString()stringObject.toString() Boolean 类型的 toString() 方法只是输出 “true” 或 “false”; Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。 12345678910// 1. 默认模式，toString()方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）的十进制;var iNum1 = 10;var iNum2 = 10.0;alert(iNum1.toString()); //输出 "10"alert(iNum2.toString()); //输出 "10"// 2. 按参数类型转换，参数是数值表示几进制；var iNum = 10;alert(iNum.toString(2)); //输出 "1010"alert(iNum.toString(8)); //输出 "12"alert(iNum.toString(16)); //输出 "A" 转换成数字parseInt() 和 parseFloat() 1234567// 基本转换var iNum1 = parseInt("56.9"); //返回 56var fNum3 = parseFloat("11.2"); //返回 11.2// 按配置的进制转var iNum2 = parseInt("10", 8); //返回 8var fNum1 = parseFloat("red"); //返回 NaN 强制类型转换ECMAScript 中可用的 3 种强制类型转换如下： Boolean(value) - 把给定的值转换成 Boolean 型； 123456var b1 = Boolean(""); //false - 空字符串var b2 = Boolean("hello"); //true - 非空字符串var b1 = Boolean(50); //true - 非零数字var b1 = Boolean(null); //false - nullvar b1 = Boolean(0); //false - 零var b1 = Boolean(new object()); //true - 对象 Number(value) - 把给定的值转换成数字（可以是整数或浮点数）； 12345678910用法 结果Number(false) 0Number(true) 1Number(undefined) NaNNumber(null) 0Number(&quot;1.2&quot;) 1.2Number(&quot;12&quot;) 12Number(&quot;1.2.3&quot;) NaNNumber(new object()) NaNNumber(50) 50 String(value) - 把给定的值转换成字符串； 最后一种强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。123var s1 = String(null); //"null"var oNull = null;var s2 = oNull.toString(); //会引发错误 包装对象概念 形如string对应String,用new关键字来创建string的包装对象； 一般不推荐使用包装对象; 常见的包装对象123var n = new Number(123); // 123,生成了新的包装类型var b = new Boolean(true); // true,生成了新的包装类型var s = new String('str'); // 'str',生成了新的包装类型 要点 包装对象后，数据类型已经变为object； 包装对象和原始值用===比较会返回false； 12345678typeof new Number(123); // 'object'new Number(123) === 123; // falsetypeof new Boolean(true); // 'object'new Boolean(true) === true; // falsetypeof new String('str'); // 'object'new String('str') === 'str'; // false Math对象Math 对象用于执行数学任务。 Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。 Math对象属性 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math对象方法 pow(a,b): 返回a的b次方； abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。 日期和时间Date: 在JavaScript中，Date对象用来表示日期和时间。 Date对象 JavaScript的月份范围用整数表示是0~11月; 创建Date对象 创建默认Date对象： 12// 注释：Date 对象会自动把当前日期和时间保存为其初始值。var myDate=new Date() 根据指定的时间创建： 12var d = new Date(2015, 5, 19, 20, 15, 30, 123);d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 解析ISO 8601格式的时间为时间戳： 使用Date.parse()时传入的字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0 ~ 11。 12var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; // 1435146562875 根据指定时间戳创建： 123var d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)d.getMonth(); // 5 时区Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： 123var d = new Date(1435146562875);d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时 当前时间注意：当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。 123456789101112var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳Date.now; // 时间戳,老版本IE没有now()方法 Date对象属性 constructor 返回对创建此对象的 Date 函数的引用。 prototype 使您有能力向对象添加属性和方法。 Date对象方法 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 正则表达式创建正则表达式JavaScript有两种方式创建一个正则表达式： 第一种方式是直接通过/正则表达式/写出来; 第二种方式是通过new RegExp(‘正则表达式’)创建一个RegExp对象; 12345var re1 = /ABC\-001/;var re2 = new RegExp('ABC\\-001');re1; // /ABC\-001/re2; // /ABC\-001/ 操作正则正则匹配test()方法：用于测试给定的字符串是否符合条件。 1234var re = /^\d&#123;3&#125;\-\d&#123;3,8&#125;$/;re.test('010-12345'); // truere.test('010-1234x'); // falsere.test('010 12345'); // false 切分字符串1234// 按空格分割字符串'a b c'.split(/\s+/); // ['a', 'b', 'c']// 按空格、都好、分号，分割字符串'a,b;; c d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd'] 分组匹配除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。 用exec()方法提取出子串来; exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 1234// ^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。 加个?就可以让正则采用非贪婪匹配（也就是尽可能少匹配）； 12var re = /^(\d+?)(0*)$/;re.exec('102300'); // ['102300', '1023', '00'] 全局搜索匹配全局匹配类似搜索，因此不能使用/^…$/，那样只会最多匹配一次。 JavaScript的正则表达式还有几个特殊的匹配标志；1231&gt; 指定i标志，表示忽略大小写;2&gt; 指定m标志，表示执行多行匹配。3&gt; 指定g标志，表示全局匹配。 表示全局匹配标志g： 123var r1 = /test/g;// 等价于:var r2 = new RegExp('test', 'g'); 全局匹配流程： 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引； 1234567891011121314151617var s = 'JavaScript, VBScript, JScript and ECMAScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // ['JScript']re.lastIndex; // 29re.exec(s); // ['ECMAScript']re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 JsonJSON字符串规定必须用双引号””，Object的键也必须用双引号””； 数据类型： number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ … }表示方式。 序列化1对象转Json字符串； Json序列化方法：JSON.stringify(aimObj,replacer,space); aimObj：被序列化对象； replacer：控制如何筛选对象的键值； space: json格式化缩进占位符； 示例 简单序列化 123456789101112var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']&#125;;// 对象转json字符串var s = JSON.stringify(xiaoming);console.log(s); 按缩进输出 1JSON.stringify(xiaoming, null, ' '); 控制如何筛选对象的键值 仅输出指定的属性，可以传入Array： 1234567891011JSON.stringify(xiaoming, ['name', 'skills'], ' ');结果如下：&#123; "name": "小明", "skills": [ "JavaScript", "Java", "Python", "Lisp" ]&#125; 传入处理函数(参数是：key,value)，这样对象的每个键值对都会被函数先处理： 123456789101112131415161718192021222324function convert(key, value) &#123; if (typeof value === 'string') &#123; return value.toUpperCase(); &#125; return value;&#125;JSON.stringify(xiaoming, convert, ' ');结果如下：&#123; "name": "小明", "age": 14, "gender": true, "height": 1.65, "grade": null, "middle-school": "\"W3C\" MIDDLE SCHOOL", "skills": [ "JAVASCRIPT", "JAVA", "PYTHON", "LISP" ]&#125; 精确控制序列化，可以给xiaoming定义一个toJSON()的方法，调用序列化方法，会直接返回toJson的结果： 1234567891011121314151617var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\"W3C\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () &#123; return &#123; // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age &#125;; &#125;&#125;;JSON.stringify(xiaoming); // '&#123;"Name":"小明","Age":14&#125;' 反序列化1把JSON格式的字符串，转化为JavaScript对象； 反序列化方法：JSON.parse(jsonString, function) jsonString: json字符串； reviver: 处理反序列化结果； 示例 简单反序列化； 1234JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]JSON.parse('&#123;"name":"小明","age":14&#125;'); // Object &#123;name: '小明', age: 14&#125;JSON.parse('true'); // trueJSON.parse('123.45'); // 123.45 反序列化前处理逻辑； 1234567var obj = JSON.parse('&#123;"name":"小明","age":14&#125;', function (key, value) &#123; if (key === 'name') &#123; return value + '同学'; &#125; return value;&#125;);console.log(JSON.stringify(obj)); // &#123;name: '小明同学', age: 14&#125; 面向对象编程对象原型链原型对象 JavaScript对每个创建的对象X都会设置一个原型，指向它的原型对象X.prototype。 prototype允许您向对象添加属性和方法; 查找对象属性的原型链概述用Obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。这个过程形成对象的原型链。 实例访问某对象属性，执行的原型链具体如下： 12Obj ----&gt; Obj.prototype ----&gt; Object.prototype ----&gt; null// obj.prototype: 对象的原型，包含该对象的所有属性； 创建对象创建方式 直接用{…}创建一个对象； 构造函数创建对象； 构造函数创建对象 创建构造函数并生成对象： 12除了直接用&#123;...&#125;创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。关键字new来调用这个函数，并返回一个对象; 1234567891011function Student(name) &#123; this.name = name; this.hello = function () &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 123456xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // trueObject.getPrototypeOf(xiaoming) === Student.prototype; // truexiaoming instanceof Student; // true prototype设置共享原型对象的属性： 1234567function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;; 创建对象注意12如果不写new，这就是一个普通函数，它返回undefined。如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 设置属性默认值1234function Student(props) &#123; this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1&#125; 对象实例类型判断1xiaoming instanceof Student; // true 封装创建构造函数对象12345678910111213141516171819function Student(props) &#123; this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;;function createStudent(props) &#123; return new Student(props || &#123;&#125;)&#125;// 使用var xiaoming = createStudent(&#123; name: '小明'&#125;);xiaoming.grade; // 1 原型继承原型继承：把一个对象的原型，指向另一个对象； 原型继承的原型链为：1new ChildObject() ----&gt; ChildObject.prototype ----&gt; ParentObject.prototype ----&gt; Object.prototype ----&gt; null 创建方式__proto__概述： 121&gt; 通过obj1.__proto__=obj2，将obj的原型指向obj2，这样obj1就拥有了obj2的属性，包括属性值；2&gt; 不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__； 示例： 123456789101112131415161718var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;var xiaoming = &#123; name: '小明'&#125;;// 让xiaoming继承Student,即把xiaoming的原型指向了对象Student；xiaoming.__proto__ = Student;// 测试xiaoming.name; // '小明'xiaoming.run(); // 小明 is running Object.create() Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象； Object.create()创建的新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming； 1234567891011121314151617181920// 原型对象:var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;function createStudent(name) &#123; // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;&#125;var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true 中间对象 借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype； 12345678910111213141516171819202122232425262728293031323334353637383940// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建xiaoming:var xiaoming = new PrimaryStudent(&#123; name: '小明', grade: 2&#125;);xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 继承简化 继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 12345678910111213141516171819202122232425262728293031// 封装可复用的继承函数function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;// 父对象function Student(props) &#123; this.name = props.name || 'Unnamed';&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;// 子对象function PrimaryStudent(props) &#123; // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1;&#125;// 实现原型继承链:inherits(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; 类关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 定义1234567891011121314// 定义类class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;// 创建对象var xiaoming = new Student('小明');xiaoming.hello(); 继承 extends则表示原型链对象来继承自Student。 子类的构造函数参数任意，但是需要通过super(params)来调用父类的构造函数，否则父类的name属性无法正常初始化。 子类继承父类，就拥有了父类的属性和方法； 12345678910class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 模块 浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。 js模块化，将每个js文件看做一个模块，可以将js文件中的成员导出，或者导入别的模块的成员； 导入导出 使用export关键字导出js模块中的成员,利用import导入js模块成员； 导入时：可用as定义别名，导入的类要放在最前面，模块成员放在{}内； 同一模块内既可以导入也可以发生导出； 示例【a.js文件】123456789101112131415161718192021222324//直接导出单个export let str = 'string';let obj = &#123; name: 'jason'&#125;;let fn = () =&gt; &#123; console.log('es6 fn')&#125;;//导出多个export &#123; obj, fn&#125;;//默认导出，导入时可以使用任意名称export default class Student &#123; constructor()&#123; this.age=12; &#125; getAge() &#123; return this.age; &#125;&#125;; 【b.js文件】 12345678import Student, &#123;str as type, obj, fn&#125; from "./module";console.log('str:'+type);console.log('obj:'+obj.name);console.log('fn:'+fn);fn();let student=new Student();console.log('Student:'+student.getAge()); 浏览器主流浏览器 IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准； Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了； Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6； Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新； 移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。 浏览器差异 不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。 对于ES6标准，不同的浏览器对各个特性支持也不一样。 浏览器对象window JavaScript可以获取浏览器提供的很多对象，并进行操作。 window对象不但充当全局作用域，而且表示浏览器窗口. 浏览器尺寸属性图示 净宽高12window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 全宽高outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 浏览器的信息navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent（用户代理）字符串。 根据浏览器获取信息navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。 错误的方式： 很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如： 123456var width;if (getIEVersion(navigator.userAgent) &lt; 9) &#123; width = document.body.clientWidth;&#125; else &#123; width = window.innerWidth;&#125; 正确的方式 确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：1var width = window.innerWidth || document.body.clientWidth; 屏幕信息window.screen 对象包含有关用户屏幕的信息。 screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 screen.availHeight: 可用高度； URL信息location URL信息location对象获取当前页面的URL信息。 一个完整的URL： 1http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 1234567location.href; // 完整地址location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' 加载URL 要加载一个新页面，可以调用location.assign(URL)。 如果要重新加载当前页面，调用location.reload()方法非常方便。 12345if (confirm('重新加载当前页' + location.href + '?')) &#123; location.reload();&#125; else &#123; location.assign('/'); // 设置一个新的URL地址&#125; historyhistory对象保存了浏览器的历史记录; history的方法 history.back()：用户点击了浏览器的“后退”按钮。 history.forwar()：用户点击了浏览器的“前进”按钮。 window相关方法openwindow.open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。 1语法： window.open(URL,name,features,replace) 1234567URL 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。name 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 &lt;a&gt; 和 &lt;form&gt; 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。features 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。replace一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 cookie概念 cookie是以分号分割的多个k-v字段组成的字符串； cookie存储是用户端保存请求信息的机制； 存储在本地的加密文件里，用户不能直接访问，需要用浏览器访问； cookie的存储有路径和域名的限制，一个请求只能操作自己有权限的cookie; document.cookie.toString获取的是所有cookies的key+value拼接字符串； cookie信息 name: cookie的名称； domain: cookie生效的域名，这个域名有作用域的限制，如：一个二级域名可以访问一级域名的cookie,但是不能操作其他二级域名的cookie,也不能操作所属的三级域名的cookie; path: cookie的生效路径，比如同一个域名下不同路径的cookie也是无法操作的； expires:cookie的过期时间，超过这个时间cookie就会被删除，如果不设置此属性，cookie只会存在于一次会话中，那么浏览器关闭时cookie就会被删除； HttpOnly: 表示cookie是由服务端设置的，不允许在用户端进行更改，这种类型的cookie，js无法进行操作。 设置cookie1234567// 设置cookiefunction setCookie(keyName, value) &#123; var days = 30; var exp = new Date(); exp.setTime(exp.getTime() + days); document.cookie = name + "=" + escape(value) + ";expires=" + exp.getDate();&#125; 获取cookis12345678910111213141516function getXCookie(key) &#123; alert(document.cookie.toString()); if (document.cookie.length &gt; 0) &#123; let key_start = document.cookie.indexOf(key + "="); if (key_start !== -1) &#123; key_start = key_start + key.length + 1; let key_end = document.cookie.indexOf(";", key_start); if (key_end === -1) &#123; key_end = document.cookie.length; &#125; alert(document.cookie.substring(key_start, key_end)) &#125; &#125; else &#123; alert("no cookie"); &#125;&#125; session session是服务端保存请求信息的机制； session是用在服务端记录请求者身份的，服务端接到http请求后，服务端生成一个sessionId,这个sessionId种到用户的cookie里，这样同一用户再发一次这个请求，服务端根据cookie就知道是哪个用户发来的。 sessionId并不一定都是用cookie实现的，也可以放在请求参数里，或者在http请求头里开辟一个token字段。 会话由浏览器控制，如果没有设置过期时间，会话结束，session就失效； 消息框可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。 警告框 警告框经常用于确保用户可以得到某些信息。 当警告框出现后，用户需要点击确定按钮才能继续进行操作。 1alert("文本"); 确认框 确认框用于使用户可以验证或者接受某些信息。 当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。 12345678confirm("文本")var result = confirm("确定要这么做吗？");if(result)&#123;//true alert('点了确定');&#125; else &#123; //false alert('点了取消');&#125; 提示框 提示框经常用于提示用户在进入页面前输入某个值。 当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。 如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。 1prompt("文本","默认值") HTTP路由路由的种类 页面路由： hash路由： H5路由： 页面路由直接在当前页面进行跳转，js代码如下：1234//当前页面跳转到指定页面：window.location.href='https://www.baidu.com/';//回退功能，回退到上一页：history.back(); hash路由通过window.location方法直接指定一个hash值，页面的地址会追加这个哈希值作为新的请求地址，通过window.onhashchange方法监听页面的hash变化，实现代码如下： 12345678//为当前页面地址追加指定hash值window.location="#test";//获取页面地址的hash值window.location.hash//监听页面hash的变化window.onhashchange=()=&gt;&#123; console.log("current hash: "+window.location.hash);&#125; H5路由 添加并定位到一个新地址： H5提供的路由，通过history.pushState推入一个状态，当前地址会追加一个hash值或者一个路径地址： 1234//推入一个hash：history.pushState("name","title","#hash1");//推入一个路径：history.pushState("name","title","/path"); 替换当前页面地址追加的部分的hash或者地址名： 12345678history.replaceState("name","title","xxxx");//监听页面通过回退和前进页面历史改变页面时,回调：window.onpopstate=()=&gt;&#123; console.log("href="+window.location.href+"\n"); console.log("pathname="+window.location.pathname+"\n"); console.log("hash="+window.location.hash+"\n"); console.log("search="+window.location.search+"\n");&#125;; DOMdocument当前页面 概述 document对象表示当前页面。 由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。 页面属性标题标题：document.title; 123// document的title属性是从HTML文档中的&lt;title&gt;xxx&lt;/title&gt;读取的，但是可以动态改变：document.title; // 读取标题document.title = '努力学习JavaScript!'; // 改变标题 cookies12js可以获取网页的cookie信息；防止外部第三方js读取cookies,服务器端设置Cookie时，应该始终坚持使用httpOnly来设置； 1document.cookie; // 获取页面设置的cookie信息； body属性12345678网页可见区域宽： document.body.clientWidth网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽)网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop网页被卷去的左： document.body.scrollLeft dom节点元素dom详细内容见操作dom document.getElementById(“x_id”)：按ID获得一个DOM节点； document.getElementsByTagName(“x_tag”)：按html标签Tag名称获得一组DOM节点； 获取节点的内容innerHTML：document.getElementById(‘x_id’).innerHTML ; 示例： 12345678&lt;dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;"&gt; &lt;dt&gt;摩卡&lt;/dt&gt; &lt;dd&gt;热摩卡咖啡&lt;/dd&gt; &lt;dt&gt;酸奶&lt;/dt&gt; &lt;dd&gt;北京老酸奶&lt;/dd&gt; &lt;dt&gt;果汁&lt;/dt&gt; &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;&lt;/dl&gt; 123456789101112131415// 根据id获取dom节点元素var menu = document.getElementById('drink-menu');// 根据标签名获取dom节点元素var drinks = document.getElementsByTagName('dt');var i, s, menu, drinks;menu = document.getElementById('drink-menu');menu.tagName; // 'DL'drinks = document.getElementsByTagName('dt');s = '提供的饮料有:';for (i=0; i&lt;drinks.length; i++) &#123; s = s + drinks[i].innerHTML + ',';&#125;console.log(s); DOM事件处理dom对象提供如下两个方法处理监听事件： addEventListener() 方法用于向指定元素添加事件句柄。 removeEventListener()方法来移除addEventListener()方法添加的事件句柄。 12345// 添加 &lt;div&gt; 事件句柄 document.getElementById("myDIV").addEventListener("mousemove", myFunction);// 移除 &lt;div&gt; 事件句柄 document.getElementById("myDIV").removeEventListener("mousemove", myFunction); event对象event时dom自带的事件对象 event.preventDefault()：该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。 event.stopPropagation()：该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。 操作DOM创建节点123456789// 1. 创建新节点；let d = document.createElement('style');// 2. 设置节点属性；d.setAttribute('type', 'text/css');d.setAttribute("id", "container");// 也可以直接属性赋值：d.id="container";// 获取目标节点，追加元素let list = document.getElementById('list');list.appendChild(d); 插入DOM如果DOM节点是空的，可以直接使用innerHTML “插入”新的DOM节点。 appendChild 把一个子节点添加到父节点的最后一个子节点,首先会从原先的位置删除，再插入到新的位置。 从零创建一个新的节点，然后插入到指定位置; 【实例1】增加节点：123456789101112131415161718192021&lt;!-- HTML结构 --&gt;&lt;p id="js"&gt;JavaScript&lt;/p&gt;&lt;div id="list"&gt; &lt;p id="java"&gt;Java&lt;/p&gt; &lt;p id="python"&gt;Python&lt;/p&gt; &lt;p id="scheme"&gt;Scheme&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 把原有节点添加到的最后一项 let js = document.getElementById('js'), let list = document.getElementById('list'); list.appendChild(js); // 创建新节点，并添加 let list = document.getElementById('list'), let haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell);&lt;/script&gt; 【实例2】向head添加css样式： 1234var d = document.createElement('style');d.setAttribute('type', 'text/css');d.innerHTML = 'p &#123; color: red &#125;';document.getElementsByTagName('head')[0].appendChild(d); insertBefore12// 把子节点插入到指定的位置referenceElement元素之前parentElement.insertBefore(newElement, referenceElement); 删除DOM1removeChild 删除Dom的步骤： 1要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉; 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 1【注意】删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 更新DOMinnerHTML 不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树; 用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 12345var p = document.getElementById('container');// 修改内容p.innerHTML="hello world";// 修改内容并添加子元素p.innerHTML="hello &lt;span style='color:red'&gt;RED&lt;/span&gt;"; write document.write() 仅仅向文档输出写内容。 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖; 1document.write("糟糕！文档消失了。"); innerText 向标签元素中添加纯文本内容，即使是html代码也会被原样输出； innerText不返回隐藏元素的文本 123var p = document.getElementById('container');p.innerText="hello &lt;span style='color:red'&gt;RED&lt;/span&gt;";// hello &lt;span style='color:red'&gt;RED&lt;/span&gt; textContent 向标签元素中添加纯文本内容，即使是html代码也会被原样输出； innerText会输出所有文本，包括隐藏的； 注意IE&lt;9不支持textContent。 12var p = document.getElementById('container');p.textContent="&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;hello&lt;/p&gt;"; 查询DOM操作方法 document.getElementById()：根据元素id获取唯一的DOM节点； 1234567// 1. 获取ID为'test'的节点：var test = document.getElementById('test');// 2. 获取节点test下的所有直属子节点:var cs = test.children;// 3. 获取节点test下第一个、最后一个子节点：var first = test.firstElementChild;var last = test.lastElementChild; document.getElementsByTagName()：根据元素名称获取一组DOM节点； document.getElementsByClassName()：根据css选择器类名获取一组DOM节点； 12345【查找某节点下的一组节点】// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：var trs = document.getElementById('test-table').getElementsByTagName('tr');// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：var reds = document.getElementById('test-div').getElementsByClassName('red'); querySelector()和querySelectorAll()（更加方便） 121&gt; querySelector() 根据选择器名称获取节点元素；2&gt; querySelectorAll() 根据选择器名称获取所有符合条件的一组节点； 12345// 通过querySelector获取ID为q1的节点：var q1 = document.querySelector('#q1');// 通过querySelectorAll获取q1节点内的符合条件的所有节点：var ps = q1.querySelectorAll('div.highlighted &gt; p'); 【注意】 低版本的IE&lt;8不支持querySelector和querySelectorAll。IE8仅有限支持。 严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node。（详见：w3cschool文档节点类型） 遍历节点123456var i, c, list = document.getElementById('list');for (i = 0; i &lt; list.children.length; i++) &#123; c = list.children[i]; // 拿到第i个子节点&#125; dom宽高1234元素的实际高度：document.getElementById(&quot;div&quot;).offsetHeight元素的实际宽度：document.getElementById(&quot;div&quot;).offsetWidth元素的实际距离左边界的距离：document.getElementById(&quot;div&quot;).offsetLeft元素的实际距离上边界的距离：document.getElementById(&quot;div&quot;).offsetTop Dom相关方法属性1234// 获取属性值domX.getAttribute(&quot;data-animal-type&quot;);// 设置属性值domX.setAttribute(&apos;type&apos;, &apos;text/css&apos;); 操作表单 用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。 表单的输入框、下拉框等可以接收用户输入，JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。 表单输入控件123456文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本；口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令；单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项；复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项；下拉框，对应的&lt;select&gt;，用于选择一项；隐藏文本(多用于密码)，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 控件值 text、password、hidden、select控件 获得了一个input节点的引用，就可以直接调用value获得对应的用户输入值； 123456// &lt;input type="text" id="email"&gt;var input = document.getElementById('email');// 获取值input.value; // 设置值input.value = 'test@example.com'; 单选框和复选框 1对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断 123456789101112// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type="radio" name="weekday" id="tuesday" value="2"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'// 获取选择的状态mon.checked; // true或者falsetue.checked; // true或者false// 设置选择的状态input.checked=true; HTML5控件 123不支持HTML5的浏览器无法识别新的控件，会把它们当做type=&quot;text&quot;来显示。支持HTML5的浏览器将获得格式化的字符串。例如，type=&quot;date&quot;类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。 HTML5控件date、datetime、datetime-local、color等，它们都使用input标签，通过value获取值； 提交表单 一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。 如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 响应onsubmit 浏览器默认点击submit时提交表单，或者用户在最后一个输入框按回车键。 return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 12345678910111213141516171819&lt;!-- HTML --&gt;&lt;form id="test-form" onsubmit="return checkForm()"&gt; &lt;input type="text" name="test"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;form id="test-form" onsubmit="checkForm()"&gt; &lt;input type="text" name="test"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;&#125;&lt;/script&gt; 点击事件提交 缺点是扰乱了浏览器对form的正常提交; 1234567891011121314&lt;!-- HTML --&gt;&lt;form id="test-form"&gt; &lt;input type="text" name="test"&gt; &lt;button type="button" onclick="doSubmitForm()"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();&#125;&lt;/script&gt; 实例 密码加密 121. 提交表单，对密码加密，利用隐藏元素提交表单。2. md5: https://github.com/blueimp/JavaScript-MD5 123456789101112131415161718&lt;!-- HTML --&gt;&lt;form id="login-form" method="post" onsubmit="return checkForm()"&gt; &lt;input type="text" id="username" name="username"&gt; &lt;input type="password" id="input-password"&gt; &lt;input type="hidden" id="md5-password" name="password"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt; function checkForm() &#123; var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true; &#125;&lt;/script&gt; 操作文件普通文件12// 上传文件的唯一控件&lt;input type="file"&gt;; 特点 input.value赋值是没有任何效果的; JavaScript也无法获得该文件的真实路径； 当表单包含file时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 文件信息 表单文件改变监听： 12345var fileInput = document.getElementById('test-file-upload');// 监听file的改变获取file的值fileInput.addEventListener('change', function () &#123; var filePath = fileInput.value;&#125;); 提交表单前校验文件： 123456var f = document.getElementById('test-file-upload');var filename = f.value; // 'C:\fakepath\test.png'if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) &#123; alert('Can only upload image file.'); return false;&#125; HTML5 File HTML5新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 File 文件名：file.name; 文件大小：file.size; 文件最终修改时间：file.lastModifiedDate; FileReaderFileReader用于异步读取文件: 1234567var reader = new FileReader();reader.onload = function(e) &#123; var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')';&#125;;// 以DataURL的形式读取文件:reader.readAsDataURL(file); 【注意】121&gt; 以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。2&gt; 如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。 实例 选择图片并回显； 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id="show_image" style="width: 100px; height: 100px;border: 1px solid black;background-size: 100%;"&gt;&lt;/div&gt;&lt;input type="file" id="avatar" name="image" onchange="changeImage()"&gt;&lt;div id="info"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; function changeImage() &#123; console.log("----------------------------"); let fileInput = document.getElementById('avatar'); let preview = document.getElementById('show_image'); let info = document.getElementById('info'); // 清除背景图片: preview.style.backgroundImage = ""; // 检查文件是否选择: if (!fileInput.value) &#123; info.innerHTML = '没有选择文件'; return; &#125; // 获取File引用: let file = fileInput.files[0]; // 文件名 console.log("文件名："+file.name); // 文件大小 console.log("文件大小："+file.size); // 文件最后修改的时间 console.log("文件最终修改时间："+file.lastModifiedDate); if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: let reader = new FileReader(); reader.onload = e=&gt;&#123; let data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' // 填充文件到div preview.style.backgroundImage = 'url(' + data + ')'; &#125;; // 以DataURL的形式读取文件: reader.readAsDataURL(file); &#125;&lt;/script&gt; Ajax Ajax(Asynchronous JavaScript and XML)意思就是用JavaScript执行异步网络请求; AJAX = 异步 JavaScript 和 XML； AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 XMLHttpRequest XMLHttpRequest用于发送请求； 所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 ajax使用 创建XMLHttpRequest请求对象： 123456var request;if (window.XMLHttpRequest) &#123; // code for IE7+, Firefox, Chrome, Opera, Safari request = new XMLHttpRequest();&#125; else &#123; // code for IE6, IE5 request = new ActiveXObject('Microsoft.XMLHTTP');&#125; 设置请求返回处理： 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息； 1234567readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 http状态码 123status 200: &quot;OK&quot;404: 未找到页面 配置实例：123456789101112131415161718192021222324function success(text) &#123; console.log("success="+text);&#125;function fail(code) &#123; console.log("error code is "+code);&#125; request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // request.responseXML; // XML格式的数据 // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... console.log("链接异常...") &#125;&#125; open方法发起请求 open()规定请求的类型、URL 以及是否异步处理请求。 123456【语法格式】request.open(method,url,async);【参数说明】- method：请求的类型；GET 或 POST- url：文件在服务器上的位置- async：true（异步）或 false（同步） 【GET请求】1234// 设置请求request.open("GET","url?param1=1&amp;params2=2",true);// 发送请求request.send(); 【POST请求】1234// 设置请求request.open("POST","url",true);// 发送请求带参数request.send(params); 设置请求头信息 12// 请求头信息设置request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 跨域a.com访问b.com就发生了跨域，跨域的解决方案见：细说ajax跨域 Promise概念 Promise主要用于在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了; 支持链式调用； 语法格式1234//写法1：new Promise((resolve,reject)=&gt;&#123;&#125;).then(result=&gt;&#123;&#125;,error=&gt;&#123;&#125;);//写法2：new Promise((resolve,reject)=&gt;&#123;&#125;).then(result=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;); 【参数说明】 Promise对象接受一个匿名函数作为参数，匿名函数有两个参数(resolve,reject),可以看成两个方法； 写法1中： 12- 调用resolve方法，会回调then方法的第一个匿名函数；- 调用reject方法会回调then方法的第二个匿名函数； 写法2中： 12- 调用resolve方法，会回调then方法中的匿名函数；- 调用reject方法会回调catch方法中的匿名函数； 异步任务单异步任务1234567891011121314151617181920function test(resolve, reject) &#123; var timeOut = Math.random() * 2; setTimeout(function () &#123; if (timeOut &lt; 1) &#123; resolve('200 OK'); &#125; else &#123; reject('timeout is' + timeOut); &#125; &#125;, timeOut * 1000);&#125;function testMethod() &#123; new Promise(test) .then(function (result) &#123; console.log('成功：' + result); &#125;) .catch(function (reason) &#123; console.log('失败：' + reason); &#125;);&#125; 串异步任务串行执行若干异步任务 问题描述：若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数？ 1234567let job1=new Promise(task1Fn());let job2=new Promise(task2n());let job3=new Promise(task3Fn());// 写法1：job1.then(()=&gt;&#123;return job2;&#125;).then(()=&gt;&#123;&#125;);// 写法2：job1.then(job2).then(job3).catch(handleError); 并行异步任务Promise.all描述：并行执行两个任务p1,p2,全部结束后打印结果？ 12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;); Promise.race描述：并行执行执行多个异步任务，任意任务执行结束，丢弃其他任务？ 123456789var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // 'P1'&#125;); 执行ajax123456789101112131415161718192021222324252627// ajax函数将返回Promise对象:function ajax(method, url, data) &#123; var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; resolve(request.responseText); &#125; else &#123; reject(request.status); &#125; &#125; &#125;; request.open(method, url); request.send(data); &#125;);&#125;// 入口function mainFn()&#123; var p = ajax('GET', '/api/categories'); p.then(function (text) &#123; // 如果AJAX成功，获得响应内容 log.innerText = text; &#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码 log.innerText = 'ERROR: ' + status; &#125;);&#125; fetchfetch用于访问和操纵HTTP请求； 对比ajax 除非网络故障，否则fetch()返回的Promise 不会被标记为reject，只有resolve状态，但是可以通过resolve的ok属性来判断请求结果是否被拒（404 or 500）； 默认情况下，fetch不会从服务端发送或接收任何 cookies, 要发送cookies，必须设置credentials选项。 fetch语法【语法格式】1Promise&lt;Response&gt; fetch(input[, init]); 【参数解释】 input：（必须参数）url或request对象； init: （可选参数）配置请求信息的对象； 1234567891011配置参数如下：- method: 请求使用的方法，如 GET、POST。- headers: 请求的头信息，形式为 Headers 的对象或包含 ByteString 值的对象字面量。- body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。- mode: 请求的模式，如 cors、 no-cors 或者 same-origin。- credentials: 请求的凭据credentials，如omit（不在请求中包含凭据）、same-origin（在请求URL与调用脚本位于同一起源处时发送凭据）或者 include（发送包含凭据的请求）。为了在当前域名内自动发送cookie， 必须提供这个选项， 从Chrome50开始，这个属性也可以接受FederatedCredential 实例或是一个PasswordCredential实例。- cache: 请求的 cache 模式: default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached 。- redirect: 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者 manual (手动处理重定向). 在Chrome中，Chrome 47之前的默认值是 follow，从 Chrome 47开始是 manual。- referrer: 一个 USVString 可以是 no-referrer、client或一个 URL。默认是 client。- referrerPolicy: Specifies the value of the referer HTTP header. May be one of no-referrer、 no-referrer-when-downgrade、 origin、 origin-when-cross-origin、 unsafe-url 。- integrity: 包括请求的 subresource integrity 值 （ 例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 Request对象12345678910111213var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg', myInit);//请求fetch(myRequest).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); Response对象Response实例是在fetch()处理完promises之后返回的. 创建ResponseResponse() 构造方法接受两个可选参数—response的数据体和一个初始化对象(与Request()所接受的init参数类似.) 1234567var myBody = new Blob();addEventListener('fetch', function(event) &#123; event.respondWith(new Response(myBody, &#123; headers: &#123; "Content-Type" : "text/plain" &#125; &#125;);&#125;); response常见属性 Response.status — 整数(默认值为200) 为response的状态码. Response.statusText — 字符串(默认值为”OK”),该值与HTTP状态码消息对应. Response.ok — 如上所示, 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个Boolean值. Headersheaders配置也创建Headers对象来设置：12345678910111213var myHeaders = new Headers(&#123; "Content-Length": content.length.toString(), "X-Custom-Header": "ProcessThisImmediately",&#125;);//添加配置myHeaders.append("Content-Type", "text/plain");//更新写入配置（有一些属性不可以写入，如Origin）myHeaders.set("Content-Type", "application/json");//获取配置console.log(myHeaders.get("Content-Length")); // 11console.log(myHeaders.getAll("X-Custom-Header")); // ["ProcessThisImmediately", "AnotherValue"]//删除配置myHeaders.delete("X-Custom-Header"); Bodybody用于指定提交请求的参数； body参数类型可以是以下任意类型的实例： ArrayBuffer ArrayBufferView (Uint8Array and friends) Blob/File string URLSearchParams(用于form-data格式提交请求参数) FormData(用于图文格式提交请求参数) Body类定义了以下方法 (这些方法都被 Request 和Response所实现)以获取body内容. 这些方法都会返回一个被解析后的promise对象和数据： arrayBuffer() blob()： Response流 json()：Body mixin的json()方法使用一个Response 流，并将其读取完成。它返回一个 promise ，解析结果是将文本体解析为JSON。 text() formData()：将Response对象中的所承载的数据流读取并封装成为一个对象。 请求示例Get请求12345678//get请求fetch("http://localhost:8080/test-api/get") .then(function (response) &#123; return response.json(); //返回一个Promise对象 &#125;) .then(function (myJson) &#123; //需要二次处理才会返回处理结果 console.log(myJson); &#125;); Get请求-带参数12345678910111213141516171819202122function testGetByParams() &#123; let url = "http://localhost:8080/test-api/get"; let params=&#123;tag:'tag'&#125;; if (params) &#123; let paramsArray = []; //拼接参数 Object.keys(params).forEach(key =&gt; paramsArray.push(key + '=' + params[key])); if (url.search(/\?/) === -1) &#123; url += '?' + paramsArray.join('&amp;') &#125; else &#123; url += '&amp;' + paramsArray.join('&amp;') &#125; &#125; fetch(url, &#123; method: 'GET' &#125;).then(function (response) &#123; return response.json(); //返回一个Promise对象 &#125;).then(function (myJson) &#123; //需要二次处理才会返回处理结果 console.log(myJson); &#125;);&#125; post请求-body形式JSON.stringify()来组织参数：12345678910111213141516171819function testPostBody() &#123; fetch("http://localhost:8080/test-api/postBody", &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123;tag: 'this'&#125;), credentials: 'same-origin', //请求可以带cookie &#125;).then(response =&gt; &#123; if (response.ok) &#123; return response.json(); &#125; throw new Error('Network response was not ok.'); &#125;).catch(error =&gt; &#123; console.error('Error:', error) &#125;).then(response =&gt; &#123; console.log('Success:', response) &#125;);&#125; post请求-FormData形式URLSearchParams来组织参数：12345678910111213141516171819202122function testPostFormData() &#123; let params = new URLSearchParams(); params.append('tag', 'tag'); fetch("http://localhost:8080/test-api/postFormData", &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;, body: params, credentials: 'same-origin', //请求可以带cookie &#125;).then(response =&gt; &#123; if (response.ok) &#123; return response.json(); &#125; throw new Error('Network response was not ok.'); &#125;).catch(error =&gt; &#123; console.error('Error:', error) &#125;).then(response =&gt; &#123; console.log('Success:', response) &#125;);&#125; post请求-form-data提交文件文字表单的形式提交文件和文字，参数是FormData对象，不用指定Content-Type：12345678910111213let formData = new FormData();let fileField = document.querySelector("input[type='file']");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'POST', body: formData&#125;).then(response =&gt; response.json()).catch(error =&gt; console.error('Error:', error)).then(response =&gt; console.log('Success:', response)); GeneratorGenerator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 概述 generator和函数不同的是，generator由function定义（注意多出的号），并且，除了return语句，还可以用yield返回多次。 调用一个generator和调用函数不一样，调用生成器g()，仅仅是创建了一个generator对象，还没有去执行它，调用generator对象的next()方法才会执行。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。 基本示例123456789101112function handleFn() &#123; return 1;&#125;let gen = function* () &#123; yield handleFn();&#125;;let g = gen();let result = g.next();console.log(result); //&#123; value: 1, done: false &#125; 使用方式执行generator对象有两个方法： 一是不断地调用generator对象的next()方法； 直接用for … of循环迭代generator对象，这种方式不需要我们自己判断done； 实例 打印一个菲波那切数列； 123456789101112131415161718192021222324252627function* fib(max) &#123; var t, a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n ++; &#125; return;&#125;// 1. next()方法输出结果var f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125;// 2. for ... of循环迭代generator对象输出结果for (var x of fib(5)) &#123; console.log(x); // 依次输出0, 1, 1, 2, 3, ...&#125; 执行异步任务 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 1234567891011121314function* gen() &#123; let url = "http://localhost:8080/test-api/testGet"; yield fetch(url);&#125;function testGenerator() &#123; let g = gen(); let result = g.next(); result.value.then(function (data) &#123; return data.json(); &#125;).then(function (data) &#123; console.log(data); &#125;);&#125; 【上述代码执行流程】首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 异步ES6中用Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 es8引入async/await异步函数，即在async标识的函数体内部，使用await调用异步方法，就会立刻执行，并将结果返回； 语法四种写法12341&gt; 函数声明： async function foo() &#123;&#125;2&gt; 函数表达式： const foo = async function() &#123;&#125;3&gt; 对象的方式： let obj = &#123; async foo() &#123;&#125; &#125;4&gt; 箭头函数： const foo = async () =&gt; &#123;&#125; 错误处理使用try..catch来处理错误：1234567async function asyncFunc() &#123; try &#123; await fetch(asyncTask()); &#125;catch (e) &#123; console.error(e); &#125;&#125; fetchasync/wait与fetch结合，可以像写同步代码一样写异步； 处理单个异步任务123456async function asyncFunc() &#123; let url = "http://localhost:8080/test-api/testGet"; let response = await fetch(url); let data = await response.json(); //注意此处返回Promise对象 console.log(data);&#125; 顺序处理多个异步任务12345async function asyncFunc() &#123; let url = "http://localhost:8080/test-api/testGet"; let response1 = await fetch(url); let response2 = await fetch(url);&#125; 并行处理多个异步任务12345678async function asyncFunc() &#123; let url = "http://localhost:8080/test-api/testGet"; const [res1, res2] = await Promise.all([ await fetch(url), await fetch(url) ]); console.log(res1, res2);&#125; 错误处理捕获异常1234567try &#123; ...&#125; catch (e) &#123; ...&#125; finally &#123; ...&#125; 错误类型 JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。 我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象。 抛出错误 程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。 抛出错误使用throw语句。 1throw new Error('输入错误'); 参考计时操作 setTimeout()未来的某时执行代码 clearTimeout()取消setTimeout() 123456789function callback() &#123; console.log('Done');&#125;function testMethod() &#123; console.log('before setTimeout()'); setTimeout(callback, 1000); // 1秒钟后调用callback函数 console.log('after setTimeout()');&#125; 全局函数可在全局直接调用； decodeURI() 解码某个编码的 URI。 decodeURIComponent() 解码一个编码的 URI 组件。 encodeURI() 把字符串编码为 URI。 encodeURIComponent() 把字符串编码为 URI 组件。 escape() 对字符串进行编码。 eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。 getClass() 返回一个 JavaObject 的 JavaClass。 isFinite() 检查某个值是否为有穷大的数。 isNaN() 检查某个值是否是数字。 Number() 把对象的值转换为数字。 parseFloat() 解析一个字符串并返回一个浮点数。 parseInt() 解析一个字符串并返回一个整数。 String() 把对象的值转换为字符串。 unescape() 对由 escape() 编码的字符串进行解码。 常见事件事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。 下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作： onabort 图像加载被中断 onblur 元素失去焦点 onchange 用户改变域的内容 onclick 鼠标点击某个对象 ondblclick 鼠标双击某个对象 onerror 当加载文档或图像时发生某个错误 onfocus 元素获得焦点 onkeydown 某个键盘的键被按下 onkeypress 某个键盘的键被按下或按住 onkeyup 某个键盘的键被松开 onload 某个页面或图像被完成加载 onmousedown 某个鼠标按键被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标被移到某元素之上 onmouseup 某个鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被调整尺寸 onselect 文本被选定 onsubmit 提交按钮被点击 onunload 用户退出页面]]></content>
      <categories>
        <category>大前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记]]></title>
    <url>%2F2016%2F01%2F09%2Fweb%2FCSS%2FCSS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录css笔记。 CSS基础CSS概念 CSS指层叠样式表(Cascading Style Sheets); 样式定义如何显示HTML元素的样式; 样式文件(.css)允许同时控制多重页面的样式和布局; 样式表类型（按优先级递减） 内联样式，定义在元素内部； 123&lt;p style="color: sienna; margin-left: 20px"&gt;hello world&lt;/p&gt; 内部样式表，定义在html的head头部； 1234567&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url(&quot;images/back40.gif&quot;);&#125;&lt;/style&gt;&lt;/head&gt; 外部/联样式表； 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 多重样式表 概述：html文档同时引用多个外联样式表，对同名的选择器有多个样式，那么选择器使用多个样式的并集，属性重复则使用就近原则进行覆盖； CSS样式结构格式CSS样式规则由两部分构成：选择器和一条或多条声明； 格式： 123/*selector &#123;property: value; property1: value1;...&#125;*//*例如：设置h1标签的样式：*/h1 &#123;color:red; font-size:14px;&#125; 选择器 1&gt; 概念 选择器的构成：标签元素、id(#id_name)、class(.class_name)、属性等； 2&gt; 特点 class 和 id 名称对大小写是敏感的； 声明 声明由属性和值组成； 声明与声明之间用分号隔开； 应该在每行只描述一个属性，这样可以增强样式定义的可读性； 属性值规则 1&gt; 如果值为若干单词，则要给值加引号: CSS选择器元素选择器概述： html文档的元素就是最基本的选择器; 元素选择器又称为类型选择器,类型选择器匹配文档语言元素类型的名称; 123html &#123;color:black;&#125;h1 &#123;color:blue;&#125;h2 &#123;color:silver;&#125; 12//CSS 元素选择器（类型选择器）可以设置 XML 文档中元素的样式&lt;?xml-stylesheet type="text/css" href="note.css"?&gt; 选择器分组概述一组选择器共享一个样式； 123h1,h2,h3,h4,h5,h6 &#123; color: green;&#125; 通配符选择器概述：CSS2 引入了通配选择器，显示为一个星号（*）。该选择器可以与任何元素匹配，就像是一个通配符,通配选择器等价于列出了文档中所有元素的一个分组选择器。。 12/*使文档中的每个元素都为红色*/* &#123;color:red;&#125; 选择器的继承性概述：子元素继承父元素属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd，IE6忽略继承） 1子元素如果没有设置color属性，会使用父元素的color属性; 类选择器概述 html每个标签元素都有一个class属性，在html文档中可以有多个同名的class；“.”加html标签元素的class名称组成类选择器。 类选择器允许以一种独立于文档元素的方式来指定样式。 该选择器可以单独使用，也可以与其他元素结合使用。 1.center &#123;text-align: center&#125; 基于所属标签类而被选择格式：标签名.类名 1&lt;td class="class_name"&gt; 12345678// 结合通配选择器=结合元素选择器//(因为指定了具体的类名，所以可以忽略通配符)td.class_name &#123; color: #f60; background: #666;&#125;*.class_name &#123;color:red;&#125; 多类选择器概述：类名由多个单词组成，各个词之间用空格分隔，每个单词都可以作为一个类选择器； 两个类选择器链接在一起，仅可以选择同时包含这些类名的元素（类名的顺序不限）； 如果一个多类选择器包含类名列表中没有的一个类名，匹配就会失败。 123&lt;p class="important warning"&gt;hello world&lt;/p&gt; 123.important &#123;font-weight:bold;&#125;.warning &#123;font-style:italic;&#125;.important.warning &#123;background:silver;&#125; 派生选择器概述：派生选择器又叫后代选择器； 后代选择器（descendant selector）又称为包含选择器。 后代选择器可以选择某元素的所有任意后代元素（包括间接后代）。 派生选择器，根据标签的上下文关系来定义的选择器，如：storng 被包裹在 li标签内，strong和li就具有上下文关系;派生选择器的有效范围是：li标签内的strong标签内的内容； 格式：父元素 子元素{…} 1234&lt;li&gt;hello&lt;strong&gt;word&lt;/strong&gt;&lt;/li&gt;&lt;div class="main"&gt; &lt;a link=""&gt;link&lt;/a&gt;&lt;/div&gt; 1234li strong &#123; font-style: italic; font-weight: normal;&#125; 格式：标签元素.类名/.类名 标签名/id选择器/类选择器 1234.fancy td &#123; color: #f60; background: #666;&#125; 直接子元素选择器概述：如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素直接子元素，请使用子元素选择器； 格式：父元素 &gt; 子元素 12h1 &gt; strong &#123;color:red;&#125;table.company td &gt; p&#123;...&#125; 相邻兄弟选择器概述如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器。 格式元素a +元素a后面的一个兄弟元素 案例：12345&lt;body&gt;&lt;h1&gt;This is a heading.&lt;/h1&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;p&gt;This is paragraph.&lt;/p&gt;&lt;/body&gt; 1h1 + p &#123;margin-top:50px;&#125; 结合其他选择器1html &gt; body table + ul &#123;margin-top:20px;&#125; id选择器概述html每个标签元素都有一个id属性，在html文档中只能出现一次；“#”加html标签元素的id名称组成id选择器。id选择器名仅有一个单词组成，不支持多个单词。 1&lt;p id="red"&gt;这个段落是红色。&lt;/p&gt; 1234// 结合通配符=独立使用// (因为指定了具体的id名，所以可以忽略通配符)*#red &#123;color:red&#125;#red &#123;color:red;&#125; id派生选择器格式：#id名 标签名/id选择器/类选择器1234567891011#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em;&#125;/*也可以用id紧跟所属的元素作为选择器*/div#sidebar &#123; border: 1px dotted #000; padding: 10px;&#125; 属性选择器概述属性选择器可以根据元素的属性及属性值来选择元素设置样式。 注意：属性与属性值必须完全匹配（在这里，像class属性值可以有分隔符和空格，必须匹配完整的值才行，除非使用特殊符号~=或|=） 格式 根据属性设置：[属性名]{…} 根据属性和属性值设置：[属性名=属性值]{…} *[属性名|属性名=属性值]{…} 根据多属性设置：[属性名1][属性名2]{…} 根据标签元素加属性设置：标签元素[属性名1][属性名2]{…} 123456// 设置包含标题（title）的所有元素变为红色*[title] &#123;color:red;&#125;// 只对有 href 属性的锚（a元素）设置样式a[href] &#123;color:red;&#125;// 将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色a[href][title] &#123;color:red;&#125; 1注释：只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择。 1&lt;img title="W3School" src="xxx.gif" /&gt; 123[title=ls]&#123; color: red;&#125; 属性值包含某字符如果需要根据属性值中的词列表的某个词进行选择，则需要使用波浪号（~）。 1&lt;img title="hello world" src="xxx.gif" /&gt; 1[title~=hello] &#123; color:red; &#125; 属性值含连字符1&lt;p lang="en-us"&gt;Hi!&lt;/p&gt; 1[lang|=en] &#123; color:red; &#125; 表单属性选择器属性选择器在为不带有 class 或 id 的表单设置样式12345&lt;form name="input" action="" method="get"&gt; &lt;input type="text" name="Name" value="Bill" size="20"&gt; &lt;input type="text" name="Name" value="Gates" size="20"&gt; &lt;input type="button" value="Example Button"&gt;&lt;/form&gt; 123456input[type="button"]&#123; width:120px; margin-left:35px; display:block; font-family: Verdana, Arial;&#125; 属性选择器属性值匹配参考12345678选择器：描述[attribute] 用于选取带有指定属性的元素。[attribute=value] 用于选取带有指定属性和值的元素。[attribute~=value] 用于选取属性值中包含指定词汇的元素。[attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。[attribute^=value] 匹配属性值以指定值开头的每个元素。[attribute$=value] 匹配属性值以指定值结尾的每个元素。[attribute*=value] 匹配属性值中包含指定值的每个元素。 伪类概述：CSS 伪类用于向某些选择器添加特殊的效果。 常见伪类参考W3C：”W3C” 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。 12345678属性 描述 CSS版本:active 向被激活的元素添加样式。 1:focus 向拥有键盘输入焦点的元素添加样式。 2:hover 当鼠标悬浮在元素上方时，向元素添加样式。 1:link 向未被访问的链接添加样式。 1:visited 向已被访问的链接添加样式。 1:first-child 向元素的第一个子元素添加样式。 2:lang 向带有指定 lang 属性的元素添加样式。 2 语法格式 伪类语法：selector : pseudo-class {property: value} CSS类与伪类搭配使用：selector.class : pseudo-class {property: value} 1&lt;a class="red" href="css_syntax.asp"&gt;CSS Syntax&lt;/a&gt; 1a.red : visited &#123;color: #FF0000&#125; CSS类id与伪类搭配：selector#id : pseudo-class {property: value} 锚(a链接)伪类锚伪类使用顺序： 提示：在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。 提示：在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。 提示：伪类名称对大小写不敏感。1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ :first-child伪类 格式：某标签元素:first-child{…} 概述：向某标签元素的第一个子元素设置样式； :lang伪类概述：向带有指定 lang 属性的元素添加样式; 1234567891011&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;q:lang(no)&#123; quotes: "~" "~"&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;文字&lt;q lang="no"&gt;段落中的引用的文字&lt;/q&gt;文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 伪元素概述：CSS 伪元素用于向某些选择器设置特殊效果。 常用的伪元素123456W3C：&quot;W3C&quot; 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。属性 描述 CSS:first-letter 向文本的第一个字母添加特殊样式。 1:first-line 向文本的首行添加特殊样式。 1:before 在元素之前添加内容。 2:after 在元素之后添加内容。 2 语法格式 伪元素语法：selector:pseudo-element {property:value;} CSS类与伪元素配合使用：selector.class:pseudo-element {property:value;} :first-line伪元素概述：”first-line” 伪元素用于向文本的首行设置特殊样式。 示例：根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化 1234p:first-line&#123; color:#ff0000; font-variant:small-caps;&#125; 要点： “first-line” 伪元素只能用于块级元素。 下面的属性可应用于 “first-line” 伪元素： 12345678910fontcolorbackgroundword-spacingletter-spacingtext-decorationvertical-aligntext-transformline-heightclear :first-letter伪元素概述：”first-letter” 伪元素用于向文本的首字母设置特殊样式： 1234p:first-letter&#123; color:#ff0000; font-size:xx-large;&#125; 要点： “first-letter” 伪元素只能用于块级元素。 可以给同个selector设置多个伪元素； 下面的属性可应用于 “first-letter” 伪元素： 123456789101112fontcolorbackgroundmarginpaddingbordertext-decorationvertical-align (仅当 float 为 none 时)text-transformline-heightfloatclear（左侧和右侧均不允许出现浮动元素） :before伪元素概述：”:before” 伪元素可以在元素的内容前面插入新内容。 123h1:before&#123; content:url(logo.gif);&#125; :after伪元素概述：”:after” 伪元素可以在元素的内容之后插入新内容。 1234// 示例：下面的例子在每个 &lt;h1&gt; 元素后面插入一幅图片：h1:after&#123; content:url(logo.gif);&#125; CSS3选择器参考123456789101112131415161718192021222324252627282930313233343536373839404142434445选择器 例子 例子描述 CSS.class .intro 选择 class=&quot;intro&quot; 的所有元素。 1#id #firstname 选择 id=&quot;firstname&quot; 的所有元素。 1* * 选择所有元素。 2element p 选择所有 &lt;p&gt; 元素。 1element,element div,p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 1element element div p 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。 1element&gt;element div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。 2element+element div+p 选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。 2[attribute] [target] 选择带有 target 属性所有元素。 2[attribute=value] [target=_blank] 选择 target=&quot;_blank&quot; 的所有元素。 2[attribute~=value] [title~=flower] 选择 title 属性包含单词 &quot;flower&quot; 的所有元素。 2[attribute|=value] [lang|=en] 选择 lang 属性值以 &quot;en&quot; 开头的所有元素。 2:link a:link 选择所有未被访问的链接。 1:visited a:visited 选择所有已被访问的链接。 1:active a:active 选择活动链接。 1:hover a:hover 选择鼠标指针位于其上的链接。 1:focus input:focus 选择获得焦点的 input 元素。 2:first-letter p:first-letter 选择每个 &lt;p&gt; 元素的首字母。 1:first-line p:first-line 选择每个 &lt;p&gt; 元素的首行。 1:first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 2:before p:before 在每个 &lt;p&gt; 元素的内容之前插入内容。 2:after p:after 在每个 &lt;p&gt; 元素的内容之后插入内容。 2:lang(language) p:lang(it) 选择带有以 &quot;it&quot; 开头的 lang 属性值的每个 &lt;p&gt; 元素。 2element1~element2 p~ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 3[attribute^=value] a[src^=&quot;https&quot;] 选择其 src 属性值以 &quot;https&quot; 开头的每个 &lt;a&gt; 元素。 3[attribute$=value] a[src$=&quot;.pdf&quot;] 选择其 src 属性以 &quot;.pdf&quot; 结尾的所有 &lt;a&gt; 元素。 3[attribute*=value] a[src*=&quot;abc&quot;] 选择其 src 属性中包含 &quot;abc&quot; 子串的每个 &lt;a&gt; 元素。 3:first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 3:last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 3:only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 3:only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 3:nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 3:nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3:nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 3:nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3:last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 3:root :root 选择文档的根元素。 3:empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 3:target #news:target 选择当前活动的 #news 元素。 3:enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 3:disabled input:disabled 选择每个禁用的 &lt;input&gt; 元素 3:checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 3:not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 3::selection ::selection 选择被用户选取的元素部分。 3 CSS样式大小 宽高：height width 1234auto 默认。浏览器会计算出实际的高度。length 使用 px、cm 等单位定义高度。% 基于包含它的块级对象的百分比高度。inherit 规定应该从父元素继承 height 属性的值 line-height 行与行之间的基线间的距离（设置行内元素行高，块级元素基线之间的最小距离）。 12345normal 默认。设置合理的行间距。number 设置数字，此数字会与当前的字体尺寸相乘来设置行间距。length 设置固定的行间距。% 基于当前字体尺寸的百分比行间距。inherit 规定应该从父元素继承 line-height 属性的值。 max-height、max-width 设置元素的最大高度。 1234none 默认。定义对元素被允许的最大高度没有限制。length 定义元素的最大高度值。% 定义基于包含它的块级对象的百分比最大高度。inherit 规定应该从父元素继承 max-height 属性的值。 设置元素的最大宽度。 1234none 默认。定义对元素的最大宽度没有限制。length 定义元素的最大宽度值。% 定义基于包含它的块级对象的百分比最大宽度。inherit 规定应该从父元素继承 max-width 属性的值。 设置元素的最小宽度 min-height min-width。 123length 定义元素的最小高度。默认值是 0。% 定义基于包含它的块级对象的百分比最小高度。inherit 规定应该从父元素继承 min-height 属性的值。 背景背景属性概览1234567属性 描述background 简写属性，作用是将背景属性设置在一个声明中。background-attachment 背景图像是否固定或者随着页面的其余部分滚动。background-color 设置元素的背景颜色。background-image 把图像设置为背景。background-position 设置背景图像的起始位置。background-repeat 设置背景图像是否及如何重复。 背景色 属性名：background-color 目标元素：可以为所有元素设置背景色，这包括 body 一直到 em 和 a 等行内元素。 属性值：默认transparent，接受任何合法的颜色值； 1p &#123;background-color: gray;&#125; 背景图像属性名：background-image 属性值: 默认none 1body &#123;background-image: url(/i/eg_bg_04.gif);&#125; 背景重复属性名：background-repeat 属性值： repeat-y：垂直方向重复 repeat-x no-repeat 1234body&#123; background-image: url(/i/eg_bg_03.gif); background-repeat: repeat-y;&#125; 背景定位概述：利用background-position属性改变图像在背景中的位置。 属性值：标准两个值（水平方向定位 垂直方向定位）,如果有一个值，则另一个值时center; top、bottom、left、right 和 center top center、center center 百分数值：10% 20% 长度值：20px 10px 12345body&#123; background-image:url('/i/eg_bg_03.gif'); background-repeat:no-repeat; background-position:center;&#125; 背景关联概述：长文档，上下滚动时，控制背景的联动样式； 属性值： scroll：默认值。背景图像会随着页面其余部分的滚动而移动。 fixed：当页面的其余部分滚动时，背景图像不会移动。 inherit：规定应该从父元素继承 background-attachment 属性的设置。 12345body&#123; background-image:url(/i/eg_bg_02.gif); background-repeat:no-repeat; background-attachment:fixed&#125; 背景属性概述： 属性名：background 属性值： 12345678910值 描述 CSSbackground-color 规定要使用的背景颜色。 1background-position 规定背景图像的位置。 1background-size 规定背景图片的尺寸。 3background-repeat 规定如何重复背景图像。 1background-origin 规定背景图片的定位区域。 3background-clip 规定背景的绘制区域。 3background-attachment 规定背景图像是否固定或者随着页面的其余部分滚动。 1background-image 规定要使用的背景图像。 1inherit 规定应该从父元素继承 background 属性的设置。 1 在一个声明中可以设置所有背景属性（不区分顺序和完整性）：123body&#123; background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center;&#125; 文本概述：文本属性可定义文本的外观； 常用CSS文本属性 12345678910111213属性 描述color 设置文本颜色direction 设置文本方向。line-height 设置行高。letter-spacing 设置字符间距。text-align 对齐元素中的文本。text-decoration 向文本添加修饰。text-indent 缩进元素中文本的首行。text-shadow 设置文本阴影。CSS2 包含该属性，但是 CSS2.1 没有保留该属性。text-transform 控制元素中的字母。unicode-bidi 设置文本方向。white-space 设置元素中空白的处理方式。word-spacing 设置字间距。 缩进文本属性名：text-indent 1p &#123;text-indent: 5em;&#125; 概述：对文档标签中文本进行首行缩进； 设置目标：所有块级元素应用 text-indent，但无法将该属性应用于行内元素； 属性值： 使用正负值 使用百分比值：缩进值是父元素的 20%； 继承：子元素可以继承父元素的缩进属性； 水平对齐属性名text-align 针对行内或者块元素内部的文字、图片、按钮； 属性值12345left 把文本排列到左边。默认值：由浏览器决定。right 把文本排列到右边。center 把文本排列到中间。justify 实现两端对齐文本效果。inherit 规定应该从父元素继承 text-align 属性的值。 文本方向属性名direction 针对目标 主要影响块级元素中文本的方向; 对于行内元素，只有当 unicode-bidi 属性设置为 embed 或 bidi-override 时才会应用 direction 属性。 属性值123ltr 默认。文本方向从左到右。rtl 文本方向从右到左。inherit 规定应该从父元素继承 direction 属性的值。 示例：1p&#123;direction: rtl&#125; 书写的方向writing-mode：horizontal-tb | vertical-rl | vertical-lr | lr-tb | tb-rl 默认值：normal 适用于：除 &lt;’ display ‘&gt; 属性定义为table-row-group | table-column-group | table-row | table-column之外的所有元素; 12345horizontal-tb：水平方向自上而下的书写方式。即left-right-top-bottom（类似IE私有值lr-tb）vertical-rl：垂直方向自右而左的书写方式。即top-bottom-right-left（类似IE私有值tb-rl）vertical-lr：垂直方向自左而右的书写方式。即 top-bottom-left-rightlr-tb(ie)：左-右，上-下。对象中的内容在水平方向上从左向右流入，后一行在前一行的下面。 所有的字形都是竖直向上的。这种布局是罗马语系使用的（IE）tb-rl(ie)：上-下，右-左。对象中的内容在垂直方向上从上向下流入，自右向左。后一竖行在前一竖行的左面。全角字符是竖直向上的，半角字符如拉丁字母或片假名顺时针旋转90度。这种布局是东亚语系通常使用的（IE） 字(单词)间隔属性名word-spacing 属性值123normal 默认。定义单词间的标准空间。length 定义单词间的固定空间，可以是正负长度。inherit 规定应该从父元素继承 word-spacing 属性的值。 示例： 12p &#123;word-spacing: 30px;&#125;p &#123;word-spacing: -0.5em;&#125; 字符或字母间隔属性名letter-spacing 属性值123normal 默认。规定字符间没有额外的空间。length 定义字符间的固定空间（允许使用负值）。inherit 规定应该从父元素继承 letter-spacing 属性的值。 示例：12h1 &#123;letter-spacing:2px&#125;h2 &#123;letter-spacing:-3px&#125; 大小写转换属性名text-transform 属性值12345none 默认。定义带有小写字母和大写字母的标准的文本。capitalize 文本中的每个单词以大写字母开头。uppercase 定义仅有大写字母。lowercase 定义无大写字母，仅有小写字母。inherit 规定应该从父元素继承 text-transform 属性的值。 示例：123h1 &#123;text-transform:uppercase&#125;h2 &#123;text-transform:capitalize&#125;p &#123;text-transform:lowercase&#125; 文本装饰属性名text-decoration 属性值123456none 默认。定义标准的文本，关闭所有装饰。underline 文本下划线。overline 文本上划线。line-through 文本中划线（删除线）等效于strike标签。blink 定义闪烁的文本。inherit 规定应该从父元素继承 text-decoration 属性的值。 设置上述单个属性值； 可以同时设置多个属性值效果； 示例：12345h1 &#123;text-decoration:overline&#125;h2 &#123;text-decoration:line-through&#125;h3 &#123;text-decoration:underline&#125;h4 &#123;text-decoration:blink&#125;div&#123;text-decoration: underline line-through overline;&#125; 处理空白符属性名white-space 属性值123456normal 默认。空白会被浏览器忽略。pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap 保留空白符序列，但是正常地进行换行。pre-line 合并空白符序列，但是保留换行符。inherit 规定应该从父元素继承 white-space 属性的值。 示例：1p&#123;white-space: nowrap&#125; 字体字体属性概览123456789属性 描述font 简写属性。作用是把所有针对字体的属性设置在一个声明中。font-family 设置字体系列。font-size 设置字体的尺寸。font-size-adjust 当首选字体不可用时，对替换字体进行智能缩放。（CSS2.1 已删除该属性。）font-stretch 对字体进行水平拉伸。（CSS2.1 已删除该属性。）font-style 设置字体风格。font-variant 以小型大写字体或者正常字体显示文本。font-weight 设置字体的粗细。 字体类系5种通用字体系列注意：小写 serif sans-serif monospace cursive fantasy 通用系列的具体字体 serif：Times、Georgia、New Century Schoolbook sans-serif：Helvetica、Geneva、Verdana、Arial 或 Univers monospace：Courier、Courier New 和 Andale Mono cursive：Zapf Chancery、Author 和 Comic Sans fantasy：Western、Woodblock 和 Klingon 设置字体font-family 注意：当字体名中有一个或多个空格（比如 New York），或者如果字体名包括#或$之类的符号，需要在font-family 声明中加引号（支持单引号和双引号）。 1234567// 设置通用字体系列body &#123;font-family: sans-serif;&#125;// 设置通用字体系列中的具体字体h1 &#123;font-family: Georgia, serif;&#125;// 设置通用字体系列中的具体字体,按照优先顺序排列备用字体p &#123;font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif;&#125; 字体风格font-style 属性值1234normal 默认值。浏览器显示一个标准的字体样式。italic 每个字母都倾斜。oblique 竖直文本的一个倾斜版本。inherit 规定应该从父元素继承字体样式。 示例： 123p.normal &#123;font-style:normal;&#125;p.italic &#123;font-style:italic;&#125;p.oblique &#123;font-style:oblique;&#125; 字体变形font-variant 属性值123normal 默认值。浏览器会显示一个标准的字体。small-caps 将非大写字母设置成小型大写字母。inherit 规定应该从父元素继承 font-variant 属性的值。 示例： 1p &#123;font-variant:small-caps;&#125; 字体加粗font-weight 属性值 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100~900 为字体指定了 9 级加粗度，100 对应最细的字体变形，900 对应最粗的字体变形。数字 400 等价于 normal，而 700 等价于 bold。 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 inherit 规定应该从父元素继承字体的粗细。 示例 123p.normal &#123;font-weight:normal;&#125;p.thick &#123;font-weight:bold;&#125;p.thicker &#123;font-weight:900;&#125; 字体大小font-size 1注意：如果您没有规定字体大小，普通文本（比如段落）的默认大小是 16 像素 (16px=1em)。 属性值 把字体的尺寸设置为不同的尺寸，从 xx-small 到 xx-large。默认值：medium。 1234567xx-smallx-smallsmallmediumlargex-largexx-large smaller 把 font-size 设置为比父元素更小的尺寸。 larger 把 font-size 设置为比父元素更大的尺寸。 length 把 font-size 设置为一个固定的值。 123// 尺寸单位- px: 通过像素设置文本大小;- em: W3C推荐使用em作为字体尺寸单位，可以避免在 Internet Explorer 中无法调整文本的问题； 123em是相对父容器字体大小计算来的，即piexl=parentFontPixel*nem;浏览器中默认的文本大小是 16 像素。因此 1em 的默认尺寸是 16 像素。如果父元素文本大小是32px, 子元素字体是1em % 把 font-size 设置为基于父元素的一个百分比值。 inherit 规定应该从父元素继承字体尺寸。 示例123h1 &#123;font-size:60px;&#125;h1 &#123;font-size:3.75em;&#125;body &#123;font-size:100%;&#125; 链接为链接设置样式 链接的四种伪类状态： a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方 a:active - 链接被点击的时刻 当为链接的不同状态设置样式时，请按照以下次序规则： a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 示例1234a:link &#123;background-color:#B2FF99;&#125;a:visited &#123;background-color:#FFFF85;&#125;a:hover &#123;background-color:#FF704D;&#125;a:active &#123;background-color:#FF704D;&#125; 列表列表属性允许你放置、改变列表项标志，或者将图像作为列表项标志。 列表属性123456属性 描述list-style 简写属性。用于把所有用于列表的属性设置于一个声明中。list-style-image 将图象设置为列表项标志。list-style-position 设置列表中列表项标志的位置。list-style-type 设置列表项标志的类型。marker-offset 列表项标志类型list-style-type 属性值CSS2 的值：12345678910111213141516171819202122值 描述none 无标记。disc 默认。标记是实心圆。circle 标记是空心圆。square 标记是实心方块。decimal 标记是数字。decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。)lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。)upper-roman 大写罗马数字(I, II, III, IV, V, 等。)lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)lower-greek 小写希腊字母(alpha, beta, gamma, 等。)lower-latin 小写拉丁字母(a, b, c, d, e, 等。)upper-latin 大写拉丁字母(A, B, C, D, E, 等。)hebrew 传统的希伯来编号方式armenian 传统的亚美尼亚编号方式georgian 传统的乔治亚编号方式(an, ban, gan, 等。)cjk-ideographic 简单的表意数字hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） CSS2.1 的值：123disc | circle | square | decimal | decimal-leading-zero |lower-roman | upper-roman | lower-greek | lower-latin | upper-latin |armenian | georgian | none | inherit 示例123456// 设置不同的列表样式ul &#123;list-style-type : square&#125;ul.circle &#123;list-style-type:circle;&#125;ul.square &#123;list-style-type:square;&#125;ol.upper-roman &#123;list-style-type:upper-roman;&#125;ol.lower-alpha &#123;list-style-type:lower-alpha;&#125; 列表项图像list-style-image 概述：有时，常规的标志是不够的。你可能想对各标志使用一个图像； 1ul li &#123;list-style-image : url(xxx.gif)&#125; 列表标志位置list-style-position 概述：CSS2.1 可以确定标志出现在列表项内容之外还是内容内部。 属性值1234值 描述inside 列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inherit 规定应该从父元素继承 list-style-position 属性的值。 示例123ul.inside &#123; list-style-position: inside&#125; 列表样式合并写法list-style 属性值可以同时包含list-style-type、list-style-image、list-style-position、inherit值，并且值无顺序； 1li &#123;list-style : url(example.gif) square inside&#125; 表格常用属性123456属性 描述border-collapse 设置是否把表格边框合并为单一的边框。border-spacing 设置分隔单元格边框的距离。caption-side 设置表格标题的位置。empty-cells 设置是否显示表格中的空单元格。table-layout 设置显示单元、行和列的算法。 表格边框border 12345// 为 table、th 以及 td 设置了蓝色边框// 写法 1：table, th, td&#123;border: 1px solid blue;&#125;// 写法 2：table,th,td&#123;border:1px solid;&#125; 注：详见边框 边框线border-collapse 属性设置是否将表格边框折叠为单一边框： 属性值123separate 默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性。collapse 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。inherit 规定应该从父元素继承 border-collapse 属性的值。 示例12table&#123;border-collapse:collapse;&#125;table,th, td&#123;border: 1px solid black;&#125; 表格宽度和高度12table&#123;width:100%;&#125;th&#123;height:50px;&#125; 表格文本对齐text-align 和 vertical-align 属性设置表格中文本的对齐方式。 text-align属性设置水平对齐方式，比如左对齐、右对齐或者居中：1td&#123;text-align:right;&#125; vertical-align属性设置垂直对齐方式，比如顶部对齐、底部对齐或居中对齐：1234td&#123; height:50px; vertical-align:bottom;&#125; 表格内边距1td&#123;padding:15px;&#125; 详见：边框内边距； 表格颜色下面的例子设置边框的颜色，以及 th 元素的文本和背景颜色：12345678table, td, th&#123; border:1px solid green;&#125;th&#123; background-color:green; color:white;&#125; 单元格间距border-spacing 属性设置相邻单元格的边框间的距离（仅用于“边框分离”模式）。 1注释：某些版本的IE浏览器不支持此属性。 属性值 length length 规定相邻单元的边框之间的距离。 123使用 px、cm 等单位。不允许使用负值。如果定义一个 length 参数，那么定义的是水平和垂直间距。如果定义两个 length 参数，那么第一个设置水平间距，而第二个设置垂直间距。 inherit 规定应该从父元素继承 border-spacing 属性的值。 标题位置caption-side 属性设置表格标题的位置。 属性值 top 默认值。把表格标题定位在表格之上。 bottom 把表格标题定位在表格之下。 inherit 规定应该从父元素继承 caption-side 属性的值。 空单元格empty-cells 属性值： hide 不在空单元格周围绘制边框。 show 在空单元格周围绘制边框。默认。 inherit 规定应该从父元素继承 empty-cells 属性的值。 示例隐藏表格中空单元格上的边框和背景：1234table&#123; border-collapse:separate; empty-cells:hide;&#125; 列宽度算法table-layout 概述tableLayout 属性用来显示表格单元格、行、列的算法规则。 属性值 automatic 默认。列宽度由单元格内容设定。 fixed 列宽由表格宽度和列宽度设定。 inherit 规定应该从父元素继承 table-layout 属性的值。 示例1table&#123;table-layout:fixed;&#125; 轮廓线 轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 CSS outline 属性规定元素轮廓的样式、颜色和宽度。 属性概览12345属性 描述 CSSoutline 在一个声明中设置所有的轮廓属性。 2outline-color 设置轮廓的颜色。 2outline-style 设置轮廓的样式。 2outline-width 设置轮廓的宽度。 轮廓线样式outline-style 概述设置轮廓的样式： 属性值12345678910none 默认。定义无轮廓。dotted 定义点状的轮廓。dashed 定义虚线轮廓。solid 定义实线轮廓。double 定义双线轮廓。双线的宽度等同于 outline-width 的值。groove 定义 3D 凹槽轮廓。此效果取决于 outline-color 值。ridge 定义 3D 凸槽轮廓。此效果取决于 outline-color 值。inset 定义 3D 凹边轮廓。此效果取决于 outline-color 值。outset 定义 3D 凸边轮廓。此效果取决于 outline-color 值。inherit 规定应该从父元素继承轮廓样式的设置。 示例1p&#123;outline-style:dotted;&#125; 轮廓线颜色outline-color 概述outline-color 属性设置一个元素整个轮廓中可见部分的颜色。要记住，轮廓的样式不能是 none，否则轮廓不会出现。 注意： 请始终在 outline-color 属性之前声明 outline-style 属性。元素只有获得轮廓以后才能改变其轮廓的颜色。 轮廓线不会占据空间，也不一定是矩形。 属性值 颜色值 invert 默认。执行颜色反转（逆向的颜色）。可使轮廓在不同的背景颜色中都是可见。 inherit 规定应该从父元素继承轮廓颜色的设置。 示例1234p&#123; outline-style:dotted; outline-color:#00ff00;&#125; 轮廓线宽度outline-width 概述outline-width 属性设置元素整个轮廓的宽度； 注意： 只有当轮廓样式不是 none 时，这个宽度才会起作用。 如果样式为 none，宽度实际上会重置为 0。 不允许设置负长度值。 请始终在 outline-width 属性之前声明 outline-style 属性。元素只有获得轮廓以后才能改变其轮廓的颜色。 轮廓线不会占据空间，也不一定是矩形。 属性值 thin 规定细轮廓。 medium 默认。规定中等的轮廓。 thick 规定粗的轮廓。 length 允许您规定轮廓粗细的值。 inherit 规定应该从父元素继承轮廓宽度的设置。 示例1234p&#123; outline-style:dotted; outline-width:5px;&#125; 轮廓样式简写outline 概述 outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 outline 简写属性在一个声明中设置所有的轮廓属性。 1234可以按顺序设置如下属性：outline-coloroutline-styleoutline-width 属性值12345值 描述outline-color 规定边框的颜色。参阅：outline-color 中可能的值。outline-style 规定边框的样式。参阅：outline-style 中可能的值。outline-width 规定边框的宽度。参阅：outline-width 中可能的值。inherit 规定应该从父元素继承 outline 属性的设置。 示例1p&#123;outline:#00FF00 dotted thick;&#125; CSS框模型CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式 内边距padding padding-top padding-right padding-bottom padding-left 概述CSS padding 属性定义元素的内边距。 属性值 auto 浏览器计算内边距。 % 规定基于父元素的宽度的百分比的内边距。 inherit 规定应该从父元素继承内边距。 length 规定以具体单位计的内边距值，比如像素、厘米等。默认值是 0px。但不允许使用负值。 1234567length 格式：1&gt; length length length length3&gt; length 或 length length 值复制这两个值可以取代前面 4 个值。，允许指定少于 4 个值。规则如下：如果缺少左外边距的值，则使用右外边距的值。如果缺少下外边距的值，则使用上外边距的值。如果缺少右外边距的值，则使用上外边距的值。 示例1234567891011121314// 按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值：h1 &#123;padding: 10px 0.25em 2ex 20%;&#125;h1 &#123; padding-top: 10px; padding-right: 0.25em; padding-bottom: 2ex; padding-left: 20%;&#125;// 各边内边距相同h1 &#123;padding: 10px;&#125;// 设置为父元素 width 的 10%p &#123;padding: 10%;&#125;// 值复制td.test2 &#123;padding: 0.5cm 2.5cm&#125; 外边距12345margin 简写属性。在一个声明中设置所有外边距属性。margin-bottom 设置元素的下外边距。margin-left 设置元素的左外边距。margin-right 设置元素的右外边距。margin-top 设置元素的上外边距。 属性值同内边距 示例1234567891011p &#123;margin: 20px 30px 30px 20px;&#125;p &#123;margin: auto auto auto 20px;&#125;h2 &#123; margin-top: 20px; margin-right: 30px; margin-bottom: 30px; margin-left: 20px;&#125;h1 &#123;margin: 0.25em 1em 0.5em;&#125; /* 等价于 0.25em 1em 0.5em 1em */h2 &#123;margin: 0.5em 1em;&#125; /* 等价于 0.5em 1em 0.5em 1em */p &#123;margin: 1px;&#125; /* 等价于 1px 1px 1px 1px */ 边框 元素的边框绘制在背景之上。 CSS border 属性允许你规定元素边框的样式、宽度和颜色。 属性概览123456789101112131415161718192021属性 描述border 简写属性，用于把针对四个边的属性设置在一个声明。border-style 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。border-width 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。border-color 简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。border-bottom 简写属性，用于把下边框的所有属性设置到一个声明中。border-bottom-color 设置元素的下边框的颜色。border-bottom-style 设置元素的下边框的样式。border-bottom-width 设置元素的下边框的宽度。border-left 简写属性，用于把左边框的所有属性设置到一个声明中。border-left-color 设置元素的左边框的颜色。border-left-style 设置元素的左边框的样式。border-left-width 设置元素的左边框的宽度。border-right 简写属性，用于把右边框的所有属性设置到一个声明中。border-right-color 设置元素的右边框的颜色。border-right-style 设置元素的右边框的样式。border-right-width 设置元素的右边框的宽度。border-top 简写属性，用于把上边框的所有属性设置到一个声明中。border-top-color 设置元素的上边框的颜色。border-top-style 设置元素的上边框的样式。border-top-width 设置元素的上边框的宽度。 边框的样式 border-style border-top-style border-right-style border-bottom-style border-left-style 注意border-style支持设置小于或等于4个值（上、右、下、左），支持css值复制属性； 属性值 none 定义无边框。 hidden 与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。 dotted 定义点状边框。在大多数浏览器中呈现为实线。 dashed 定义虚线。在大多数浏览器中呈现为实线。 solid 定义实线。 double 定义双线。双线的宽度等于 border-width 的值。 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值。 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值。 inset 定义 3D inset 边框。其效果取决于 border-color 的值。 outset 定义 3D outset 边框。其效果取决于 border-color 的值。 inherit 规定应该从父元素继承边框样式。 示例1234567p&#123;border-style: outset;&#125;// 一个边框定义多个样式p&#123;border-style:dotted solid double dashed; &#125;p&#123;border-style:dotted solid;&#125;p&#123;border-style:dotted;&#125;// 设置单一边框样式p &#123;border-left-style: none;&#125; 边框的宽度 border-width 边框宽度 border-top-width border-right-width border-bottom-width border-left-width概述 只有当边框样式不是 none 时才起作用。 如果边框样式是 none，边框宽度实际上会重置为 0。 不允许指定负长度值。 支持设置小于或等于4个值（上、右、下、左），支持css值复制属性； 属性值 thin 定义细的边框。 medium 默认。定义中等的边框。 thick 定义粗的边框。 length 允许您自定义边框的宽度。 inherit 规定应该从父元素继承边框宽度。 示例123456789p &#123;border-style: solid; border-width: 15px 5px 15px 5px;&#125;p &#123; border-style: solid; border-top-width: 15px; border-right-width: 5px; border-bottom-width: 15px; border-left-width: 5px;&#125;p &#123;border-style: solid; border-width: 15px 5px;&#125; 边框的颜色 border-color border-top-color border-right-color border-bottom-color border-left-color 概述 支持设置小于或等于4个值（上、右、下、左），支持css值复制属性； 属性值 颜色值 transparent 默认值。边框颜色为透明。 inherit 规定应该从父元素继承边框颜色。 示例12345678p &#123; border-style: solid; border-color: blue rgb(25%,35%,45%) #909090 red;&#125;p &#123; border-style: solid; border-color: blue red;&#125; 外边距合并 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 元素定位 元素调整在文档中的位置； CSS 有三种基本的定位机制：普通流、浮动和绝对定位。 12【普通流】除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在 (X)HTML 中的位置决定。 元素的框 块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。 行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。 12div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。 框的类型display 属性规定元素应该生成的框的类型； 属性值12345678910111213141516171819none 此元素不会被显示。block 此元素将显示为块级元素，此元素前后会带有换行符。inline 默认。此元素会被显示为内联元素，元素前后没有换行符。inline-block 作用域子元素，让子元素成为行内块元素,不独占一行的块级元素，横向排列。（CSS2.1 新增的值）list-item 此元素会作为列表显示。run-in 此元素会根据上下文作为块级元素或内联元素显示。compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;）table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）inherit 规定应该从父元素继承 display 属性的值。 示例1234// p显示为内联元素p &#123;display: inline&#125;// span显示为块级元素span&#123;display: block&#125; 元素定位CSS 定位属性允许你对元素进行定位。 12345678910属性 描述position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。top 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。right 定义了定位元素右外边距边界与其包含块右边界之间的偏移。bottom 定义了定位元素下外边距边界与其包含块下边界之间的偏移。left 定义了定位元素左外边距边界与其包含块左边界之间的偏移。overflow 设置当元素的内容溢出其区域时发生的事情。clip 设置元素的形状。元素被剪入这个形状之中，然后显示出来。vertical-align 设置元素的垂直对齐方式。z-index 设置元素的堆叠顺序。 位置坐标left, top, right和bottom 元素值：1234auto 默认值。通过浏览器计算上边缘的位置。% 设置以包含元素的百分比计的上边位置。可使用负值。length 使用 px、cm 等单位设置元素的上边位置。可使用负值。inherit 规定应该从父元素继承 top 属性的值。 示例1234img&#123; position:absolute; top:5px;&#125; 定位类型position 概述通过使用 position 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。 属性值 absolute 相对第一个父元素进行定位，原本所占的空间删除。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 相对于浏览器窗口进行绝对定位，原本所占的空间删除。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 相对于正常位置进行定位，原本所占的空间仍保留；因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。 示例 absolute 绝对定位12345h2&#123; position:absolute; left:100px; top:150px;&#125; 溢出内容控制overflow 概述overflow 属性规定当内容溢出元素框时发生的事情。 属性值12345visible 默认值。内容不会被修剪，会呈现在元素框之外。hidden 内容会被修剪，并且其余内容是不可见的。scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit 规定应该从父元素继承 overflow 属性的值。 示例使用滚动条来显示元素内溢出的内容123456div &#123; background-color:#00FFFF; width:150px; height:150px; overflow: scroll;&#125; 裁剪元素的形状clip 概述clip 属性剪裁绝对定位元素（absolute和fixed）。 属性值 shape 设置元素的形状。唯一合法的形状值是：rect (top, right, bottom, left) auto 默认值。不应用任何剪裁。 inherit 规定应该从父元素继承 clip 属性的值。 示例1234img &#123; position:absolute; clip:rect(0px 50px 200px 0px)&#125; 垂直对齐vertical-align 概述 属性设置元素在当前行内相对于行内内容的垂直对齐方式。 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。 在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 属性值1234567891011baseline 默认。元素放置在父元素的基线上。sub 垂直对齐文本的下标。super 垂直对齐文本的上标top 把元素的顶端与行中最高元素的顶端对齐text-top 把元素的顶端与父元素字体的顶端对齐middle 把此元素放置在父元素的中部。bottom 把元素的顶端与行中最低的元素的顶端对齐。text-bottom 把元素的底端与父元素字体的底端对齐。length% 使用 &quot;line-height&quot; 属性的百分比值来排列此元素。允许使用负值。inherit （IE不支持）规定应该从父元素继承 vertical-align 属性的值。 元素的堆叠概述 z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面(上层)。 元素可拥有负的 z-index 属性值。 z-index 仅能在设置position的定位元素上奏效（例如 position:absolute;） 属性值 auto 默认。堆叠顺序与父元素相等。 number 设置元素的堆叠顺序。 inherit 规定应该从父元素继承 z-index 属性的值。 示例123456div &#123; position:absolute; left:0px; top:0px; z-index:-1;&#125; 浮动框元素浮动float 概述 float 属性定义元素在哪个方向浮动。 浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动框周围是有内容的块框，浮动框不会覆盖内容框，视觉上没有浮动效果。 浮动框周围是无内容的块框，浮动框不占据空间，浮动并覆盖下一个元素。 如果三个浮动框都是left浮动，则会出现三个浮动框水平方向上排列； 属性值 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素不浮动，并会显示在其在文本中出现的位置。 inherit 规定应该从父元素继承 float 属性的值。 示例1img&#123;float:right;&#125; 清除浮动clear 概述clear 表示框的哪些边不应该挨着浮动框，即清除对应边浮动元素框的浮动效果。 属性值 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 none 默认值。允许浮动元素出现在两侧。 inherit 规定应该从父元素继承 clear 属性的值。 示例清除img两侧浮动元素框的浮动效果1234img&#123; float:left; clear:both;&#125; 参考元素显隐visibility visible 默认值。元素是可见的。 hidden 元素是不可见的。 collapse 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。 inherit 规定应该从父元素继承 visibility 属性的值。 示例 1h2&#123;visibility:hidden;&#125; 水平导航栏实现方式：设置行内或浮动列表项； 12li&#123;display:inline;&#125;li&#123;float:left;&#125; 图像透明度 opacity: 值从 0.0 到 1.0,值越小，越透明。 IE8 以及更早的版本使用滤镜 filter:alpha(opacity=x)。x 能够取的值从 0 到 100。值越小，越透明。 示例： 12345678img&#123; opacity:0.4; filter:alpha(opacity=40); /* 针对 IE8 以及更早的版本 */&#125;img:hover&#123; opacity:1.0; filter:alpha(opacity=100); /* 针对 IE8 以及更早的版本 */&#125; CSS单位 % 百分比 in 英寸 cm 厘米 mm 毫米 em 12341em 等于当前的字体尺寸。2em 等于当前字体尺寸的两倍。例如，如果某元素以 12pt 显示，那么 2em 是24pt。在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体。 ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。) pt 磅 (1 pt 等于 1/72 英寸),多做字体。 pc 12 点活字 (1 pc 等于 12 点) px 像素 (计算机屏幕上的一个点) 颜色123456789101112/*颜色英文名(浏览器支持的有16种)*/p &#123;color: red;&#125;/*十六进制的颜色值*/p &#123; color: #ff0000; &#125;/*十六进制的颜色值节约字节写法*/p &#123; color: #f00; &#125;/*RGB值*/p &#123; color: rgb(255,0,0); &#125;/*RGB 百分比必须加 %*/p &#123; color: rgb(100%,0%,0%); &#125;/*rgba设置颜色和透明度，此时子元素不会继承父元素的透明度（r,g,b,alpha）*/p &#123; color: rgba(0, 0, 0, 0.7); &#125; 鼠标样式cursor url 12需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。 default 默认光标（通常是一个箭头） auto 默认。浏览器设置的光标。 crosshair 光标呈现为十字线。 pointer 光标呈现为指示链接的指针（一只手） move 此光标指示某对象可被移动。 e-resize 此光标指示矩形框的边缘可被向右（东）移动。 ne-resize 此光标指示矩形框的边缘可被向上及向右移动（北/东）。 nw-resize 此光标指示矩形框的边缘可被向上及向左移动（北/西）。 n-resize 此光标指示矩形框的边缘可被向上（北）移动。 se-resize 此光标指示矩形框的边缘可被向下及向右移动（南/东）。 sw-resize 此光标指示矩形框的边缘可被向下及向左移动（南/西）。 s-resize 此光标指示矩形框的边缘可被向下移动（南）。 w-resize 此光标指示矩形框的边缘可被向左移动（西）。 text 此光标指示文本。 wait 此光标指示程序正忙（通常是一只表或沙漏）。 help 此光标指示可用的帮助（通常是一个问号或一个气球）。 示例：123span.crosshair &#123;cursor:crosshair;&#125;span.help &#123;cursor:help;&#125;span.wait &#123;cursor:wait;&#125; 媒介类型媒介类型允许你定义以何种媒介来提交文档，文档可以显示在显示器、纸、听觉浏览器等媒介上。 媒介类型概览注释：媒介类型名称对大小写不敏感。 1234567891011媒介类型 描述all 用于所有的媒介设备。aural 用于语音和音频合成器。braille 用于盲人用点字法触觉回馈设备。embossed 用于分页的盲人用点字法打印机。handheld 用于小的手持的设备。print 用于打印机。projection 用于方案展示，比如幻灯片。screen 用于电脑显示器。tty 用于使用固定密度字母栅格的媒介，比如电传打字机和终端。tv 用于电视机类型的设备。 示例同一个样式表中设置文档在不同媒介中的样式：123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style&gt;@media screen&#123; p.test &#123;font-family:verdana,sans-serif; font-size:14px&#125;&#125;@media print&#123; p.test &#123;font-family:times,serif; font-size:10px&#125;&#125;@media screen,print&#123; p.test &#123;font-weight:bold&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;....&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>大前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html笔记]]></title>
    <url>%2F2016%2F01%2F02%2Fweb%2FHTML%2FHtml%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文章概述 本篇文章记录html笔记。 html模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!--(!DOCTYPE)：标准通用标记语言的文档类型声明--&gt;&lt;!DOCTYPE html&gt;&lt;!--语言--&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;!--编码--&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--html网页书签栏icon--&gt; &lt;link rel="icon" type="image/x-icon" href="../images/favicon.ico"&gt; &lt;!-- META元素 通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。 --&gt; &lt;!--适配手机--&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!--为搜索引擎定义关键词:--&gt; &lt;meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript"&gt; &lt;!--为网页定义描述内容:--&gt; &lt;meta name="description" content="Free Web tutorials on HTML and CSS"&gt; &lt;!--定义网页作者:--&gt; &lt;meta name="author" content="jason"&gt; &lt;!--网页重定向--&gt; &lt;meta http-equiv="refresh" content="3; https://www.baidu.com/"&gt; &lt;!--每30秒中刷新当前页面:--&gt; &lt;meta http-equiv="refresh" content="3"&gt; &lt;!--默认链接打开方式--&gt; &lt;base target='_blank'&gt; &lt;!--默认链接地址--&gt; &lt;base href="http://liusong.site/" target="_blank"&gt; &lt;!--js语法--&gt; &lt;script type="text/javascript"&gt; //... &lt;/script&gt; &lt;!--不支持脚本js的提示--&gt; &lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt; &lt;!--引用外部的js--&gt; &lt;script src="myScript.js"&gt;&lt;/script&gt; &lt;!--css样式--&gt; &lt;style type="text/css"&gt; /*...*/ &lt;/style&gt; &lt;!--外部样式表--&gt; &lt;link rel="stylesheet" type="text/css" href="myStyle.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 常见单标签123注释：&lt;!----&gt;换行：&lt;br /&gt;水平线：&lt;hr/&gt; 文字标签(双标签)123456789101112131415161718● 段落标签：&lt;p&gt;文本内容&lt;/p&gt;● 标题标签： &lt;h1&gt;&lt;/h1&gt; 权重比较大，不利于seo，一个页面最好只出现一次； &lt;h2&gt;&lt;/h2&gt;......&lt;h6&gt;&lt;/h6&gt; 文字大小依次递减； ● 文本标签：&lt;font size=&quot;6&quot; color=&quot;red&quot;&gt;内容&lt;/font&gt;● 加粗标签： &lt;strong&gt;&lt;/strong&gt; 推荐使用(有语气强调意思) &lt;b&gt;&lt;/b&gt;● 文字倾斜标签： &lt;em&gt;content&lt;/em&gt; 推荐使用(有语气强调意思) &lt;i&gt;content&lt;/i&gt;● 删除线标签： &lt;del&gt;content&lt;/del&gt; 推荐使用(有语气强调意思) &lt;s&gt;content&lt;/s&gt;● 下划线(插入)标签： &lt;ins&gt;content&lt;/ins&gt; 推荐使用(有语气强调意思) &lt;u&gt;content&lt;/u&gt;● &lt;sup&gt;上标&lt;/sup&gt; &lt;sub&gt;下标&lt;/sub&gt; 图片属性： alt：图片不显示时的替换文本； title：提示文本，鼠标放上去的提示文字； 123&lt;img src="android.jpg" alt="hello" title="安卓" width="200" height="200" border="5"&gt; 超链接属性： href：目标地址； title：提示文字； target：打开方式（_self：当前页面打开；_blank：在新的页面中打开） 1234&lt;a href="https://www.baidu.cn" title="提示" target="_blank"&gt; 超链接&lt;/a&gt; 超链接锚点在当前页面通过设置id锚点，点击超链接滑动到锚点处； 1234// 1. 设置锚点;&lt;p id='aim'&gt;锚点&lt;/p&gt;// 2. 超链接到锚点；&lt;a href='#aim'&gt;去锚点&lt;/a&gt; 空链接1&lt;a href="#"&gt;空链接,无效链接&lt;/a&gt; 1&lt;a href=""&gt;未设置链接地址，自动跳转到base设置的标签&lt;/a&gt; 发邮件链接1&lt;a href="mailto:webmaster@example.com"&gt;点击发送e-mail&lt;/a&gt; 超链接优化写法在head中设置超链接的打开方式 123&lt;head&gt; &lt;base target='_blank'&gt;&lt;/head&gt; 特殊字符常用特殊字符123456789101112131415161718// 实体名称对大小写敏感！显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160;&lt; 小于号 &amp;lt; &amp;#60;&gt; 大于号 &amp;gt; &amp;#62;&amp; 和号 &amp;amp; &amp;#38;" 引号 &amp;quot; &amp;#34;' 撇号 &amp;apos; (IE不支持) &amp;#39;￠ 分 &amp;cent; &amp;#162;£ 镑 &amp;pound; &amp;#163;¥ 人民币/日元 &amp;yen; &amp;#165;€ 欧元 &amp;euro; &amp;#8364;§ 小节 &amp;sect; &amp;#167;© 版权 &amp;copy; &amp;#169;® 注册商标 &amp;reg; &amp;#174;™ 商标 &amp;trade; &amp;#8482;× 乘号 &amp;times; &amp;#215;÷ 除号 &amp;divide; &amp;#247; 音标符123456789音标符 字符 Construct 输出结果̀ a a&amp;#768; à́ a a&amp;#769; á̂ a a&amp;#770; ẫ a a&amp;#771; ã̀ O O&amp;#768; Ò́ O O&amp;#769; Ó̂ O O&amp;#770; Ỗ O O&amp;#771; Õ 列表无序列表无序类型（type）: disc: 默认实心圆点； square: 实心方块； circle: 空心圆点； 123456789&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt;&lt;ul type='square'&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 有序列表属性 type:（无序类型） ‘1’: 默认按1、2、3、…排序； ‘a’: 按a、b、c、…排序； ‘A’: 按A、B、C、…排序； ‘i’: 按i、ii、…排序； ‘I’: 按I、II、…排序； start:（开始的位置） 123456789&lt;ol&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt;&lt;ol type='1' start='3'&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; 自定义列表1234&lt;dl&gt; &lt;dt&gt;小标题&lt;/dt&gt; &lt;dd&gt;- 解释标题&lt;/dd&gt;&lt;/dl&gt; 音乐标签12// embed很丑，所以用hidden隐藏，音乐仍然播放；&lt;embed src='xx.mp3' hidden='true'&gt; 滚动behavior(滚动方式) alternate: 两端之间来回滚； scroll: 一端到另一端重复滚； slide: 一端滚到另一端，不重复； direction(滚动方向) down up left right loop(滚动次数) -1： 一直滚； bgcolor: 设置背景色 1234&lt;marquee behavior='slide' direction='down'height='500' width='30' bgcolor='#ff0'&gt;文字或图片&lt;/marquee&gt; 表格表格标签属性： cellspacing: 单元格之间的距离； cellpadding: 单元格内容距边框距离； align=”center”：表格居中 bordercolor=”red”: 边框颜色 表格标签css样式： border-collapse: collapse 内外边框折叠样式； 行列属性 colspan=”3”：跨列； rowspan=”4”: 跨行； align=”center”：内容居中 valign=”top|middle|bottom”: 垂直对齐方式； 1234567891011121314151617181920212223&lt;table border="1" width='200' height='500' border="1" cellspacing="2" cellpadding="2" bgcolor="#ff0" align="center"&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!--表格列的组：根据组标记设置同组样式--&gt; &lt;colgroup&gt; &lt;col span="2" style="background-color:red"&gt; &lt;col style="background-color:yellow"&gt; &lt;/colgroup&gt; &lt;tr align="center"&gt; &lt;th colspan="2"&gt;表格的表头&lt;/th&gt; &lt;th&gt;表格的表头&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元&lt;/td&gt; &lt;td&gt;表格单元&lt;/td&gt; &lt;td&gt;表格单元&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元&lt;/td&gt; &lt;td&gt;表格单元&lt;/td&gt; &lt;td&gt;表格单元&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 12345678910111213&lt;!--table标准结构：有利于seo搜索引擎优化--&gt;&lt;!--thead/tbody/tfoot只是标记不能设置属性--&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;td&gt;头部&lt;/td&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt;&lt;td&gt;底部&lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 123456&lt;!--细线表格--&gt;&lt;table width="300" height="300" bgcolor="green" cellspacing="1"&gt; &lt;tr bgcolor="white"&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表单表单1&lt;form action="xxx.php" method="get"&gt;&lt;/form&gt; action=”xx.php”: 表单的信息处理； method=”get|post”: 提交方式； 按钮1234567891011&lt;input type="submit" value="提交按钮"&gt;&lt;input type="button" value="按钮"&gt;文件上传&lt;input type="file"&gt;图片按钮&lt;input type="image" src="xxx.jpg"&gt;重置按钮&lt;input type="reset"&gt;滑块&lt;input type="range"&gt; 文本输入12345678910111213141516171819&lt;form&gt; &lt;input type="text" readonly="readonly" name="username" maxlength="6" disabled="disabled" value="默认值"&gt; &lt;input type="password"&gt; &lt;textarea name="text" rows="10" cols="30"&gt;文本域,30字符，10行&lt;/textarea&gt; 网址输入（空也能提交！！！） &lt;input type="url"&gt; 日期 &lt;input type="date"&gt; 时间 &lt;input type="time"&gt; 邮件 &lt;input type="email"&gt; 数字控件(step：递增步长) &lt;input type="number" step="2"&gt;&lt;/form&gt; 单选框123456&lt;form&gt; &lt;input type="radio" name="sex" value="male" checked="checked"&gt;男 &lt;input type="radio" name="sex" value="female"&gt;女 &lt;input type="radio" name="sex" value="other" id="other"&gt; &lt;label for="other"&gt;label&lt;/label&gt;&lt;/form&gt; 复选框12345&lt;form&gt; &lt;input type="checkbox" name="vehicle" value="Bike" checked="checked"&gt;Bike &lt;input type="checkbox" name="vehicle" value="Car"&gt;Car &lt;input type="checkbox" name="vehicle" value="Train" checked="checked"&gt;Train&lt;br/&gt;&lt;/form&gt; 下拉列表12345678910111213141516171819202122232425262728293031323334353637&lt;form&gt; 简单的下拉列表: &lt;select name="cars"&gt; &lt;option value="volvo"&gt;Volvo&lt;/option&gt; &lt;option value="saab"&gt;Saab&lt;/option&gt; &lt;option value="fiat"&gt;Fiat&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 支持多选 &lt;select name="cars" multiple="multiple"&gt; &lt;option value="volvo"&gt;Volvo&lt;/option&gt; &lt;option value="saab"&gt;Saab&lt;/option&gt; &lt;option value="fiat"&gt;Fiat&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; 预选下拉列表: &lt;select name="cars"&gt; &lt;option value="volvo"&gt;Volvo&lt;/option&gt; &lt;option value="saab"&gt;Saab&lt;/option&gt; &lt;option value="fiat" selected&gt;Fiat&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;p&gt;下拉列表-选项分组&lt;/p&gt; &lt;select&gt; &lt;optgroup label="Swedish Cars"&gt; &lt;option value="volvo"&gt;Volvo&lt;/option&gt; &lt;option value="saab"&gt;Saab&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="German Cars"&gt; &lt;option value="mercedes"&gt;Mercedes&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;/form&gt; 表单分组123456&lt;fieldset&gt; &lt;legend&gt;标题&lt;/legend&gt; 姓名: &lt;input type="text"&gt;&lt;br&gt; 邮箱: &lt;input type="text"&gt;&lt;br&gt; 生日: &lt;input type="text"&gt;&lt;/fieldset&gt; 预选列表12345678910111213&lt;form name="input" action="html_form_action" method="get"&gt; &lt;p&gt;一个预先定义的输入控件选项列表&lt;/p&gt; &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; Internet Explorer 9（更早IE版本），Safari不支持 datalist 标签。&lt;/p&gt; &lt;input list="browsers" name="browser"&gt; &lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt; &lt;/datalist&gt; &lt;br/&gt;&lt;/form&gt; 发送电子邮件12345678910111213141516171819202122232425262728&lt;!-- enctype="text/plain"表示不对特殊字符进行编码，只会将空格转为加号form的enctype属性规定在发送表单数据之前如何对其进行编码。默认地，表单数据会编码为 "application/x-www-form-urlencoded"。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 "+" 加号，特殊符号转换为 ASCII HEX 值）。--&gt;&lt;form action="MAILTO:someone@example.com" method="post" enctype="text/plain"&gt; &lt;fieldset&gt; &lt;legend&gt;表单发送电子邮件&lt;/legend&gt; Name:&lt;br&gt; &lt;input type="text" name="name" value="your name"&gt;&lt;br&gt; E-mail:&lt;br&gt; &lt;input type="text" name="mail" value="your email"&gt;&lt;br&gt; Comment:&lt;br&gt; &lt;input type="text" name="comment" value="your comment" size="50"&gt;&lt;br&gt;&lt;br&gt; send time:&lt;br&gt; &lt;select name=time&gt; &lt;option value="2015"&gt;2015&lt;/option&gt; &lt;/br&gt; &lt;option value="2016"&gt;2016&lt;/option&gt; &lt;/br&gt; &lt;option value="2017"&gt;2017&lt;/option&gt; &lt;/br&gt; &lt;/select&gt;&lt;/br&gt; &lt;input type="submit" value="Send"&gt; &lt;input type="reset" value="Reset"&gt; &lt;/fieldset&gt;&lt;/form&gt; 表单计算(IE不支持)12345678910&lt;p&gt;output:定义一个计算结果(IE不支持)&lt;/p&gt;&lt;form oninput="x.value=parseInt(a.value)+parseInt(b.value)"&gt; 0 &lt;input type="range" id="a" value="50"&gt; 100 + &lt;input type="number" id="b" value="50"&gt; = &lt;output name="x" for="a b"&gt;&lt;/output&gt;&lt;/form&gt; iframe内联框 标签规定一个内联框架。 一个内联框架被用来在当前 HTML 文档中嵌入另一个HTML文档。 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 123456789&lt;!--iframe简单使用--&gt;&lt;iframe id="aim" src="https://www.baidu.com" width="300" height="300"&gt;&lt;/iframe&gt;&lt;!--iframe去除边框--&gt;&lt;iframe src="https://www.baidu.com" frameborder="0" width="300" height="300"&gt;&lt;/iframe&gt;使用iframe来显示外部的链接页面&lt;iframe src="https://www.baidu.com" name="iframe_a"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href="http://www.taobao.com" target="iframe_a"&gt;去淘宝&lt;/a&gt;&lt;/p&gt; 标签元素分类块级元素概念块元素指的是占据全部可用宽度的元素，可以容纳内联元素和其他块元素，并且在其前后都会换行。 块元素概览123456789101112131415161718192021222324address - 地址blockquote - 块引用center - 举中对齐块dir - 目录列表div - 常用块级容易，也是css layout的主要标签dl - 定义列表fieldset - form控制组form - 交互表单h1 - 大标题h2 - 副标题h3 - 3级标题h4 - 4级标题h5 - 5级标题h6 - 6级标题hr - 水平分隔线isindex - input promptmenu - 菜单列表noframes - frames可选内容（对于不支持frame的浏览器显示此区块内容）noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）ol - 排序列表p - 段落pre - 格式化文本table - 表格ul - 非排序列表 内联(行内)元素概念内联(行内)元素指可以共处一行之内，宽高即是内容的宽高，只能容纳文本或者其他内联元素。 内联元素概览：12345678910111213141516171819202122232425262728293031a - 锚点abbr - 缩写acronym - 首字b - 粗体（不推荐）bdo - bidi overridebig - 大字体br - 换行cite - 引用code - 计算机代码（在引用源码的时候需要）dfn - 定义字段em - 强调font - 字体设定（不推荐）i - 斜体img - 图片input - 输入框kbd - 定义键盘文本label - 表格标签q - 短引用s - 中划线（不推荐）samp - 定义范例计算机代码select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strike - 中划线strong - 粗体强调sub - 下标sup - 上标textarea - 多行文本输入框tt - 电传文本u - 下划线var - 定义变量 行内块元素行内块元素常见的有： img input td CSS中块和内联元素转换1.display 块元素默认display:block;行内非替换元素(a,span)默认为display：inline;行内替换元素(input)默认为display:inline-block; 1234a.display:none;不显示该元素，也不会保留该元素原先占有的文档流位置。b.display:block;转换为块级元素。c.display:inline;转换为行内元素。d.display:inline-block;转换为行内块级元素。 2.float 当把行内元素设置完float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。 3.position 当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。]]></content>
      <categories>
        <category>大前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>大前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHubPages+Hexo搭建免费个人博客(windows平台)]]></title>
    <url>%2F2016%2F01%2F01%2FBlog%2FGitHubPages%2BHexo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(windows%E5%B9%B3%E5%8F%B0)%2F</url>
    <content type="text"><![CDATA[文章前言 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 文章概述 本篇文章记录，用github和hexo结合，搭建免费个人博客。 关键词简介Hexo Hexo 是一个基于 Nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen(https://zespia.tw/)。 博客搭建步骤1、创建Github项目 github-&gt;create new respository-&gt;项目名称：xxx(用户名).github.io 2、安装 Git3、安装 Nodejs(最好选择官方推荐版本进行下载安装)4、安装 Hexo hexo官网首页复制安装命令，打开git bash命令行工具，输入以下命令安装hexo： 1$ npm install hexo-cli -g 5、初始化本地博客输入创建命令创建并初始化本地博客： 1$ hexo init 用户名.github.io // 建议和创建仓库时使用同一个 6、安装Next博客主题注：经过上面步骤创建完本地博客之后，基本的博客系统就已经搭建好了，自带了 landscape 主题。 默认的主题此处不做介绍，这里我们使用Next主题，Next是 iissnan 在 GitHub 上开源的一个 Hexo 主题，主打简洁。 命令行工具定位到xxx.github.io本地目录，执行以下命令安装next主题： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载好了next主题到themes目录下，做好备份，接下来我们就直接配置_config.yml主题文件。 7、修改配置文件相关配置，本地预览配置效果 注: 这里修改博客根目录xxx.github.io目录和主题目录themes/next目录下的_config.yml配置文件，一定注意，==属性和值之间一定要有一个空格==。 【站点配置文件】(博客根目录下的_config.yml)基本项修改基础的配置，也就是必须要改动的配置如下： 12345678title: xxx # 博客的名字，也称站点名称author: xxx # 作者名字description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义（这个还是加上比较好）language: zh-Hans # 语言 简体中文theme: next # 配置主题deploy: # 部署相关配置 type: git # 使用 Git 提交 repo: https://github.com/xxx/xxx.github.io.git # 就是存放博客的仓库地址 站点配置文件详细配置示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客title: xxx # 博客的名字，也称站点名称subtitle: xxx # 副标题description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义author: xxx # 作者名字language: zh-Hans # 语言 简体中文timezone: # 用默认的即可# URL # 这项暂时不需要配置，绑定域名后，要创建 sitemap.xml 时再配置该项## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: # http://xxx.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory# 目录，不要修改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing # 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format # 日期 / 时间 格式，不要修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination # 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions # 配置站点所用主题和插件，这里将默认主题注释，修改为 next## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next#theme: landscape# 头像# 注意：是 xxx.github.io/source 下的开始的相对路径，如果 source 文件夹下面没有 uploads 文件夹，那么新建一个。考虑到会博客中用很多图片，在 uploads 文件夹下请分好类，避免混乱avatar: /uploads/images/avatar.jpg# Deployment # 本地博客部署到 github 上要配置这里## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 使用 Git 提交 repository: https://github.com/xxx/xxx.github.io.git # 就是存放博客的仓库地址 到这里，我们的博客基本可以在本地预览了，下面来看看效果： 输入以下命令，启动本地预览服务1$ hexo server 根据命令行提示，在浏览器输入预览地址(http://localhost:4000/)，查看效果。 【Next主题配置】Next主题配置文件“，位于 xxx.github.io/themes/next 目录下，文件名为 _config.yml。 详细配置见next官网，一下是基本的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Set default keywords (Use a comma to separate)# 设置关键字keywords: &quot;Android, DIY&quot;# Specify the date when the site was setup# 设置博客开始时间since: 2016# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)# 设置菜单，就是[我的博客](http://diy-green.github.io)左侧那一列menu: home: / # 在菜单上显示首页 archives: /archives # 在菜单删显示全部 categories: /categories # 在菜单上显示 分类 tags: /tags # 在菜单上显示 标签 about: /about # 在菜单上显示 关于 #commonweal: /404.html# Schemes# 设置风格#scheme: Musescheme: Mist # 紧凑风格，推荐使用#scheme: Pisces # 双栏风格# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true # 设置是否显示阅读全文，文章较多的话，有必要设置为 true length: 150# 一些第三方服务设置，详情见参考官方介绍# 这里说明：评论建议用网易云跟帖，多说评论系统将于2017-06-01停止使用。# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme#highlight_theme: normal# 代码高亮主题highlight_theme: night eighties# 友情链接links_title: Linkslinks: 个人主页: http://cnlius.com/ 提示：创建如分类、标签等索引，必须使用创建命令进行创建，否则报404，分类和标签索引是由主题根据文章的头属性设置来自动维护。 8、MarkDown写博客文章注意 写*.md格式的博客文章，需要在文章头加类似如下设置，next主题才会自动对文章进行分类： 1234567891011---title: xxx # 文章标题categories: - Android # 一级分类- Android Studio # 二级分类tags: - Android- Android Studiocomments: true #开启评论date: 2016-12-16--- 9、本地运行预览服务，查看效果git bash定位到xxx.github.io文件夹根目录，输入以下命令启动本地预览服务器： 1$ hexo s 在浏览器中输入以下地址，查看效果： http://localhost:4000 10、生成博客并部署到远程GitHubPage上安装hexo自动部署工具使用如下命令进行安装 1$ npm install hexo-deployer-git --save 发布到GitHubPages方法一：依次执行如下命令来发布博客： 123$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令$ hexo g #生成静态网页$ hexo d #开始部署 方法二：也可一行命令完成发布： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 不同电脑上更新博客问题 我的方法是：将xxx.github.io文件夹内更改的文件备份到github上，在另一台电脑上下载更改的配置文件，按以上步骤配置好本地博客环境，将下载的文件覆盖到xxx.github.io文件夹中即可。 将域名绑定到github pages 博客上 在xxx.github.io仓库根目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如:test.com),不需要添加http/www等前缀。 ping xxx.github.io记录下IP地址: 1$ ping username.github.io 阿里云购买域名解析如下： 解析属性设置： 方法一：记录类型选CNAME类型,添加两个主机记录分别是@和www,记录值填写博客地址(推荐)。 方法二：记录类型选A类型,添加两个主机记录分别是@和www,记录值填写上一步ping出来的博客ip地址。 hexo部署博客常用命令 创建新的索引页面 案例1：创建分类页面 1$ hexo new page categories 案例2：创建标签页面1$ hexo new page "tags" More info: Writing 启动本地预览服务 1$ hexo server More info: Server 生成静态网页文件 1$ hexo generate More info: Generating 部署到远程 1$ hexo deploy More info: Deployment 一行命令实现博客的部署：clean,generate,deploy 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布博客常见问题用户名密码问题问题描述：执行如下命令：1$ hexo d 报错 12//...fatal: could not read Username for &apos;https://github.com&apos;: No error 原因：应该是用户名和密码没有的问题？ 解决办法修改配置文件：根目录下的_config.yml，修改deploy节点。 原来的配置为： 123deploy: type: git repo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git 修改为如下： 123deploy: type: git repo: https://&#123;yourname&#125;:&#123;yourpassword&#125;@github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
